<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只放拖鞋的鞋櫃</title>
  
  <subtitle>程式中的迷途小書僮</subtitle>
  <link href="https://jchu.cc/atom.xml" rel="self"/>
  
  <link href="https://jchu.cc/"/>
  <updated>2023-01-10T01:24:15.197Z</updated>
  <id>https://jchu.cc/</id>
  
  <author>
    <name>Walkingice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>關於台灣交通的雜感</title>
    <link href="https://jchu.cc/2023/01/09-transportation.html"/>
    <id>https://jchu.cc/2023/01/09-transportation.html</id>
    <published>2023-01-08T15:16:58.000Z</published>
    <updated>2023-01-10T01:24:15.197Z</updated>
    
    <content type="html"><![CDATA[<p>這應該算是資質駑鈍：長到三十多歲的年紀，我才理解到交通之於生活的重要性。</p><p>除了現在旅居日本，我還有幾次到國外出差的經驗，短時間內在不同國家的街道步行而明顯感受到衝擊，對於台灣的交通環境更有感觸。在此整理我對台灣交通的看法與期待，以後跟朋友討論到交通問題就能以此篇文章出發，不需要什麼事都從頭講。</p><p>更希望拋磚引玉，看到這篇文章的鄉親，也抒發自己對台灣交通的看法，促進公共討論，推動交通意識改變，進而改善生活環境。我不天真地認為幾十年的沈痾會在短時間內被革除，但是先把問題講清楚，講久了，眾人才有病識感。</p><p>先有病識感，才知道有病要治，接著各種處方建議才會被接受。</p><span id="more"></span><p style="color: #AAA">免責聲明：我的經驗告訴我，有些事情進入政策細節或是科學判斷的時候，常會出現與直覺不符的答案。所以並非交通專業的我理所當然會出錯，也期待有人指正我，順勢推廣更多交通知識。</p><h2 id="出差看見的美國交通瞥見台灣的影子"><a href="#出差看見的美國交通瞥見台灣的影子" class="headerlink" title="出差看見的美國交通瞥見台灣的影子"></a>出差看見的美國交通瞥見台灣的影子</h2><div style="max-width: 100%; margin: auto;"><img src="/2023/01/08-transportation/austin.jpg" class=""></div><p>講到美國的第一印象就是國土寬廣。有次出差去了德州，德州為美國第二大州，當然也是幅員遼闊。上圖是在德州首府 Austin 隨手拍下的照片，照片主角是建築物，在街頭很輕易就能看見的，平凡無奇的停車場。台灣也是有大型停車場，但是比起德州人如此豪爽地使用土地，隔沒幾條街就能蓋起停車大樓，寸金寸土的台灣都會區實在阮囊羞澀，只能在空間隙縫中擠出停車格。</p><p>另外兩張圖，我記得是 35 號州際公路跟 E 6th Street 的路口，從旅館的高處往這看，每天都能看見綿延不斷的回堵塞車。當時頗為驚訝，就算德州也有塞車之苦。可見不管國土再大，通勤時刻的都會區路口就是會塞車。</p><p>即便如此，汽車仍然是美國「正常生活」的低標，擁有自己的汽車才有自由移動的能力，才是正常的成年人。這樣的思維其實台灣相當熟悉，滿十八歲最重要的一件事情就是考到駕照，騎著摩托車實現交通能力的自由。</p><p>美國國土遼闊，台灣呢？我不曾聽過任何人用「大」形容台灣，雖然我們並非迷你小國，但絕對不會有人覺得台灣很大。</p><p>不過，如果要比人口密度，台灣就很厲害了。</p><p>從維基百科的<a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%9B%BD%E5%AE%B6%E5%92%8C%E5%9C%B0%E5%8C%BA%E4%BA%BA%E5%8F%A3%E5%AF%86%E5%BA%A6%E5%88%97%E8%A1%A8">人口密度列表</a>來看，世界上 200+ 的國家、地區裡，台灣排名 20。密度更高的有摩納哥、直布羅陀、梵蒂岡這些真正迷你的地方，前面 19 個只有 3 個比台灣大，其他甚至比苗栗國 1800 平方公里還要小。也就是說台灣的人口密度可說世界頂尖，更別提台灣多數人口都聚集在西側。</p><p>人口如此密集的國家，交通政策卻向美國看齊，這個大方向就註定台灣交通會有困境</p><ul><li><a href="https://opinion.udn.com/opinion/story/8048/2842031">從車的城市到人的城市：台灣該向美國汽車文化看齊？ - 廖桂賢</a></li></ul><h2 id="台灣的交通困境與螺旋"><a href="#台灣的交通困境與螺旋" class="headerlink" title="台灣的交通困境與螺旋"></a>台灣的交通困境與螺旋</h2><p>雖然心裡知道「台灣的交通不是很好」，但自小在台灣長大，早已經習慣車水馬龍，似乎也沒什麼太大的問題。直到三十歲後經常往返各國，仔細體會行走國外街道的感覺，接著飛了幾個小時回到台灣，踏上原本熟悉的馬路：這路況真糟糕啊！</p><p>撇除特異的台北市不談，以私人交通工具為主的台灣家庭，評比交通效率的考量往往是這兩點</p><ul><li>從家裡出門能夠多快到目的地</li><li>停車後需要步行多久到目的地</li></ul><p>政府對改善交通的承諾，也都是滿足上述兩點為主。遇到交通的民怨，往往會開新路或增設快速道路，接著在終端想辦法擠出停車場或停車格。台灣發展觀光的方式也大致如此，任何觀光景點遇上交通問題，只要情況允許就會盡可能開路。於是在某個縣市的兩個景點之間可能會不斷地開新路，或是拓寬原有道路。</p><p>在台灣文化裡開路等同建設，建設等同選票支持，這是地方政治的要點：不管真實需求的高低，能建設馬路，地方就願意支持。誰敢反對就是跟選票過不去。</p><p>從這樣的文化，就能勾勒出台灣的交通困境的原因。不論開了幾條順暢的路，終端永遠都是人多的地方，難以生出停車位。本來就腹地狹小的城鎮或景點，湧入的車輛永遠高於停車位數量，自然產生的結果就是大家各憑本事隨意停車，先天停車位不足，後天要靠執法補救也只會累積民怨。</p><p>停車問題會影響旅遊品質。雖然台灣好山好水，但是許多知名觀光景點的旅遊體驗相當糟糕，家庭出遊最大的精神消耗就是塞車與停車。</p><p>就算不談出遊，一般家庭的停車問題就已經很嚴重。新建的大樓通常都有地下停車場容納住戶的車輛，情況可能好一點。但早期的房子沒有考慮到停車位，所以住戶都是在家附近尋找車位，有些停車位處於灰色地帶，也常耳聞鄰居間因為停車問題產生糾紛。更何況現在一個家庭常常需有兩台車，又有多少人家裡有兩個停車格？</p><p>台灣也有人嘗試反制，也就是以檢舉的方式減少違停。遵守交通條例的人認為，已經付出成本，把自己的生活方式調整成不需要依靠違規，為什麼還要忍受其他人的違規降低自己的生活品質？但是對許多人而言，模糊地帶的停車一直都是生活的一部分，為何長時間累積而成的默契要被不知名的人打破？</p><p>當兩方發生衝突，民意代表自然成為解決衝突的角色。但是全國上下不曾對交通戰略做出通盤檢討，局部的法規取締必然收效甚微，不免猜出民意代表最後會如何取捨。</p><p><a href="https://www.thenewslens.com/article/135482">要消滅檢舉達人，形象清新的賴品妤為何成為「羅淑蕾第二」？</a></p><h2 id="以大眾交通為主的東京地區"><a href="#以大眾交通為主的東京地區" class="headerlink" title="以大眾交通為主的東京地區"></a>以大眾交通為主的東京地區</h2><p>用我比較熟悉的東京地區 (涵蓋千葉、埼玉與神奈川)，住在這塊地區的人，多半不用買車。或著換個角度說，不買車的人也能夠在這塊地區找到落腳處。</p><p>整個大東京地區，由 JR、都營地鐵與各種私鐵交織出相當綿密的網絡，之外還有各家公車補足沒有被鐵路網涵蓋到的區域。多數人選擇住宅的方式就是以車站為中心，走路十五分鐘內能到的地方就算是能夠住人的範圍。再遠一點的人，便會選擇用自行車作為接駁工具。多數大樓以及車站外都有自行車停車場，由於停車的限制，自行車 + 鐵道往往會比騎摩托車要來得方便。</p><p>如果要比喻的話，整個東京就是捷運跟人行道更密集，去掉大量摩托車的台北市。我相信規劃東京自由行的外國，多半不需要考慮租車的問題。</p><div style="max-width: 100%; margin: auto;"><img src="/2023/01/08-transportation/sidewalk.jpg" class=""></div><p>雖然東京也是寸土寸金，保護行人路權卻不馬虎。不只有完整的人行道，許多鬧區，例如銀座或秋葉原，在週末還會實施行人天國，該路段禁止汽車駛入，讓行人安心地逛街消費。</p><p>出了東京地區的交通，如果目的地是知名景點，經常還是有電車或公車可以抵達。如果一定要開車，可以選擇轉乘電車之後再開車。我以前去富士山附近玩都是全程開車，最近幾次都是坐電車到小田原之後再租車，省去中間的長途開車與塞車隱憂。用台灣的地理位置來比喻，若從台北想去日月潭玩，與其直接開車，不如先搭高鐵到台中烏日站，再租車前往日月潭。</p><p>在東京地區，絕大多數的交通需求都能用大眾交通工具滿足，開車的必要性被降低之後，停車的問題也減少許多。如果沒有特殊的需求(譬如載老人或嬰幼兒)，往往搭鐵道的體驗優於自駕。</p><h2 id="交通影響生活"><a href="#交通影響生活" class="headerlink" title="交通影響生活"></a>交通影響生活</h2><p>東京跟台灣的交通方式如此不同，那麼對生活有哪些影響呢？</p><p>生活中能做的事情，取決於我們能行動的範圍。青少年就是最好的例子，步入高中之後開始發展個人興趣，想做的事情愈來愈多，但是若缺少父母接送，很多想做的事情都做不了。我這種鄉下長大的小孩，真正能夠嚐到自由的滋味，是滿 18 歲之後家裡為我買了一台摩托車才開始。</p><p>但是自由的生活，又會在結婚生子後瞬間崩毀。我有很多朋友的小孩已經是國小的年紀。同事早早到公司不是因為勤奮，是因為要配合小孩的上學時間。至於放學，幸運的人早早準時下班去接小孩，不夠幸運的人就是再多花一筆錢，把小孩送去安親班待到下班時間為止。</p><p>日本就不是這樣。日本人在升上小學之後，多數就會開始自己上學，有些是完全步行，有些會轉乘電車、公車。年紀再大一點，就能自己坐車出遠門，早早就能體會到獨立的感覺。</p><div style="max-width: 100%; margin: auto;"><img src="/2023/01/08-transportation/students.jpg" class=""></div><p>我個人的直覺，房價也跟交通有關。在日本租房的地點選擇方式，其實還滿像台北市，車站十分鐘步行距離為最佳。不同的是電車涵蓋的網路比台北市更大更密集，房屋的選項也更多。以我之前通勤的距離為例，我從出門到坐進辦公室的時間大約是 70 分鐘，通勤的距離約 30 km。</p><p>有時候在想，如果把同等級的鐵路網放到台北市，從台北車站拉 30 公里都到大溪了。但是在大台北地區捷運的覆蓋密度不比東京地鐵，選項少房價自然高。至於沒捷運的省轄市，情況更是悲慘。</p><p>並非日本人不開車，而是在日本的都會區，人們有很多不開車的選擇，道路硬體的建設也會優先考量行人，同時也是照顧社會弱勢，那些沒能力開車的老人、小孩，或是負擔不起車價的人。</p><p>但是在台灣，每個人都沒有選擇的餘地，只能開車或騎車，只能跳進道路的修羅場掙扎求生。</p><h2 id="台灣交通有沒有改變的機會？"><a href="#台灣交通有沒有改變的機會？" class="headerlink" title="台灣交通有沒有改變的機會？"></a>台灣交通有沒有改變的機會？</h2><p>我舉不出什麼專業的論點作為理論基礎，只是我個人會希望台灣交通能在這兩點上做出改變</p><ul><li>更多的大眾交通工具</li><li>更多的人行道</li></ul><p>台灣人口高度密集，腹地也不算遼闊。若能用鐵路之類的工具建成網絡，「CP值」應該要比日本還高。人們有了開車騎車以外的選擇，才有可能降低道路上的壓力，接著才去要求民眾做出更好的駕駛行為(停車、禮讓行人)。也才能釋放空間，施作人行道。</p><p>然而民眾已經習慣使用汽機車作為工具，糟糕的路況多數人也習以為常，我還真不敢期待有哪位民意代表或民選首長，敢去做任何丟選票，短期內看不出成果的交通改革。但是台灣這個死結已經綁了幾十年，絕不是抽一兩個線頭就能解開，只能祈禱哪天出現一位有遠見的交通部長，訂下長遠的戰略，逐步改變台灣的交通方針。至於這個結該從何解起，我還真沒有頭緒</p><p>不過對於任何社會秩序問題，我的原則都會是「工程先於規範」。先在工程面增加安全係數，再從規範面去要求駕駛做出更好的行為。比起大刀闊斧地蓋大眾交通系統，或許改善現有的道路工程、標線劃設，會更適合台灣這種高度在意 CP 值的國家吧。</p><ul><li><a href="https://www.twreporter.org/a/sidewalk-pedestrian-traffic-safety">被稱「行人地獄」的台灣──為何我們的馬路設計不安全？</a></li><li><a href="https://www.twreporter.org/a/sidewalk-pedestrian-roadmarking-advocates">「撞死人才想改」太慢，兩位「馬路醫生」日常道路改造大作戰</a></li></ul><p>每個人都會被交通影響生活，同時每個人也在影響交通，我們還是有些能做的小事，聚沙成塔慢慢推動交通的改革</p><ul><li>對行人多些同理心<ul><li>我們都有當行人的機會，友善行人的環境，對我們自身也有好處</li><li>同時把這種想法分享給親友，擴散影響力。</li><li>正如自己家裡的長輩或小孩走在路上，我們也希望他們行走得安全、安心，能被其他駕駛尊重。</li></ul></li><li>開車出門多預留時間緩衝，讓自己開車的心情不要過度緊繃<ul><li>留有餘裕的行車心態，也能減少事故機率</li><li>行車事故的成本很高，小則時間金錢，大則生命安全，搶快實在不划算</li></ul></li><li>觀察生活周遭的人行動線<ul><li>正如前述，先有病識感就很夠了。</li><li>觀察自己常走的路段，有哪些不舒服的地方，或是不合理的設計。</li><li>行有餘力者再向當地的民意代表提出想法，要求他們改進。</li></ul></li></ul><p>交通的變革需要無比的耐心，難收速效。話說回來，搞不好幾十年後，台灣的交通問題與高房價問題，會因為人口數大幅減少而自然痊癒？(笑)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;這應該算是資質駑鈍：長到三十多歲的年紀，我才理解到交通之於生活的重要性。&lt;/p&gt;
&lt;p&gt;除了現在旅居日本，我還有幾次到國外出差的經驗，短時間內在不同國家的街道步行而明顯感受到衝擊，對於台灣的交通環境更有感觸。在此整理我對台灣交通的看法與期待，以後跟朋友討論到交通問題就能以此篇文章出發，不需要什麼事都從頭講。&lt;/p&gt;
&lt;p&gt;更希望拋磚引玉，看到這篇文章的鄉親，也抒發自己對台灣交通的看法，促進公共討論，推動交通意識改變，進而改善生活環境。我不天真地認為幾十年的沈痾會在短時間內被革除，但是先把問題講清楚，講久了，眾人才有病識感。&lt;/p&gt;
&lt;p&gt;先有病識感，才知道有病要治，接著各種處方建議才會被接受。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="government" scheme="https://jchu.cc/tags/government/"/>
    
  </entry>
  
  <entry>
    <title>政治參與程度之我見</title>
    <link href="https://jchu.cc/2022/11/27-political.html"/>
    <id>https://jchu.cc/2022/11/27-political.html</id>
    <published>2022-11-27T12:47:25.000Z</published>
    <updated>2022-11-27T15:09:30.919Z</updated>
    
    <content type="html"><![CDATA[<p>在不同地方政治人物旁邊看多了，覺得不同政治參與程度的人可以被歸分到不同的族群。而且不同族群的人對於政治會有不同的想像與感受</p><p>當然以下的想法沒有任何數據佐證，純粹就是我的個人看法。</p><span id="more"></span><h1 id="簡單分類"><a href="#簡單分類" class="headerlink" title="簡單分類"></a>簡單分類</h1><p>根據不同的參與程度，我會粗略分成下面四個族群。每次聽到任何人講地方的政治八卦，我就會先將對方分類到以下其中一個群體，當作我驗證對方說話可性度的參考。</p><div style="max-width: 100%;" class="img-row"><img src="/2022/11/27-political/group.svg" class=""></div><ul><li>政客：沒有貶意，純粹是為了省字。除了檯面上民意代表與官員，還泛指該人周圍的幕僚與黨工</li><li>樁腳：我常說這些人吃政治飯的人。舉凡什麼社區發展協會主委、里幹事、某某協會理事長…等等。這些人最常向政客要各種補助經費，也是吃飯喝酒的主揪。也包括許多協會成員，或是義消之類的。</li><li>鄉親：並非直接靠政治維生，但是工作上常跟前兩者往來。通常會是家裡做生意，或是跟樁腳私交不錯的人</li><li>公民：基本上講不出自己家附近有什麼阿里不搭協會的人，多半就在這裡了。多數小本生意人或上班族都在這裡面。</li></ul><p>鄉親跟公民是我硬湊出來的詞，只是不想用「民眾A/B」來指稱兩者。</p><p>鄉親跟公民的比例，在服務業興盛的都會區跟農業比例高的鄉下不同，移入人口多的新市鎮，與人口老化的老市鎮也不一樣。</p><h1 id="所謂地方聲音"><a href="#所謂地方聲音" class="headerlink" title="所謂地方聲音"></a>所謂地方聲音</h1><p>基本上政客與助理都很忙，會期之外就是跑行程參加各種活動，或是各種會勘去現場看看東西蓋德有沒有問題，又或著是處理大小的選民服務。所以政客實際上並沒有辦法真正地接觸到普羅大眾</p><p>你如果覺得很奇怪，沒有做民調的時候，到底哪來的「地方聲音」？其實就是樁腳的聲音。</p><p>那些樁腳就是整天到處跑，努力做 1) 跟政客混熟 2) 跟其他樁腳混熟 3) 跟民眾A 混熟。政客最直接的管道，就是聽到樁腳告訴他的消息。</p><p>但是樁腳也有自己的利害關係，而且他能接觸的「民眾」最多也只到鄉親。比較有良心的樁腳會傳達鄉親的心聲，沒良心的就玩資訊操弄，賣給政客有利自己的資訊。</p><p>沒有民調的時候，政客只能高度仰賴樁腳，或是熟識的鄉親的意見。如果你家那邊的政客如果幹了什麼鳥事，若不是為了私利，多半就是這一層在亂搞。</p><h1 id="政治謠言"><a href="#政治謠言" class="headerlink" title="政治謠言"></a>政治謠言</h1><p>地方謠言的出現，大致上都是這樣</p><ul><li>樁腳A：「弄成這樣，我覺得老王搞不好會出來選立委」</li><li>樁腳B：「C 我跟你講，A 說他覺得老王會出來選立委」</li><li>樁腳C：「我聽 B 說老王可能會出來選立委」</li><li>樁腳D：「聽說老王要出來選立委了」</li><li>樁腳E：『誰説的』</li><li>樁腳D：「B 講的，應該很可靠」</li></ul><p>雖然樁腳的工作是傳遞訊息，但並非傳遞精準的訊息。所以很多地方耳語起源於樁腳的個人臆測。</p><p>即使是同黨的政客，也偶有利益衝突，也常常會是選舉的對手，所以政治人物之間的訊息交換非常不透明，並沒有公民所想的那麼團結一致。如果沒有派系頭來排解，就會有很多樁腳介入的空間。</p><h1 id="選舉的資訊傳遞"><a href="#選舉的資訊傳遞" class="headerlink" title="選舉的資訊傳遞"></a>選舉的資訊傳遞</h1><p>按照通常的理解，我區分成陸戰、空戰以及傳統媒體。選舉的時候就是透過資訊的傳遞去影響鄉親與公民的意願</p><h2 id="陸戰"><a href="#陸戰" class="headerlink" title="陸戰"></a>陸戰</h2><p>平常看到誰挺誰，就是政客指揮樁腳要支持誰。樁腳本身人數不算多 (但在地方基層選舉也是稍有影響)，但是樁腳很能影響鄉民，鄉民的數量就可觀多了，多席次的民意代表選舉只要掌握好這個就有保證的席次</p><p>「比起陌生人，把資源分享給自己熟識的人」我覺得算是人類的動物本能。對於公民而言，平常就會打招呼聊天的鄉親，選舉的時候若是沒接收到太強烈的政治訊息，投票意向就很容易被鄉親影響。</p><p>陸戰能夠影響的有樁腳、鄉親，還有一部分的公民。</p><h2 id="空戰"><a href="#空戰" class="headerlink" title="空戰"></a>空戰</h2><p>沒有時間跟資源養樁腳跟鄉親，所以新興候選人多半只能從網路打空戰。但是空戰其實直接影響的也有限，除了公民圈裏面對政治比較在乎的一塊，以及稍微進一點的鄉親。</p><p>於是空戰的間接影響就很重要，如何透過公民裡面的有色圈，把自己形塑成值得選的人，推銷給公民無色圈。公民無色圈其實也不懂那麼多艱深的理論，也沒多堅定的意志。「反正我也沒特別想投誰，既然我那朋友都說這個人不錯，那就投他吧」</p><p>空戰能夠影響的範圍就是有色公民圈，以及一部分無色公民圈。能影響到多少廣？不知道</p><p>對，這就是空氣票</p><h2 id="傳媒"><a href="#傳媒" class="headerlink" title="傳媒"></a>傳媒</h2><p>說某傳媒沒顏色，在台灣應該沒人相信吧。反正選舉期的傳媒就是宣傳機器，藍綠各取所需。</p><p>傳媒對於選舉的影響很強烈。陸戰的論述基本上是從傳媒的主軸變化而來。譬如說某民代質疑疫苗採購不法，樁腳就在看新聞的時候煽風點火：「那個一定有貪啦，騙我們不知道」。當然也可能反操作：「那個都是假的，媒體被操控了」</p><p>空戰也會被影響，當傳媒的某個議題發酵且對候選人不利的時候，有色公民圈就要向無色圈努力解釋。無色圈的人就變成整天看新聞說 A，偶爾聽朋友說 B，接著覺得政治真的很煩。</p><h2 id="聊天群組"><a href="#聊天群組" class="headerlink" title="聊天群組"></a>聊天群組</h2><p>我沒在圖片畫出來，但我會把 LINE/FB 群組歸類在陸戰。雖然這些是數位工具，但是用法其實相當傳統。其實就是把以前在榕樹下或街尾聚在一起罵對方陣營的作法，搬到數位工具上，而且執行得更有效率。</p><p>這種聊天室不是用來論理辨是非，而是用來傳播特定論點。</p><h1 id="2022-地方選舉的雜想"><a href="#2022-地方選舉的雜想" class="headerlink" title="2022 地方選舉的雜想"></a>2022 地方選舉的雜想</h1><p>我覺得 2020 的民進黨內總統初選，大致上就是傳統的賴清德陸戰派與蔡英文空戰派的對決，延續到總統選舉結束可說是小英完全勝利。我想從政者都很明白陸戰的重要，這不必贅言。但是蔡跟黨內派系競爭的時候 (沒有人天真到以為民進黨內一派和諧吧？)，想要推的人通常基層實力也不比傳統派系，有限資源下只能更多倚賴空戰。</p><p>於是在那之後，各個空戰側翼的自信與聲量就愈加膨脹，連帶也影響著綠營網路支持者的態度。遇到風向不順的議題就變得敏感且富攻擊性。</p><p>近年來的各大議題，對執政黨有意見的人不都被指教過一輪？同黨內有意見的人貼上叛徒的標籤。看那違規停車還會對警員施壓，陰德值已經很低的徐巧芯，都能夠挖出側翼群組要出征的難堪新聞給自己得意一陣。這些側翼網軍不是持續在削弱民進黨在空戰的實力嗎？</p><p>誠如前述，空戰是要靠間接的影響力，透過口碑的傳遞把政令或候選人推銷出去。但是現在民進黨空軍愈加極端，燒光陰德值後以前願意講話的淺色公民圈的人明哲保身只能站得遠一點，論述就傳不出去了。第一層的人沒意願討論，傳統媒體更沒有興趣追蹤。</p><p>那麼最外面的人聽到的是什麼呢？各種論文的花絮。結果就是傳統媒體表演大亂鬥，聽不太懂政治的人就覺得煩了。</p><p>總體來說我覺得空戰其實影響有限，但是在風向不太糟糕的時候，能夠激起淺色公民圈甚至到無色那一塊的認同。但是這個傳遞鏈已經被那些劍走偏鋒的側翼弄斷了</p><p>你我這種「會看部落格文章的中產階級上班族」，多半都是最外圈的邊緣人。坦然面對吧，無足輕重的我們就算跳樓也不見得會上新聞，我們說的話也沒什麼份量。想要幫綠營的話，只要不添亂不到處罵人，讓身邊無色圈的朋友覺得「其實台獨份子也是很務實的」就功德無量了</p><p>民主沒有特效藥，台獨也沒有。來得快的東西，去得也快。台獨這條線要走得穩，只能在現實中，慢慢取得一位又一位的認同</p><p>把那些做哏嘲諷反對者，用力嘶喊誰是叛徒，或是整天叫你疼惜民進黨的帳號，尤其是不知道本尊的帳號全部封掉吧，那些是阻礙民進黨重新前進的絆腳石</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在不同地方政治人物旁邊看多了，覺得不同政治參與程度的人可以被歸分到不同的族群。而且不同族群的人對於政治會有不同的想像與感受&lt;/p&gt;
&lt;p&gt;當然以下的想法沒有任何數據佐證，純粹就是我的個人看法。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 雙冒號 ::someMethod 的觀察</title>
    <link href="https://jchu.cc/2022/09/04-kotlin.html"/>
    <id>https://jchu.cc/2022/09/04-kotlin.html</id>
    <published>2022-09-03T15:09:44.000Z</published>
    <updated>2022-09-03T16:20:44.478Z</updated>
    
    <content type="html"><![CDATA[<p>寫 kotlin 的時候經常會看到 <code>::myMethod</code> 的出現，本文觀察編譯器的結果去猜測可能的過程。並非真正地去閱讀規格或源碼。若有寫不正確的地方，還請鄉親指正</p><span id="more"></span><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>有時候在實作中，我們會自製一些可被觀察的物件 Observable，以及觀察者 Observer。然後在 Fragment 結束的時候拔掉 Observer。Observer 的實作就用 lambda 解決</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.addObserver &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.removeObserver &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>上面的片段一看就知道很有問題，因為新增跟刪除傳遞進去的東西很明顯不是同一個物件實體。通常會生出一個 private field 來指向同一個物件實體。但如果寫成這樣呢？能夠順利地移除掉 Observer 嗎？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.addObserver(::doSomething)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.removeObserver(::doSomething)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>先說結論：<strong>運氣好的話，可以。</strong></p><p>這邊引出幾個問題</p><ul><li>為什麼可以？在哪些情況下可以？</li><li>究竟 <code>::doSomething</code> 這段做了什麼事？</li><li>或著問，<code>::doSomething</code> 總是回傳同樣的東西嗎？(Singleton?)</li></ul><p>在那之前，我先岔題談一下 Lambda</p><h1 id="Lambda-是如何傳遞的"><a href="#Lambda-是如何傳遞的" class="headerlink" title="Lambda 是如何傳遞的"></a>Lambda 是如何傳遞的</h1><p><a href="https://kotlinlang.org/docs/lambdas.html">Lambda</a> 鄉親都用得很爽，常聽到函式在 Kotlin 裡面是 First-class，就文件跟編譯的結果來看，Kotlin 是透過 <code>kotlin.jvm.functions.Function0</code> 或是類似的內部類別來實作，這東西就跟 Java 的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html">Method</a>差不多。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">observable.addObserver &#123;</span><br><span class="line">    println(<span class="string">&quot;===Inside lambda&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myFunc = <span class="keyword">object</span> : Function0&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;====Inside function&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">observable.addObserver(myFun)</span><br></pre></td></tr></table></figure><p>這兩個寫法都可以只是上方的 Lambda 會產生一個匿名類別(anonymous class)，通常用數字取名 <code>$1</code>，底下會產生一個 <code>$myFunc</code>的類別。放編譯檔案的目錄 <code>app/build/...</code> 裡面就能找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$myFun$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$1.class</span><br></pre></td></tr></table></figure><p>用 javap 去看，會發現兩個東西很像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">$ javap <span class="string">&#x27;./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$1.class&#x27;</span></span><br><span class="line">Compiled from <span class="string">&quot;MyObservableTest.kt&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">foooo</span>.<span class="title">baaar</span>.<span class="title">MyObservableTest</span>$<span class="title">testInstance</span>$1 <span class="keyword">extends</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">internal</span>.<span class="title">Lambda</span> <span class="keyword">implements</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">functions</span>.<span class="title">Function0</span>&lt;<span class="title">kotlin</span>.<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> foooo.baaar.MyObservableTest$testInstance$<span class="number">1</span> INSTANCE;</span><br><span class="line">  foooo.baaar.MyObservableTest$testInstance$<span class="number">1</span>();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFun</span></span><br><span class="line">$ javap <span class="string">&#x27;./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$myFun$1.class&#x27;</span></span><br><span class="line">Compiled from <span class="string">&quot;MyObservableTest.kt&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">foooo</span>.<span class="title">baaar</span>.<span class="title">MyObservableTest</span>$<span class="title">testInstance</span>$<span class="title">myFun</span>$1 <span class="keyword">implements</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">functions</span>.<span class="title">Function0</span>&lt;<span class="title">kotlin</span>.<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">  foooo.baaar.MyObservableTest$testInstance$myFun$<span class="number">1</span>();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兩個都實作了 <code>Function0</code>，這就有點像是 Runnable 的介面，<a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/function-types.md">Kotlin Function Type</a> 是這麼寫的</p><ul><li>On JVM, introduce Function0..Function22, which are optimized in a certain way, and FunctionN for functions with 23+ parameters. When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.</li><li>Also on JVM (under the hood) add abstract FunctionImpl which implements all of Function0..Function22 and FunctionN (throwing exceptions), and which knows its arity. Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.</li></ul><p>也可以看一下 JVM 的實作<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/FunctionImpl.java">FunctionImpl.java</a></p><p>小結：使用 Lambda 的時候，Kotlin 會自動幫你實作一個匿名類別，你傳遞過去的東西其實是這個匿名類別的實體化物件</p><h1 id="雙冒號-class-java-在幹嘛？"><a href="#雙冒號-class-java-在幹嘛？" class="headerlink" title="雙冒號 ::class.java 在幹嘛？"></a>雙冒號 ::class.java 在幹嘛？</h1><p>這是 Kotlin 使用 <a href="https://kotlinlang.org/docs/reflection.html">Reflection API</a> 的方法。Java 也有一套 Reflection API，讓你能做一些見不得光的事情，尤其測試的工具經常大量使用到 Reflection。在 Java 裡面通常會先拿到一個叫做 Class 的類別，然後用那個類別動態挖出一些 Method 來用。在 Kotlin 裡面，除了能用 Java 的 Class，做了很多對應的類別，好比 <code>KClass</code>，加個 K 就是 Kotlin 界的東西。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> j: Class&lt;Foobar&gt; = Foobar::<span class="keyword">class</span>.java</span><br><span class="line"><span class="keyword">val</span> k: KClass&lt;Foobar&gt; = Foobar::<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>這個範例加上了型別，所以就很清楚知道 <code>MyClass::class.java</code> 是使用 Reflection API 去拿到 Java 界的 <code>Class</code> 類別，而 <code>MyClass::class</code> 是拿到 Kotlin 界的 <code>KClass</code> 類別。</p><p><code>::class.java</code> 就相當於以前的 <code>object.getClass</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> j: Class&lt;Foobar&gt; = Foobar::<span class="keyword">class</span>.java</span><br><span class="line"><span class="keyword">val</span> obj = Foobar(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> oldSchool: Class&lt;Foobar&gt; = obj.javaClass</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;oldSchool === j&#125;</span>&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>小結：<code>::class</code> 是使用 Reflection API 的方法，用來拿到 <code>KClass</code> 這個類別</p><h1 id="雙冒號-someFunc-在幹嘛？"><a href="#雙冒號-someFunc-在幹嘛？" class="headerlink" title="雙冒號 ::someFunc 在幹嘛？"></a>雙冒號 ::someFunc 在幹嘛？</h1><p>前面是用 <code>::class</code>，但如果到我們的主角，雙冒號後面接個 method 呢？雖然同樣用 <code>::</code> 都是 Reflection，但是此時的行為不一樣。</p><p>Kotlin 是個語言，跑在 JVM 上面只是這個語言的其中一種實作。只論 JVM 這部分的話，Kotlin 遇到 <code>::someFunc</code> 的處理方式，跟前面的 lambda 很像，都是產生一個匿名類別，然後傳遞出去。</p><p>而且 <code>類別::someFunc</code> 跟 <code>物件::someFunc</code> 雖然都是產生出 <code>Callable</code> 的物件，但是兩者有所不同。懂 JS 的人，想像一下 <code>Function.prototype.apply()</code>就知道了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foobar = Foobar(<span class="string">&quot;Foobar&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> funSpeakA: KFunction&lt;<span class="built_in">Unit</span>&gt; = foobar::speak</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line">funSpeakA.call()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funSpeakB: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak</span><br><span class="line"><span class="comment">// runTime 會爆出 IllegalArgumentException Callable expects 1 arguments, but 0 were provided.</span></span><br><span class="line">funSpeakB.call()</span><br><span class="line"><span class="comment">// 塞一個 Instance 給它就可以了</span></span><br><span class="line">funSpeakB.call(foobar)</span><br></pre></td></tr></table></figure><p>在上面的例子，生出 funSpeakB 的時候根本不知道<code>this</code> 是誰，所以會生出一個需要傳入 Foobar 實例的函式物件。</p><p>既然知道這麼多「生出匿名類別與 Callable 物件」的技巧，可以看看這段程式碼會生出幾個匿名類別？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foobar = Foobar(<span class="string">&quot;Foobar&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funSpeakA: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak <span class="comment">// 從 class 產生</span></span><br><span class="line"><span class="keyword">val</span> funSpeakB: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak</span><br><span class="line"><span class="keyword">val</span> funSpeakC: KFunction&lt;<span class="built_in">Unit</span>&gt; = foobar::speak <span class="comment">// 從 instance 產生</span></span><br><span class="line"><span class="keyword">val</span> funSpeakD: () -&gt; <span class="built_in">Unit</span> = foobar::speak</span><br><span class="line"><span class="keyword">val</span> funSpeakE: () -&gt; <span class="built_in">Unit</span> = foobar::speak</span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver(funSpeakD)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br></pre></td></tr></table></figure><p><strong>答案是「8個」</strong>，abcde 各五個，以及 addObserver 那三行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakA$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakB$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$2.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$3.class</span><br></pre></td></tr></table></figure><p>而且看 Java 的 byte code，還真的都是拿不同的類別來做事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">18</span>: getstatic     #<span class="number">49</span>  <span class="comment">// Field investigate/reflection/mypkg/Tester$testReflection$funSpeakA$1.INSTANCE:Linvestigate/reflection/mypkg/Tester$testReflection$funSpeakA$1;</span></span><br><span class="line"> <span class="number">21</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">24</span>: astore_3</span><br><span class="line"> <span class="number">25</span>: getstatic     #<span class="number">54</span>  <span class="comment">// Field investigate/reflection/mypkg/Tester$testReflection$funSpeakB$1.INSTANCE:Linvestigate/reflection/mypkg/Tester$testReflection$funSpeakB$1;</span></span><br><span class="line"> <span class="number">28</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">31</span>: astore        <span class="number">4</span></span><br><span class="line"> <span class="number">33</span>: <span class="keyword">new</span>           #<span class="number">56</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1</span></span><br><span class="line"> <span class="number">36</span>: dup</span><br><span class="line"> <span class="number">37</span>: aload_1</span><br><span class="line"> <span class="number">38</span>: invokespecial #<span class="number">57</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">41</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">44</span>: astore        <span class="number">5</span></span><br><span class="line"> <span class="number">46</span>: <span class="keyword">new</span>           #<span class="number">59</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1</span></span><br><span class="line"> <span class="number">49</span>: dup</span><br><span class="line"> <span class="number">50</span>: aload_1</span><br><span class="line"> <span class="number">51</span>: invokespecial #<span class="number">60</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">54</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">57</span>: astore        <span class="number">6</span></span><br><span class="line"> <span class="number">59</span>: <span class="keyword">new</span>           #<span class="number">64</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1</span></span><br><span class="line"> <span class="number">62</span>: dup</span><br><span class="line"> <span class="number">63</span>: aload_1</span><br><span class="line"> <span class="number">64</span>: invokespecial #<span class="number">65</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">67</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">70</span>: astore        <span class="number">7</span></span><br><span class="line"> <span class="number">72</span>: aload_2</span><br><span class="line"> <span class="number">73</span>: aload         <span class="number">6</span></span><br><span class="line"> <span class="number">75</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"> <span class="number">78</span>: aload_2</span><br><span class="line"> <span class="number">79</span>: <span class="keyword">new</span>           #<span class="number">71</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$1</span></span><br><span class="line"> <span class="number">82</span>: dup</span><br><span class="line"> <span class="number">83</span>: aload_1</span><br><span class="line"> <span class="number">84</span>: invokespecial #<span class="number">72</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">87</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">90</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"> <span class="number">93</span>: aload_2</span><br><span class="line"> <span class="number">94</span>: <span class="keyword">new</span>           #<span class="number">74</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$2</span></span><br><span class="line"> <span class="number">97</span>: dup</span><br><span class="line"> <span class="number">98</span>: aload_1</span><br><span class="line"> <span class="number">99</span>: invokespecial #<span class="number">75</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$2.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"><span class="number">102</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"><span class="number">105</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"><span class="number">108</span>: aload_2</span><br><span class="line"><span class="number">109</span>: <span class="keyword">new</span>           #<span class="number">77</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$3</span></span><br><span class="line"><span class="number">112</span>: dup</span><br><span class="line"><span class="number">113</span>: aload_1</span><br><span class="line"><span class="number">114</span>: invokespecial #<span class="number">78</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$3.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"><span class="number">117</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"><span class="number">120</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br></pre></td></tr></table></figure><p>現在知道了 <code>::someFunc</code> 就像 lambda 一樣，會生出匿名類別，並產生 Instance 來用。而且，<strong>如果 ::someFunc 有兩行，就會產生兩個</strong>，知道這個問題的答案之後，也很容易回答另外一個問題。</p><p>既然都是用不同的類別來產生實體，當然不是回傳同樣的東西，絕對不是 Singleton</p><h1 id="什麼時候可以讓-removeObserver-如預期般運作"><a href="#什麼時候可以讓-removeObserver-如預期般運作" class="headerlink" title="什麼時候可以讓 removeObserver 如預期般運作"></a>什麼時候可以讓 removeObserver 如預期般運作</h1><p>那麼第一個問題，在什麼情況下可以這麼用呢？這跟 Observer 的實作有關。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObservable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> list: MutableList&lt;MyObserver&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">triggerObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addObserver</span><span class="params">(observer: <span class="type">MyObserver</span>)</span></span> &#123;</span><br><span class="line">        list.add(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">MyObserver</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> index = list.indexOfFirst &#123; it == observer &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            list.removeAt(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實作的關鍵點就在 <code>removeObserver</code> 那邊，如果找到同樣的 observer 就拿掉，所以用 lambda 的時候很自然地就會拿不掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line">println(<span class="string">&quot;Size A: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver &#123; someFunc() &#125;</span><br><span class="line">println(<span class="string">&quot;Size B: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.removeObserver &#123; someFunc() &#125;</span><br><span class="line">println(<span class="string">&quot;Size C: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是如果改用 <code>::someFunc</code> 竟然會動！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line">println(<span class="string">&quot;Size A: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver(::someFunc)</span><br><span class="line">println(<span class="string">&quot;Size B: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.removeObserver(::someFunc)</span><br><span class="line">println(<span class="string">&quot;Size C: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0 !!</span></span><br></pre></td></tr></table></figure><p>明明是不同類別產生的物件，為什麼可以順利被對應到？鄉民們一定馬上就想到<strong>因為 <code>==</code> 被改寫了！</strong></p><p>既然 Kotlin Relection 是產生 <code>KFunction</code> 介面的時候，那我們來看一下 JVM 平台的實作 <a href="https://github.com/JetBrains/kotlin/blob/b8b0b279ee2195ccbdce61e2365f123ee928532b/core/reflection.jvm/src/kotlin/reflect/jvm/internal/KFunctionImpl.kt#L176">KFunctionImpl</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> that = other.asKFunctionImpl() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> container == that.container &amp;&amp; name == that.name &amp;&amp; signature == that.signature &amp;&amp; rawBoundReceiver == that.rawBoundReceiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我沒有繼續深追下去確認細節，看起來是用相同 Reflection API 方法產生的類別都會在這邊被視為同一個東西。所以在上方的 Observer 實作就能用 <code>==</code> 找到「同一種東西」</p><p>我們可以用 <code>System.identityHashCode()</code> 找出物件的 hash code 來確認，其實它們真的不是同一個物件。也因此，如果在 <code>Observerable.removeObserver</code> 裡面用 <code>===</code> 當作比對的方法，就會發現原本可以 remove 的作法行不通了。這也就是我在一開始就說「運氣好的話，遇到用 <code>==</code> 來比對的實作，就可以這樣傳 <code>::someMethod</code> 進去」</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫 kotlin 的時候經常會看到 &lt;code&gt;::myMethod&lt;/code&gt; 的出現，本文觀察編譯器的結果去猜測可能的過程。並非真正地去閱讀規格或源碼。若有寫不正確的地方，還請鄉親指正&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="java" scheme="https://jchu.cc/tags/java/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Anki 的基本介紹與自訂卡片</title>
    <link href="https://jchu.cc/2022/09/01-anki.html"/>
    <id>https://jchu.cc/2022/09/01-anki.html</id>
    <published>2022-09-01T13:16:06.000Z</published>
    <updated>2022-09-01T15:27:39.964Z</updated>
    
    <content type="html"><![CDATA[<p>Anki 是相當知名的單字背誦軟體，但是製作卡片的方法不是很容易理解，本篇文章嘗試從軟體阿宅的角度做基本的介紹</p><span id="more"></span><p>光是看中文寫作能力，就已經比許多台灣人還要厲害的畢靜翰也說<a href="https://www.facebook.com/john.barthelette/posts/pfbid0EyfaNKzdjf8pW5X7SVuxinrfsoeStQpfeJXZW78ReoCek5YMCyn375ZAeSmfNheXl">學語言需要有技巧地背單字</a>，強者都這麼說了，當然要試著把這件事情做好。</p><p>正所謂工欲善其事，必先利其器，我們軟體阿宅，最喜歡花時間把工具弄好。就像很多人會花好幾天調整 Blog 的樣式，然後三年寫不到一篇。寫不寫 Blog 不是重點，重點是我們寫 Blog 的工具一定要夠順夠好用。同理，能用 Anki 背多少單字一點都不重要，重要的是能夠造出比別人更細膩的單字卡，這才是我們關心的部分。</p><h1 id="要做出怎樣的卡片"><a href="#要做出怎樣的卡片" class="headerlink" title="要做出怎樣的卡片"></a>要做出怎樣的卡片</h1><p>小畢那篇文章對於 Anki 用法的建議，大致整理要點如下</p><ul><li>正面寫上英文單字，譬如<code>Cone</code></li><li>背面寫上中文解釋，並且加上例句，例句裡面要把生字挖空，譬如<code>圓錐或圓錐體 The ____is gone: VLC Media Player silently banned in India</code></li></ul><p>就我的額外理解，對於這個單字要產生兩張卡片。一張卡片是扔出英文單字，考你中文意思；另一張卡片是扔出中文，要你在英文例句裏面填空。當你卡片數量累積夠多的時候，就可以偶爾考你英翻中，偶爾考你中翻英，兩邊夾攻之下聽起來效果會很不錯。</p><p>然而，但是，不過，But，我現在想學的是日文，學日文多了一個「漢字」要背。</p><p>漢字該怎麼安排？我想了很久都想不到一個合理的做法。我試過分別產生漢字跟假名的卡片來背誦，可是這樣效果很差。舉例來說「便利(べんり)」這個字，漢字跟中文解釋完全一樣，這樣產生的卡片就很尷尬。</p><p>我最近才想通，就單純背單字來說，我不應該去背漢字。就像完全不會寫漢字的日文小學生，全部寫假名然後用講的也能溝通，我應該要把假名當成英文，然後背誦的假名跟中文解釋的關係，譬如「正面：べんり；反面：很方便；東京の生活は…ですね」，漢字則當成一個補充學習的東西，反正對台灣人來說漢字大多數都不難。</p><p>所以我的目標就是做出這樣的卡片</p><ul><li>正面：假名</li><li>背面：中文解釋、挖空生字的例句</li><li>可選(optional) 的註釋，預設都是隱藏起來，直到按下去才會顯示出來</li></ul><p>這樣我就能用背英文單字的方式去背日文，真的想要知道額外訊息的時候再去偷看一下註釋的東西。</p><h1 id="Anki-的基本介紹"><a href="#Anki-的基本介紹" class="headerlink" title="Anki 的基本介紹"></a>Anki 的基本介紹</h1><p>剛開始碰 Anki 的阿宅都會搞不太懂牌組或卡片之類的關係，會覺得有點混亂。如果從軟體宅的角度來解釋，我會用資料庫的方式去解說</p><ul><li>整個 Anki 筆記就是一個資料庫<ul><li>不懂程式的人，可以想像是一個 Excel 檔案</li></ul></li><li>筆記類型(Note Type) 就是一個 Table<ul><li>可以想像是一個 Excel 檔案裡面有好幾個工作表(Sheet)，一個 Note Type 就是一個 Sheet</li></ul></li><li>筆記(Note) 就是 Table 裡面的一個 Row<ul><li>可以想像是某個 Sheet 裡面的某一筆資料</li></ul></li><li>卡片就是某一個 Row (筆記) Render 出來的結果，就像 Select 語句<ul><li><code>SELECT front_col, back_col, comment_col FROM MY_NOTE;</code> 產生第一堆卡片，正面顯示假名，背面顯示中文解釋與例句</li><li><code>SELECT back_col, front_col, comment_col FROM MY_NOTE;</code> 產生第二堆卡片，正面顯示中文解釋與例句，背面顯示假名</li><li>可以想像是把 Sheet 裡面的資料匯出成各種花俏的資料</li></ul></li><li>牌堆(Deck)就是前述 SELECT 出來的卡片，分組放到不同的地方<ul><li>可以想像是把匯出的花俏資料，放到不同的資料夾：「給上司看的」「呼嚨投資人的」</li></ul></li></ul><p>用資料庫的表格來看，大概會像這樣</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/tables.svg" class=""></div><ul><li>有兩個 Note type，一個叫 JP，一個叫 Eng</li><li>JP 裡面有三筆 Notes</li><li>Eng 裡面有兩筆 Notes</li></ul><p>實際上 Anki 裡面是怎麼儲存這些資料呢？我沒有去看源碼所以並不清楚。不過沒關係，真正搞懂原理才動手，這是舊時代骨灰程式設計師才會做的事情，身為後現代軟體宅，歷經各種 Scrum 的調教，我們明白 time to market 比什麼都重要。所有東西都可以視為黑盒子，只要 INPUT 對，OUTPUT 對，就可以上線出貨。為了可以趕快進到改介面那個階段，我們不用管 Anki 存資料的真正方式。</p><p>突破心魔之後，一切就海闊天空，要做的事情就變得很明確</p><ul><li>新增一個符合我們目標的 Note Type<ul><li>要有 Front</li><li>要有 Back</li><li>要有 Comment</li></ul></li><li>該 Note Type 要能夠針對每筆 Note 生出兩張卡片<ul><li>一張問你 假名 =&gt; 意思、例句</li><li>一張問你 意思、例句 =&gt; 假名</li></ul></li><li>針對卡片修改外觀<ul><li>Comment 預設隱藏，點一下才會顯示</li></ul></li><li>輸入 Note 新增需要背誦的資料<ul><li>其實可以用 CSV 檔匯入，但我懶得紀錄了</li></ul></li><li>Optional(可省略)：使用 Anki 背單字</li></ul><h1 id="開始自訂格式"><a href="#開始自訂格式" class="headerlink" title="開始自訂格式"></a>開始自訂格式</h1><h2 id="產生我們的-Note-Type"><a href="#產生我們的-Note-Type" class="headerlink" title="產生我們的 Note Type"></a>產生我們的 Note Type</h2><p>其實你也可以用現成的 Note Type，但是自己土砲一個是軟體宅基本美德，我們永遠都會嫌棄，看不上毫無個性的預設值。</p><ul><li>打開 Anki desktop 版</li><li>點上方的 Browse</li><li>從左邊的 side bar 找到 Note Type，按右鍵選 Manage Note Types</li><li>打開 Note Types 對話框之後，點 Add</li><li>在顯示的 Add Note Type 對話框裡面，先隨便選個基本的 Add: Basic，取名叫 <code>JP</code></li></ul><p>至此已經產生 Table，但是 Table 裡面的欄位不對，所以我們來修改一下</p><ul><li>在 Note Types 對話框點剛剛新增的 <code>JP</code>，然後選右邊的 Fields</li><li>在打開的 Field 對話框點 Add，新增一個欄位叫做 HiddenComment，於是就會有三個欄位<ul><li><code>Front</code> - 這是預設的</li><li><code>Back</code> - 這是預設的</li><li><code>HiddenComment</code> - 我們新增的</li></ul></li></ul><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_add_field.jpg" class=""></div><p>Save 之後就完成了這個階段</p><h2 id="針對-Note-生出兩張卡片"><a href="#針對-Note-生出兩張卡片" class="headerlink" title="針對 Note 生出兩張卡片"></a>針對 Note 生出兩張卡片</h2><ul><li>回到 Notes Type 對話框，選了 <code>JP</code> 之後點右邊的 <code>Cards</code> 按鈕，打開 Cards Types for JP 對話框</li><li>點右上方的 Options 選 Add Card Type，預設的名字是 Card2</li></ul><p>以後 <code>JP</code> 這個 Note Type 每新增一筆資料，就會根據 Card1 跟 Card2 定義的樣式生出兩張卡片了</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_add_type.jpg" class=""></div><p>截圖裡面兩張卡片的敘述看起來不是很好懂，它的格式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[順序]: [卡片類型名稱]: [正面卡片欄位] -&gt; [背面卡片欄位]</span><br></pre></td></tr></table></figure><p>改名字只能改到 <code>卡片類型名稱</code> 那一塊，剩下的都是自動產生的提示，正面跟背面卡片的欄位會由下一節的內容來決定</p><h2 id="針對卡片修改外觀"><a href="#針對卡片修改外觀" class="headerlink" title="針對卡片修改外觀"></a>針對卡片修改外觀</h2><p>重頭戲來了，展示我們軟體宅與眾不同的地方就是在這裡，首先我們先改 Card1 的外觀</p><ul><li>在 Card Types for JP 的對話框，在 Card Type 選 Card1</li><li>接著左邊 Template 是我們動工的地方，右邊 Preview 就是…Preview 啦！<ul><li>Front template - 卡片正面的版型，通常也就是提問的那一面</li><li>Back template - 卡片背面的版型，也就是回答的那一面</li><li>Style - 給你放超陽春 CSS 的地方，Template 跟 Style 分開來是基本起手式了</li></ul></li></ul><p>有寫過網頁的一看就知道這很像 mustache 之類的模板語言，在 front template 裡面填入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;front&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Front&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很簡單地把<code>Front</code> 欄位的內容放到 div 裡面，接著在 back template 裡面填入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Back&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hint-container&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;hint:HiddenComment&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&#123;&#123;hint:HiddenComment&#125;&#125;</code> 是 Anki 的特殊標記，告訴 Anki 要把 <code>HiddenComment</code> 這個欄位的內容視為 <code>Hint</code>，而 Hint 就會被 Anki 暫時隱藏起來，直到我們點下去才會顯示內容。接著輸入 Style</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.8rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hint</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hint-container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#AAA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就完成了 Card1 的外觀修改，接著 Card Type 選 Card2，繼續改它的 Front template。這次我們調換順序，在正面顯示 <code>Back</code> 欄位的內容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;front&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Back&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Back Template 顯示 <code>Front</code> 欄位的內容，於是我們就能夠用同一個 Note，產生出不同方向的問法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">id</span>=<span class="string">answer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Front&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hint-container&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;HiddenComment&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至於 Styles 的話，Card1 跟 Card2 都是共用同一個，所以不用再修改了。儲存之後就搞定這一切了</p><h2 id="編輯資料"><a href="#編輯資料" class="headerlink" title="編輯資料"></a>編輯資料</h2><p>前述的東西只要做一次就好，以後只要專心新增資料就好。有時候我們會被混淆，雖然介面上說的是「新增卡片」，但實際上你新增的是 Note。我猜應該是要對一般使用者講清楚 Note 跟 Card 的差別太麻煩，所以新增的時候只會跟你說「新增卡片」，實際上真正的操作是在「新增筆記(Note)」</p><p>也因此，你在卡片瀏覽器裏面，對某一張卡片點右鍵，怎樣都找不到「刪除卡片」的選項。因為 Card 是根據 Note 畫出來的結果，你真正要刪除的東西其實是 Note</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_toggle.jpg" class=""></div><p>在卡片瀏覽器的上方，可以透過 toggle widget(那個 N，原本是 C) 快速切換到 Note，這時候按右鍵就可以看見刪除的按鈕。正如我們前面的製作，讓一個 Note 可以生出兩張 Card，這邊刪除了一個 Note，理所當然會刪除對應的兩張 Card。</p><p>至於 Deck(牌組) 的部分，我覺得不用做太多。其實一個或兩個就很夠用了，畢竟學習的方法是要創一個單字池，持續地把生字丟進去，讓 Anki 根據時間撈出來給你複習，我們大家腦筋都不好，每天能背的就是那幾個。所以一個 Deck 就很夠用，除非要背單字以外的其他東西，才比較需要弄不同的 Deck。如果考試前要加強複習的話，目前的做法都是利用 Filter，創立一個暫時的 Deck，把單字卡都丟進去，考完試之後再把該 Filter 刪掉，這樣就不會影響原本 Deck 的進度。</p><p>以上就是對 Anki 的簡單介紹。身為軟體宅的你，現在已經能夠假裝自己對於 Anki 軟體本身有一定程度的熟悉，還能夠透過 CSV 檔一次匯入上千個單字，顯示出客製化過的幾千張卡片。別人只會用預設卡片老實地背單字，我們就能夠好好地炫耀：「看看我的 Anki 卡片，多美啊！」</p><p>工具調整得差不多之後，可以安心地把 Anki 關掉了。</p><div style="max-width: 500px;" class="img-row"><img src="/2022/09/01-anki/donotask.jpg" class=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Anki 是相當知名的單字背誦軟體，但是製作卡片的方法不是很容易理解，本篇文章嘗試從軟體阿宅的角度做基本的介紹&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="tools" scheme="https://jchu.cc/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>我的死刑議題立場</title>
    <link href="https://jchu.cc/2022/08/27-2022-08-26.html"/>
    <id>https://jchu.cc/2022/08/27-2022-08-26.html</id>
    <published>2022-08-26T15:00:06.000Z</published>
    <updated>2022-08-26T15:18:07.652Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有重大刑案，不免俗地死刑議題又再被提出來討論。我又不是意見領袖，當然談不上什麼倡議或說服。只是習慣性自言自語，紀錄當下我的看法，或許多年後會有不同的立場。</p><p>就結論來說，我的立場比較偏向廢除死刑。</p><span id="more"></span><p>開場不免俗要來個免責聲明。我並不認識任何廢死聯盟的人，我對他們做的事情只有很淺薄的了解，偶爾看到轉貼文章的那種程度。我所說的任何東西，僅僅只能代表我個人。</p><p>我的立場之所以傾向廢除死刑，取決於我對國家系統的理解，這份理解大致上可以歸納成幾項</p><ul><li>法律需要保留一定程度的彈性空間，實務上才能運作</li><li>審判系統永遠都有缺陷，也會產生失誤<ul><li>只要判死刑的人夠多，絕對會有少數的幾例屬於量刑過重</li></ul></li><li>過長的刑期或許可以藉由金錢給予當事人補償，但是死刑完全不可逆也無法對當事人補償</li></ul><p>以前跟朋友聊這個時，朋友曾說「那就把法律修成『罪證確鑿』者才判死刑」。但是這點是法律條文做不到的事情。</p><p>首先光是「證據確鑿」就是一個很難精確定義的事情。死刑不是開玩笑的，我相信所有的法官在判下死刑之前，在他心中衡量的那把尺，無疑認定嫌犯就是證據確鑿。甚至可以推論，只要不是存心貪污的法官，量刑的當下都是覺得符合他心中的道德正義。</p><p>其次，五個人看到 A 殺人，這樣算證據確鑿嗎？四個大人一個小孩呢？五個嗜好是霸凌人的小流氓呢？法律沒辦法用這種量化的數字來定義何謂證據確鑿。更別說現在各種科技持續進步，以往能夠被當成證據的錄音、影像，都可能隨著愈來愈強大的造假技術而變得難分真假。</p><p>當然，最近發生的殺警案，我們可以說這算是「證據確鑿」，我完全同意。但是法律該怎麼寫呢？難不成附註「當社會大眾一致同意，可視為證據確鑿」這樣嗎？不可能吧。</p><p>意思是說，沒有辦法寫出一個完美的敘述句，把現實生活中可能發生的各種兇殺案，區分成證據確鑿與尚有疑義兩大塊，這是其一。</p><p>法官也是人，也會有他的立場與偏見。樹大有枯枝，整個司法體系裡面總是會有一些位置坐很高，但是你深交後就只想搖頭的人，就算我們排除掉人的因素，客觀的證據也可能會因為科技的進步而有不同的解釋方法。又或著，隨著時間推移而出現翻盤的證據而影響判決。</p><p>一個必定會模糊的條文框架，以及無法完美精確的審判系統，就絕對會有量刑不精確的結果。</p><p>我說的量刑不精確，當然包括了應該要判更重刑的混蛋逃過一劫。</p><p>近幾年比較成人故事的遊戲，都喜歡描述世事難兩全的故事。現實生活也是這樣，有些光鮮亮麗的人私底下是混蛋，有些看起來可憐的人其實也是混蛋一個，許多糾紛其實就是混蛋跟混蛋在吵架，但是我們沒辦法分辨究竟是哪個混蛋該被打屁股，於是只能夠訂出一個不偏頗的規則，然後我們遵循這個規則讓社會運作。我們希望正義被實現，但我們只能透過公平的規則去趨近多數人認同的正義，但我們只能趨近而無法到達。</p><p>(所以正義女神之所以蒙著眼，就因為世人多是混蛋，看不出來哪個比較好啊！)</p><p>換個方向，那些窮凶惡極的重大刑犯該死嗎？我也希望這些人可以死一死，並非為了希望受害家屬被安慰，是我單純就看到混蛋死了覺得感覺很痛快，我承認自己不過是個容易憤怒的鄉民。沒有信仰的我缺乏宗教大愛，覺得受害者家屬從來都沒必要原諒什麼。看到嫌犯上香被家屬追打的畫面，我只會冷笑一聲活該。</p><p>只是談到死刑時，我會忍不住想到整個系統的缺陷，以及跑得夠久就遲早會扔出的 Exception。對於絕大多數泯滅人性的傢伙我沒什麼憐憫，但只要想到上千人裡面可能會有一個罪不致死的混蛋，我就會猶豫拿掉死刑能不能是個選項？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近又有重大刑案，不免俗地死刑議題又再被提出來討論。我又不是意見領袖，當然談不上什麼倡議或說服。只是習慣性自言自語，紀錄當下我的看法，或許多年後會有不同的立場。&lt;/p&gt;
&lt;p&gt;就結論來說，我的立場比較偏向廢除死刑。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>Android 的 View.canScrollVertically 的誤讀</title>
    <link href="https://jchu.cc/2022/08/24-android_scroll.html"/>
    <id>https://jchu.cc/2022/08/24-android_scroll.html</id>
    <published>2022-08-24T13:54:19.000Z</published>
    <updated>2022-08-28T06:41:17.686Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 官方文件裡面有個 <code>View.canScrollVertically</code>，起初我認為這個 API 文件寫錯了，後來再看了更多文件，才覺得是我的誤會。</p><span id="more"></span><p>官方文件是這麼寫的</p><blockquote><p>public boolean canScrollVertically (int direction)</p><p>Check if this view can be scrolled vertically in a certain direction.<br>direction: Negative to check scrolling up, positive to check scrolling down.</p></blockquote><p>如果傳入小於零的值，而 View 可以往上 Scroll 的時候，<code>View.canScrollVertically(-1)</code> 會回傳 <code>true</code>。</p><p>看起來很簡單，但是當我們實際去測試，明明「手指還能往上滑」的時候，這個 API 竟然會回傳 <code>false</code>，怎麼跟觀察到的結果不一樣？是不是文件剛好寫反了？</p><p>其實這個 scroll 並非「手指往上 scroll」，而是「視窗/Viewport 往上 scroll」，因此我們要區分 Scroll 跟 Drag 的差別。</p><div style="max-width: 60%;" class="img-row"><img src="/2022/08/24-android_scroll/gesture.png" class=""></div><p><strong>Scroll</strong> 的概念是來自於滑鼠的時代，我們把滑鼠滾輪往上滾，就是 <strong>Scroll up</strong>，也就是把 Viewport 往上方移動，但是在 Touch panel 的時代，<strong>Drag down</strong>(往下拖動) 會有同樣的效果。</p><p>網頁 JS 裡面的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo">window.scrollTo</a>，也是同樣的效果，傳入座標後，實際上就是把 <code>Viewport 的 (left, top)</code> 移動到給定的 <code>(x, y)</code></p><p><strong>Scroll 是在移動 Viewport/Window</strong></p><p>這樣去思考的話，回頭看 Android API 就會得到相同的答案了。</p><p>前一陣子在寫內部的文件時，我也一直常被混淆：「大家都在講 scroll，到底是 scroll 什麼」。太常在手機上面開發的人，很容易就把 Scroll-up 想像成「手指按著螢幕，由下往上滑」，如果團隊裡面沒有把這件事情講清楚，Web deverloper 跟 Mobile app developer 很容易就雞同鴨講。</p><p>嚴格說起來沒有受詞的 drag 也是曖昧不明，譬如說 Drag-down 究竟是把 View 往下拖動，還是透過 Drag 的動作把畫面移動到底下呢？</p><p>至少我自己寫文件的時候會盡量遵循這樣的規則</p><ul><li>scroll 的作用對象都是 Viewport，scroll up 就是把 view port 往上方移動</li><li>drag 是手指在螢幕上的拖動方向，drag down 就是手指按著螢幕，往下滑</li></ul><p>Update:</p><p>官方的 <a href="https://developer.android.com/develop/ui/views/touch-and-input/gestures/scroll">Animate a scroll gesture</a> 也有提到這部分</p><blockquote><p>“Scrolling” is a word that can take on different meanings in Android, depending on the context.<br>Scrolling is the general process of moving the viewport (that is, the ‘window’ of content you’re looking at)</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android 官方文件裡面有個 &lt;code&gt;View.canScrollVertically&lt;/code&gt;，起初我認為這個 API 文件寫錯了，後來再看了更多文件，才覺得是我的誤會。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Overlord - Escape from Nazrick</title>
    <link href="https://jchu.cc/2022/06/25-escape_from_nazarick.html"/>
    <id>https://jchu.cc/2022/06/25-escape_from_nazarick.html</id>
    <published>2022-06-24T19:25:29.000Z</published>
    <updated>2022-08-24T12:52:03.876Z</updated>
    
    <content type="html"><![CDATA[<p>I just finished the game, Overlord Escape from Nazarick. I was playing the SWITCH version, and I would like to make some notes.</p><span id="more"></span><p>The first thing is the map. This is the map I drawed manually, it is svg file with CC0 license.</p><div style="max-width: 100%;" class="img-row"><img src="/2022/06/25-escape_from_nazarick/overlord-escape_from_nazarick-map.svg" class=""></div><p>If you want the map without grid lines: <a href="/2022/06/25-escape_from_nazarick/overlord-escape_from_nazarick-map-no_lines.svg" title="overlord-escape_from_nazarick-map-no_lines.svg">overlord-escape_from_nazarick-map-no_lines.svg</a></p><p>TODO: add location for all memory fragments.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;I just finished the game, Overlord Escape from Nazarick. I was playing the SWITCH version, and I would like to make some notes.&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>GnuPG 基本觀念與指令介紹</title>
    <link href="https://jchu.cc/2022/05/17-gnupg.html"/>
    <id>https://jchu.cc/2022/05/17-gnupg.html</id>
    <published>2022-05-16T16:25:27.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>GnuPG 應該是絕大多數 Linux user 或是開發者都用過的工具。說起來真不好意思，十多年前剛開始工作的時候就用過它，懵懵懂懂查了幾個常見指令就擺著不放。現在終於振作起來，稍微多花點時間，重新認識這個工具</p><span id="more"></span><p>看完文件之後覺得最後的結論很簡單，但是使用前要弄清楚的一些基本觀念四散在不同的文件，而且 gpg 的指令介面也不是很友善，使得一開始的門檻弄得有點高。我試著整理出我覺得比較容易理解的順序</p><h1 id="Gpg-使用層的基本邏輯"><a href="#Gpg-使用層的基本邏輯" class="headerlink" title="Gpg 使用層的基本邏輯"></a>Gpg 使用層的基本邏輯</h1><p>眾所皆知，Gpg 是用來做加密、簽章等等功能的工具，從使用的角度來看，我們可以這麼理解它的邏輯</p><ul><li>抽象概念上，Gpg 是以「人的身份」為主體來互動</li><li>一個人可能有不同的身份，譬如說工作上的名字叫 Julian，在社群裡面互動又叫 Walkingice</li><li>你可以把這些身份跟你本人合併起來，也可以創造出一個全新的身份，達到匿名的效果</li><li>彼此簽章的時候，實際上是在做「這個人宣稱這個身份為他所有，我也同意這個說法」</li><li>每一個身份就是由一份 Primary Key pair 與數個 Uid 組合而成</li><li>每一個 Primary Key pair 底下可以掛許多個 subkey</li></ul><p>畫成圖例就有點像這樣</p><div style="max-width: 100%;" class="img-row"><img src="/2022/05/17-gnupg/gpg.svg" class=""></div><p>舉例來說，我身為一位中年大叔</p><ul><li>我可以生出一組 Primary Key pair，用來當作我在社會活動的身份<ul><li>從工作開始認識我的朋友，習慣叫我 Julian<ul><li>所以我可以在這個 Primary Key pair 底下創造一個 uid 為 <code>Julian</code></li></ul></li><li>從社群開始認識我的朋友，習慣叫我走冰<ul><li>所以我可以在這個 Primary Key pair 底下創造一個 uid 為 <code>Walkingice</code></li></ul></li><li>兩邊的朋友都知道叫我 Julian 或是 Walkingice，不管用哪個稱謂都沒問題</li><li>任何一邊的朋友，簽章認證我這份 Primary Key pair，是在認同我這個身份<ul><li>換句話說：「我同意這個 Primary Key pair 的所有人是 Julian，也就是 Walkingice」</li></ul></li></ul></li><li>但是我可能在大家不知道的地方，其實是個有變裝癖，並以此賺取斗內為生的肥宅，而這個身份我不想給任何親友知道<ul><li>所以我會生出另外一組 Primary Key pair，用來當作我在賺皮肉錢的身份<ul><li>在這個 Primary key 底下，我可以創造一個 uid 為 <code>FatTuber</code></li><li>簽章認證我這個身份的人，實際上是說：「我同意這個 Primary Key pair 的所有人是 FatTuber」</li></ul></li></ul></li></ul><p>所以我們可以看到幾個特點</p><ul><li>每個人可以創造出不同的身份，各個身份擁有的網絡是獨立的</li><li>每個身份要不要跟你的社會關係做連結，由你決定。</li><li>簽章認證並不表示「這個人真的是那個身份」，充其量只能說「這群人同意他所宣稱的身份」<ul><li>譬如說我也可以宣稱我是 <code>Tony Stark&lt;tony@avenger.universe</code>，而且我身邊一堆人還真的簽章同意，但我很明顯不是</li><li>Gpg 運作的邏輯就像一般社會一樣，所以你要慎選你的朋友，也要仔細斟酌你朋友說的話</li></ul></li></ul><p>使用 Gpg 就像在真實社會裡面運作一樣，你要重視自己某個身份的 reputation，並且好好經營它，才能夠在這個分散式的架構裡面作到身份的認證。</p><h1 id="Gpg-裡面常見的名詞解釋"><a href="#Gpg-裡面常見的名詞解釋" class="headerlink" title="Gpg 裡面常見的名詞解釋"></a>Gpg 裡面常見的名詞解釋</h1><ul><li><p>Key pair</p><ul><li>public key 跟 private key 的組合</li></ul></li><li><p>Primary Key pair / Master Key pair</p><ul><li>一份人際網絡關係就由一份 Primary Key pair 來管理</li><li>大多數情況都只要一份 Primary Key pair 就好，你的個人聲望都會累積在此</li><li>Primary Key pair 的 private key 相當重要</li></ul></li><li><p>UID / User ID</p><ul><li>UTF-8 字串，由一個名字與 e-mail 組合而成，像是 <code>FooBar (Some comment) &lt;foobar@the.addr&gt;</code></li><li>在任何指令需要透過 UID 指定或是搜尋的時候，不用全部打完，通常用一部分也可以配對成功</li><li>每一組 Primary Key pair 底下可以有好幾個 UID<ul><li>你可能因為換工作而有不同的 mail address</li></ul></li></ul></li><li><p>Subkey pair</p><ul><li>因為 Primary key pair 很重要，需要好好藏起來。於是產生其他的 key pair 並且掛在 primary 底下，所以稱為 subkey pair</li><li>在一組 Primary key pair 之下，可以掛上許多不同的 subkey 去做各種簽章或加密的實際動作</li><li>Primary key pair 跟 subkey pair 的資訊安全強度相同 (如果產生的參數一樣)</li></ul></li><li><p>Key ID</p><ul><li>16 進位的字串，用來鑑別一個 Key</li><li>又稱 long key id</li><li>如果只抓最後一部分 16 個字元來看，這個字串就叫 <strong>fingerprint</strong></li><li>gpg 取最後 8 個字元來當 fingerprint，又稱 short key id</li></ul></li><li><p>KeyGrip</p><ul><li>用在 gpg 內部的東西，20 bytes 的 SHA1 字串</li><li>用處跟 fingerprint 有點像</li><li>與 protocol 獨立，是用 key 的公開資訊算出</li></ul></li><li><p>Signing, Certification, Authentication, Encryption</p><ul><li>Signing: 用 keypair 對某一份資料簽名，讓其他人能夠確認是否看到跟我一樣的資料</li><li>Certification: 對別人的一組 key 做 signing，就是 Certification / Certify<ul><li>只有 Primary private key 可以 certify 其他 key</li></ul></li><li>Authentication: 認證，就像常見的 ssh login</li><li>Encryption: 用 key 對資料作加密</li></ul></li></ul><h1 id="與查詢有關的指令"><a href="#與查詢有關的指令" class="headerlink" title="與查詢有關的指令"></a>與查詢有關的指令</h1><p>很多操作都需要用 id 去定位某個 key，所先介紹一下查詢的指令</p><ul><li>列出 Primary key pair 的 key id<ul><li><code>$ gpg -K</code></li><li>如果想看其他人的 pubkey，就用小寫 k <code>$ gpg -k</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gpg -K</span><br><span class="line">sec   ed25519 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">uid           [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid           [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">ssb   dsa2048 2022-05-12 [S]</span><br><span class="line">ssb   rsa2016 2022-05-12 [E] [expires: 2023-05-12]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面給的資訊少得可憐。既然我們經常要用到 subkey，那麼要用什麼指定 subkey？</p><ul><li>列出 subkey 的 fingerprint<ul><li><code>$ gpg -K --keyid-format long</code></li><li><code>$ gpg -K --with-subkey-fingerprint</code> 這個也行，列出比較長的 id</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyid-format long</span><br><span class="line">sec   ed25519/44269415E755ADA0 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">uid                 [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid                 [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056/2C4FAFA05BC34CC8 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">ssb   dsa2048/96679AF60453EA0B 2022-05-12 [S]</span><br><span class="line">ssb   rsa2016/8AD8E8D104841669 2022-05-12 [E] [expires: 2023-05-12]</span><br></pre></td></tr></table></figure><p>上面的範例，2022/05/12 就會過期的 RSA key 的 fingerprint 就是 <code>2C4FAFA05BC34CC8</code>，後面會經常用到 subkey fingerprint</p><ul><li>列出 keygrip<ul><li><code>$ gpg -K  --with-keygrip</code></li><li>應該是 Gpg 2.1 之後，private key 就會存在 <code>private-keys-v1.d/[KeyGrip].key</code>，所以要看 keygrip 才知道是對應那一把 private key</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --homedir=. -K  --with-keygrip</span><br><span class="line">/home/walkingice/temp/gpg/pubring.kbx</span><br><span class="line">-------------------------------------</span><br><span class="line">sec   ed25519 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">      Keygrip = 9636425F6158C1C242C52C79AFF07DB2A76637C8</span><br><span class="line">uid           [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid           [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">      Keygrip = 80ACB61CD079B38A4FBE6B9511BAD1FF90CD1D10</span><br><span class="line">ssb   dsa2048 2022-05-12 [S]</span><br><span class="line">      Keygrip = 0E3D334598E9A2A46450F52035A30348D85776A1</span><br><span class="line">ssb   rsa2016 2022-05-12 [E] [expires: 2023-05-12]</span><br><span class="line">      Keygrip = E7B8746A7A51D69486938458A9B3C68E105791C3</span><br></pre></td></tr></table></figure><h1 id="管理-Primary-key-與-Subkey"><a href="#管理-Primary-key-與-Subkey" class="headerlink" title="管理 Primary key 與 Subkey"></a>管理 Primary key 與 Subkey</h1><p>網路上其他地方已經很多教學了，我這邊只大概列出常用到的指令當作備忘</p><ul><li><p>新增 primary key pair</p><ul><li><code>$ gpg --gen-key</code></li><li><code>$ gpg --expert --full-gen-key</code> 用更專家的模式來產生 key</li></ul></li><li><p>刪除 primary key pair</p><ul><li><code>$ gpg --delete-secret-keys [UID]</code> 先刪除 private key</li><li><code>$ gpg --delete-keys [UID]</code> 接著刪除 public key</li></ul></li><li><p>編輯 subkey</p><ul><li>subkey 是掛在 primary key 底下，所以操作都是從「編輯 primary key」出發</li><li><code>$ gpg --edit-key [UID]</code> - 編輯這個 UID 所關聯的 primary key<ul><li><code>gpg --expert --edit-key [UID]</code> - 用專家模式可以有更多操作選項</li></ul></li><li>新增<ul><li><code>gpg&gt; addkey</code></li></ul></li><li>刪除<ul><li><code>gpg&gt; key [SUBKEY fingerprint]</code> - 特別指定要對這個 subkey 操作</li><li><code>gpg&gt; delkey</code></li></ul></li><li>撤銷/Revoke key<ul><li><code>gpg&gt; key [SUBKEY fingerprint]</code> - 特別指定要對這個 subkey 操作</li><li><code>gpg&gt; revkey</code> - revoke 之後記得要重新 export public key 告知其他人</li></ul></li></ul></li><li><p>匯出並刪除 primary private key</p><ul><li>匯出 primary private key 到檔案 <code>primary_private_key.gog</code> 並且拿到別的地方好好保存</li><li><code>$ gpg -o primary_private_key.gpg --armor --export-secret-keys [KEY_ID]</code></li><li>備份完備，接著在 gpg 管轄範圍內刪除 primary private key</li><li><code>$ rm private-keys-v1.d/[Primary KeyGrip]</code> - v2.1 之後直接砍掉檔案就行了</li><li>確認一下，打 <code>$ gpg -K</code> 會看到 private key 前面的 <code>sec</code> 變成 <code>sec#</code></li></ul></li><li><p>匯出 subkey private key</p><ul><li>如果你想要備份 subkey 的 private key，匯出的方式會有點不同</li><li><code>$ gpg -o sub_prikeys.gpg --armor --export-secret-subkey [KEY_ID]</code> - 匯出所有的 subkey private keys</li><li><code>$ gpg -o sub_prikeys.gpg --armor --export-secret-subkey [SUBKEY_FINGERPRINT]!</code> - 只匯出某一把 subkey private key，注意那個驚嘆號</li></ul></li><li><p>匯入 primary private key</p><ul><li>需要把 primary private key 找回來的時候，把之前匯出的檔案重新匯入即可</li><li><code>$ gpg --import primary_private_key.gpg</code></li></ul></li></ul><p>為什麼要麻煩地把 primary private key 藏起來？</p><p>這把 key 可能擁有你經年累月所累積的聲望，用這把 key 簽署過幾百人，也可能跟幾百人都交換過。如果哪天要出差去高風險的地方，電腦可能會遭竊或是被破壞，我們不會希望這把私鑰就這樣毀於一旦。利用 subkey 的機制，可以把 primary key 在大多數情況都藏起來，主要使用 subkey 來加密或是簽名。即使 subkey 遺失或是被竊盜，還能夠請出最權威的 primary 來宣稱某把 subkey 已經失效</p><p><a href="https://wiki.debian.org/Subkeys">Debian 這篇 Subkeys</a> 解釋了原因，並且列出哪些情況才會需要用到 primary private key</p><ul><li>你要簽署認同別人的 key，或是要撤銷手上的某個 key<ul><li>when you sign someone else’s key or revoke an existing signature,</li><li>when you revoke or generate a revocation certificate for the complete key</li></ul></li><li>你要編輯 UID<ul><li>when you add a new UID or mark an existing UID as primary,</li><li>when you change the preferences (e.g., with setpref) on a UID,</li></ul></li><li>你需要編輯 subkey<ul><li>when you create a new subkey,</li><li>when you revoke an existing UID or subkey,</li><li>when you change the expiration date on your primary key or any of its subkey, or</li></ul></li></ul><p>所以建構 key 的流程會有這種方式</p><ol><li>產生一組 primary key pair<ul><li>因為不會直接拿它做檔案加密所以不用擔心效率，選定最難的加密演算法，長度用到最大</li></ul></li><li>產生幾組專門拿來加密或是簽名的 subkey</li><li>匯出 primary private key 將其好好保存</li><li>刪掉 gpg 裡面的 primary private key</li><li>使用 subkey 做常見的工作</li><li>需要用到 primary private key 的時候，才暫時將其匯入，用完再刪掉</li></ol><h1 id="跟別人交換-key"><a href="#跟別人交換-key" class="headerlink" title="跟別人交換 key"></a>跟別人交換 key</h1><p>用 gpg 終究不會是自己一個人玩，總是要跟別人交流。所以雙方會交換 pubkey 放到自己的 gpg database 裡面</p><ul><li><p>匯出自己的 pubkey</p><ul><li><code>$ gpg --output my-pubkey.gpg --export [UID]</code> - 匯出所有的 pubkeys</li><li><code>$ --output my-single-pubkey.gpg --export [SUBKEY_FINGERPRINT]!</code> - 只匯出某個 subkey 的 pubkey</li></ul></li><li><p>匯入別人的 pubkey</p><ul><li><code>$ gpg --import friend_pubkey.gpg</code></li></ul></li></ul><p>單單把別人的 pubkey 放進自己的 database 還不夠，還需要用我們自己的人格去保證這把 pubkey 是不是真的由某個認識的人發出</p><ul><li>確認匯入的 pubkey<ul><li><code>$ gpg -k</code> 確認一下「朋友」的 pubkey 已經放進去，假設「朋友」的名字是 <code>the_friend</code></li><li><code>$ gpg --edit-key the_friend</code> - 開始編輯「朋友」的 key</li><li><code>gpg&gt; fpr</code> - 確認一下「朋友」的 fingerprint 對不對</li><li><code>gpg&gt; uid friend_the_one</code> - 「朋友」有很多 UID，我想針對 <code>friend_the_one</code> 這個 UID 做簽名</li><li><code>gpg&gt; sign</code> - 進行簽名認證，或是用 <code>lsign</code> 只在 local 端簽名。確認這份 pubkey 就是由「朋友」所擁有</li><li><code>gpg&gt; save</code></li></ul></li></ul><p>如果你需要親自跟每個 gpg user 見面，確認對方的身份之後才簽名認證，長久下來效率低落。可以利用透過其他人認證過的結果來簡化流程。譬如說有個叫 Kenji 的人做事總是不仔細，所以他認證過的人我都不願意相信。但是我完全無條件相信「朋友」所認證的任何人，所以我可以針對 Kenji 跟「朋友」設定不同的 trust 程度</p><ul><li>修改 trust<ul><li><code>$ gpg --edit-key the_friend</code></li><li><code>gpg&gt; trust</code></li><li><code>gpg&gt; save</code></li></ul></li></ul><p>但是時間久了，要怎麼知道我們所設定的 trust 程度呢？edit key 的時候就能看見</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub  rsa3072/58C7791869454109</span><br><span class="line">     created: 2022-05-12  expires: 2024-05-11  usage: SC</span><br><span class="line">     trust: ultimate      validity: ultimate</span><br></pre></td></tr></table></figure><p>上方的例子，trsut 的程度就是 <code>ultimate</code>，「朋友」的話就是對的！👆</p><p>交換 public key 如果全部都要用 e-mail 之類的方法傳遞，那就太累人了。通常就會找一個 keyserver，大家把 public key 傳上去，或從那邊抓下某個人的 public key，確認無誤之後再 sign。又或著，你對自己的 key 做出什麼變更，也可以傳上 server。別人就能從這個 server 抓下你的更新</p><ul><li>送出 public key 到 server<ul><li><code>$ gpg --send-keys [KEY_ID]</code> - 送出這一組的 public key<ul><li>但有時候會遇到 <code>gpg: keyserver send failed: Server indicated a failure</code> ，那可能就是你指定的 keyserver 掛了。</li><li>ubuntu 的 key server 好像也滿常用到</li><li><code>$ gpg --keyserver keyserver.ubuntu.com --send-keys [KEY_ID]</code> - 送出這一組的 public key 到 ubuntu key server</li><li>如果你想以後都用 ubuntu 的 key server，可以在 <code>~/.gnupg/gpg.conf</code> 裡面加上 <code>keyserver hkp://keyserver.ubuntu.com</code></li></ul></li></ul></li><li>從 server 下載 public key<ul><li><code>$ gpg --recv-keys [KEY_ID]</code></li></ul></li></ul><h1 id="加密、解密與簽名"><a href="#加密、解密與簽名" class="headerlink" title="加密、解密與簽名"></a>加密、解密與簽名</h1><p>前面千辛萬苦終於把 keys 都搞定了，現在開始真正使用 gpg 來做正事</p><ul><li><p>針對某個文字檔案做簽名</p><ul><li>產生一個新的可讀文字檔案，把原檔的東西放進去，同時也把簽章的資訊放進去</li><li><code>$ gpg --clear-sign [Filename]</code> - 不影響原檔案，額外產生 <code>[Filename].asc</code></li><li><code>$ gpg -u [SUBKEY_FINGERPRINT]! --clear-sign [Filename]</code> - 如果有多個 subkey，使用驚嘆號指定某個 subkey 來 sign，<ul><li>也可以在 <code>gpg.conf</code> 裡面寫上 <code>default-key [SUBKEY_FINGERPRINT]!</code> 當作預設使用的 subkey</li></ul></li><li>驗證簽名<ul><li><code>$ gpg --verify [Filename].asc</code></li></ul></li></ul></li><li><p>僅僅只產生一個額外的簽章資訊</p><ul><li>對方收到檔案之後，再根據這個簽章的資訊驗證檔案是不是真的來自你</li><li><code>$ gpg --sign --detach-sign [Filename]</code>   產生 <code>[Filename].sig</code>，把簽名跟檔案本體分開來</li><li>驗證簽名<ul><li><code>$ gpg --verify [Filename].sig [Filename]</code></li></ul></li></ul></li><li><p>對稱式加解密</p><ul><li>就是一般常見的用密碼加密，其實要用這招的話，也不需要搞一堆 key 了</li><li><code>$ gpg -c [Filename]</code></li><li>或是 <code>$ gpg --symmetric [Filename]</code></li><li>會產生 <code>[Filename].gpg</code></li></ul></li><li><p>用對方的 public key 加密</p><ul><li><code>$ gpg --encrypt -r [UID] [Filename]</code> - 指定 recipient 為 UID，會產生加密檔案 <code>[Filename].gpg</code></li><li>如果對方有很多把 subkey，想要用其中一把 subkey 加密</li><li><code>$ gpg --encrypt -r [Recipient&#39;s Public Subkey Fingerprint]! [Filename]</code> - 注意 subkey 後面有個驚嘆號，驚嘆號就是用來指定 fingerprint</li></ul></li><li><p>用自己的 private key 加密，讓對方可以用我的 public key 解密</p><ul><li>其實，這就是對這個檔案做簽章，並且不要把簽章的資訊額外放到別的檔案</li><li><code>$ gpg --sign [Filename]</code></li></ul></li><li><p>如果手上有對方的 pubkey，不想要把對方的 pubkey 加到 database 裡面，也能用 pubkey 檔案來加密</p><ul><li><code>gpg --encrypt -f [Recipient PubKey Filename] [Filename]</code><ul><li>如果這個檔案包了好幾個 pubkey，那麼 gpg 應該會用最新的那個</li><li>所以對方最好是只給一個 pubkey</li></ul></li></ul></li></ul><h1 id="檔案管理與備份"><a href="#檔案管理與備份" class="headerlink" title="檔案管理與備份"></a>檔案管理與備份</h1><p>除了使用 gpg，妥善地管理檔案以及備份也很重要。不過我個人比較懶惰，通常是直接備份整個工作目錄，比較挑惕的人可以稍微理解一下目錄底下哪些檔案是做什麼的</p><p>gpg 的預設工作目錄是 <code>~/.gnupg</code>，也能由 <code>--homedir</code> 或是環境變數 <code>GNUPGHOME</code> 來指定其他地方為工作目錄。我在讀文件的時候，就是用 <code>--homedir</code> 來練習。不過要注意，gpg 會跑起一個 daemon <code>gpg-agent</code>，它會暫存一些資訊，譬如說輸入的 passphrase，有時候需要砍掉這個 daemon 清光 cache。</p><p>在 2.1 之後就不用 <code>secring.gpg</code> 這個檔案了。分開維護 public keyring 跟 private keyring 常常會引起問題，所以在 gpg 2.1 之後，全部把工作都交給了 gpg-agent (真正的 encryption engine)來做</p><ul><li><code>pubring.kbx</code><ul><li><strong>需要備份</strong></li><li>public key box</li><li>v2.1 之後新增的 <a href="https://www.gnupg.org/faq/whats-new-in-2.1.html#nosecring">https://www.gnupg.org/faq/whats-new-in-2.1.html#nosecring</a></li><li>給 <code>gpgsm</code> 共享使用。(<code>man gpgsm</code>)，所以這個檔案可能在早就被產生了</li></ul></li><li><code>openpgp-revocs.d</code><ul><li><strong>需要備份</strong></li><li>裡面的東西可以用來 revoke 正在使用的 key，所以最好分開存放，或是印出來收藏</li></ul></li><li><code>private-keys-v1.d</code><ul><li><strong>需要備份</strong></li><li><code>gpg-agent</code> 會把 private key 存在這裡面</li></ul></li><li><code>trustdb.gpg</code><ul><li>不需要備份</li><li>trust database</li><li>真的要備份，會用 <code>--export-ownertrust</code> 匯出檔案</li></ul></li></ul><h1 id="後話閒談"><a href="#後話閒談" class="headerlink" title="後話閒談"></a>後話閒談</h1><p>前一陣子在想，數位資產的所有權(暫且先不管「所有權」的嚴格定義)認證目前都是綁定在網站的帳號之上，可是我們註冊帳號的時候往往要提供一個 e-mail，這年頭許多人(包括我)都是直接用 gmail。如果我的 gmail 帳號因為任何原因而被停權，也代表我有風險失去在某個網站上面的數位資產。如果我想要自己架 mail server 給自己發 e-mail 帳號，實際上我的 domain name 也是被某個網路巨頭所掌控。如果想要證明登入的人真的是「我」，似乎都要被某個網路巨頭箝制？</p><p>「如何在網路上證明自己的身份，而不倚靠大公司的服務？這不就是 GnuPG？！」是啊，這個問題早就有個解法了。</p><p>最近幾年大家對「網路巨頭」很不信任，不過我身為這個行業裡面的一員，雖然有點提防但也沒有到很緊繃的程度，對於民主國家裡面比較有聲譽的大公司，其實我還是有一定程度的信任，也因此我對「完全去中心化」這種目標並不是很有興趣。</p><p>即便如此，我還是強烈同意並主張，<strong>人們應該要有個可以驗證自己的方法，不受大公司的限制</strong></p><p>用 gpg 的例子來說，就是我可以用 gpg subkey 來註冊帳號，而非使用 e-mail。註冊帳號只是例子，其實泛指的是任何需要 authenticate 的事情。這只是個理想，而現實的其中一個關卡就是，gpg 真的很難用。</p><p>Gpg 指令難用之一在於，它會故作聰明地幫你找一堆 fallback，經常你搞錯 keyid 或是 fingerprint，忘記加上驚嘆號都會動，或著在 conf 裡面設定錯誤的 default-key，這些弄錯都還是會動，但是結果跟你預期的不大一樣。從大學就喜歡用 Linux command line 的我，依然覺得 gpg 的指令很反人類。它的功能很完整，熟悉的人可以很好地使用它。但是在那之前，gpg 混亂的文件說明與複雜的指令，沒有強大耐心的人應該都沒動力弄懂 gpg，多半就只有拿來 gen key 而已。</p><h1 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h1><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc4880">RFC4880: OpenPgp Message Format</a></li><li><a href="https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/">Anatomy of a GPG Key</a></li><li><a href="http://jedi.org/blog/archives/gpg_party_zh_tw.html">中文：GnuPG Keysigning Party HOWTO</a></li><li><a href="https://zhuanlan.zhihu.com/p/481900853">知乎：使用 GPG Key 来构建签名、加密及认证体系</a></li><li><a href="https://zhuanlan.zhihu.com/p/24103240">知乎：关于GnuPG的subkey（子密钥）的使用</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;GnuPG 應該是絕大多數 Linux user 或是開發者都用過的工具。說起來真不好意思，十多年前剛開始工作的時候就用過它，懵懵懂懂查了幾個常見指令就擺著不放。現在終於振作起來，稍微多花點時間，重新認識這個工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="linux" scheme="https://jchu.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Social Network 是否可能有另外一種樣貌？</title>
    <link href="https://jchu.cc/2022/04/29-social-network.html"/>
    <id>https://jchu.cc/2022/04/29-social-network.html</id>
    <published>2022-04-28T16:38:09.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>隨手在 FB 寫了些對於最近鄉民從 Twitter 逃難到 Mastodon 的感想，竟然意外有不少朋友回應</p><p>雖然我一開始的本意，只是想要重述我在私下講過好多次的想法，想要提醒那些沒那麼熟悉科技工具的朋友，他們應該找個地方把他們的論述好好保存下來。結果卻演變成我對 Social Network 的看法，仔細再想一下，我也可以趁機好好整理一下我自己的想法，於是就打算來「認真寫一篇」</p><span id="more"></span><p>最近，超級有錢而且相當唱秋的 Elon Musk 似乎開著玩笑說要買下 Twitter，然後還真的出了 400 多億美金去買。這件事情有人喜歡，有人不喜歡，引發一波 Twitter 逃難潮，有些人最近開始使用 Mastodon</p><p>類似的逃難潮已經發生過好多次。前一陣子普羅大眾對「演算法」三個字很熟悉的時候，不少人決定「不要被 Facebook 的演算法操縱」，於是開了新的帳號。過了不久，這些帳號也都很少啟動。畢竟大多數人不是靠營銷維生，對於演算法的改變其實不敏感，也習慣。更重要的是，在那裡有更多的朋友，Social Network 就是要滿足社交嘛。</p><p>Social Network 就是這樣有力，毫無疑問。</p><p>從 Twitter 到 Mastodon 的搬家潮？除非 Twitter 真的做了什麼核心的改變，讓使用者覺得很難用，否則出走的人終究會回去習慣的地方。回去沒什麼不對，畢竟 Elon Musk 也還沒幹什麼事啊，搞不好他真的把 Twitter 弄得很有趣，活得很好。</p><p>新的 Social Network 平台崛起，舊的沒落，這已經發生過很多次。所以 FB / IG / Twitter 甚或是 Mastodon，我都覺得沒有太大的差別。Social Network 對於公共討論的影響，乃至於影響到整個政治與社會，幾年來已經有相當多的探討與觀點。</p><h1 id="Social-Network-對網路環境的影響"><a href="#Social-Network-對網路環境的影響" class="headerlink" title="Social Network 對網路環境的影響"></a>Social Network 對網路環境的影響</h1><p>社群平台的轉移風潮，理所當然地影響社會上的資訊傳遞方法。除了之外，還有一個我很在意的影響，這個影響是資訊界的人，尤其是 Web 1.0 或是部落格時代就開始參與網路的老骨頭都相當清楚的一件事：網路上累積的知識內容增長幅度不如預期</p><p>或著說，過去十多年來，各行各業的愈來愈多精英參與了網路，但是在網路上能搜尋到的優質文章並沒有蓬勃地增加。</p><p>又或著說，精英在 Social Network 把自己的知識轉化成群眾的短期支持，然後，僅止與此。這些原本被樂意分享的知識，並沒有累積到網路上，這是我覺得可惜的地方。</p><p>舉個例子來說，各個 Social Network 裡面有大大小小的社團，幾乎你有興趣的主體都找得到社團。但是，如果你拿相近的關鍵字在各個搜尋引擎來尋找，最終找到的結果不外乎是 Wiki、Blog、論壇(Reddit, BBS, Stackoverflow…)、新聞網站以及內容農場。極少的情況，你會看到來自 Social Network 的公開文章。</p><p>許多產出內容的人，他們樂意被看見嗎？我想是的。他們希望自己的文字能被更多人看見嗎？我想也是如此。但結果就是，你總是很難看見來自 Social Network 的搜尋結果。從技術的角度來看，我們可以挑惕搜尋引擎做得不夠好，老實說沒有實作過我也不敢講死責任全在 Social Network 不夠公開。我只能從結果來看，內容發布在 Social Network 裡面，多半就是紅個幾天接著消失在網路中。</p><p>當然，我這麼市儈的人，頭一個就是想到(廣義上)錢的問題，後面再談。</p><p>沒有辦法在網路累積知識，我將其視為「現象」而非「問題」，因為我也不確定累積愈來愈多免費的知識是不是好事(笑)，當然我個人是希望知識可以免費取得。這個現象的形成，是因為 Social Network 取代了 Blog。不幸的是，在我看來，這個取代又是必然發生的。</p><h1 id="前-Web-2-0-時代"><a href="#前-Web-2-0-時代" class="headerlink" title="前 Web 2.0 時代"></a>前 Web 2.0 時代</h1><p>稍微回顧網路的歷史。Web 1.0 那個時代，要產出內容你就要學會「架站」，還要學會寫烘培雞 (Home Page)。我還記得高中的電腦課，老師教我們用記事本寫簡單的 HTML，那個年代的 Web 真是簡單到不行。架站就沒那麼容易了，如果不找免費空間，就要有人提供「工作站」。那時候玩 MUD，有正在念大學的朋友說：「我幫你開個工作站的帳號」就覺得對方實在帥到不行。對國高中生而言「工作站」實在是一個高上大帥到爆炸的名詞 - 雖然我只會連上去開 tintin。(所以我大一裝完 Linux 第一次開機，看到一堆 Check OK 的文字時，真的感動到快流淚了，原來我也可以有帥到翻過來的機會)</p><p>後來進到 Web 2.0 的時代，也就是使用者產出內容的時代。從此開始，你不需要學會架站或 HTML，你就可以有個自己的天地來寫東西。對台灣人而言，大致上可以對比成無名小站當紅的時代</p><p>像我這種渾身汗臭味的大叔，會覺得那個時代真是美好啊。(打嗝) (大叔臭味更濃了)</p><p>每個人都有自己的「家」，不喜歡無名小站的，也可以開 Blogspot，或是像我們這種資工系的人就是要架個隨時會被打爆的機器證明自己的尊絕不凡。總之，每個人都有自己的空間，每個人都把自己的照片往那裡堆，每個人都把自己的心情往那裡寫。預設就是給所有人看，展現自己的風格 - 當然也有隱私的空間，但預設都是開放的。</p><p>不管是心儀的隔壁班對象，或是討厭的他校情敵，總之關鍵字丟對了，很多資訊都找得到。嗯，現在我這個年紀回想起來，這還真是恐怖啊 XD</p><p>每個人都預設別人會來看，而且是把自己家的所有東西認真看一遍。於是不少人都會認真經營自己的部落格，連帶地就會開始競爭產出的內容。</p><p>在那個時期，每個人在網路上的「家」都像是一個孤島，彼此之間透過 RSS 或是瀏覽器的 Bookmark 連結起來。雖然搬家很痛，會流失不少讀者，但是「搬家」是可能的。文章與照片是可以帶走的資產，許多程式可以讓 Blogger 轉換平台而不會損失太多文章。過往辛苦耕耘的東西都還在，讀者終究會回來。</p><p>直到 Social Network 的興起</p><h1 id="Social-Network-必然取代-Blog"><a href="#Social-Network-必然取代-Blog" class="headerlink" title="Social Network 必然取代 Blog"></a>Social Network 必然取代 Blog</h1><p>記得 Social Network 剛興起的時候，比較多人用的詞是 <strong>Micro Blog</strong> (微部落格)。當時我心想，原本部落格可以寫很長的文章，現在被限制到幾百字，這不是一種退化嗎？當時我不明白的是 1) 很多人本來就沒啥興趣看長文 (譬如本篇) 2) 重點是 social，不是 blog</p><p>Blog 剛開始流行的時候，大家都嘛隨便寫。蹺課被點名而超不爽可以寫一大篇，晚餐麻辣鍋很好吃但是拉肚子很痛苦，兩句話也能寫一篇。許多人寫 blog 只是想要在網路上社交，這個需求既然能被 social network 滿足，何必再寫 Blog？</p><p>Blog 時代也嘗試過加入社交的元素。譬如說文章留言，可以讓(孤島)島主跟路人互動的機會，或是 Pingback 機制，把不同網站的文章連結起來，又或是 Planet 把幾個 Blog 合併在一起變得更熱鬧，部落格會顯示每日參觀人數滿足人們被看見的渴望。但這些都不及 Social Network 來得直接，都不比 Social Network 刺激</p><p>在 Social Network 時代，大家都是真切地待在同一個島上。人們不再是島主，而是島民，產出都是最終貢獻給島，讓那個平台成為更豐饒的島。付出代價換回的是更直接刺激的即時回應：有多少人點了讚，有多少人轉貼</p><p>原本我就認為，所謂「值得紀錄的好文」不過是滿足社交需求這個主目的的副產品，既然 Social Network 可以滿足多數人的需求，那麼部落格的式微便是必然。</p><p>於是多數人從 Blog 轉換 Social Network 後，原本以產出文字維生的人，自然也是轉戰 Social Network。於是寫 Blog 的人，就只剩下不太需要靠文字維生，卻又刻意希望留下長久足跡的人。也因此，寫 Blog 更像是一個神聖而必須專注的工作，既然牢騷可以在 Social Network 獲得滿足，那麼 Blog 必須展現專業。</p><p>理論上來說，人多了就會產出優質的內容，實際上也是這樣，雖然 Twitter 或 FB 充滿各種牢騷或是讓人搖頭的意見，但是還是有很多精英分享真知灼見。但是在商業的考量下，Social Network 上面註定不會留下太多東西。對，還是因為錢的關係</p><h1 id="Social-Network-比較好賺錢"><a href="#Social-Network-比較好賺錢" class="headerlink" title="Social Network 比較好賺錢"></a>Social Network 比較好賺錢</h1><p>同樣都是靠廣告營利，Blog 的平台對於讀者的掌控力弱，對於內容產出者的控制力道也弱(寫手不爽就搬家了)。但是 Social Network 上面，賽制跟場地都是自己的，當然比 Blog 還要好賣廣告。更何況大多數的商品都有時效性，賣一段時間就可以了，快速迭代的 Social Network 比走長尾的 Blog 還要有用。</p><p>我已經是鼻子聞不到花香，只聞得到銅臭味的中年爸爸了，我非常清楚也認同錢的重要。</p><p>要開公司，當然要想辦法把所有的客人都鎖在自己家平台呀。</p><p>如果我當老闆，大家討論新產品的時候，有人跟我說他想做一個可以讓使用者輕易搬家的程式，我應該也會踹他兩腳再把他扔出窗外。大家想的是怎樣讓更多使用者黏在自家平台上，怎麼會有人降低搬家的門檻呢？</p><p>有人批評現在的 Social Network 大公司都在貪用網路的自由基石獲利而吝於分享。情感上我同意這種看法，但邏輯上我又覺得這難以避免。講難聽一點，我現在工作的項目，也是在利用公開的 HTTP 協定，傳送大多對人類智慧沒有幫助的資訊。既得利益者的我，領薪水的時候也是跪下來笑嘻嘻流口水捧著鈔票。</p><p>公司需要獲利，既然築起城牆可以讓公司更安全的獲利，那麼大家都築牆就太自然了。</p><p>也許適當地公開一些內容，可以為公司帶來更長遠的利益。但是這種不易證明獲利的功能，在優先權上很難贏過其他顯著有優勢的項目。要是有個工程師跟我說，他覺得整體網路的健康性比能賺錢影片廣告還要重要，希望平台的內容都很容易給網路爬蟲索引，我也會踹他兩腳：「你去幫我看看剛剛我丟下去的人死透了嗎？」然後也把他丟下去</p><p>好啦，以上是說笑。我心底是希望網路更健康，但是在公司要推動項目不能靠理想。靠理想的公司也不太容易活下來就是了。</p><h1 id="Blog-還有辦法存活嗎？"><a href="#Blog-還有辦法存活嗎？" class="headerlink" title="Blog 還有辦法存活嗎？"></a>Blog 還有辦法存活嗎？</h1><p>我覺得很難。</p><p>在台灣比較知名還存活的部落格平台，應該是 Pixnet 吧。打開 Pixnet 就看到廣告數量堪比祖國滿溢的愛，不由得覺得辛酸。Blogspot 雖然有個富爸爸，但是幾年下來沒什麼改變，多半也是靠爸才沒餓死。Wordpress 看起來活得不錯，但我的理解它不是靠 Blog 服務維生，而是提供許多小廠商架站的平台。(歡迎指正)</p><p>總之 Blog 的平台賺的錢少，但是養平台要錢，是筆難作的生意。</p><p>我的 Blog 目前是寄生在 Github page 上面，用 hexo 生出靜態網頁。哪天 Github page 收掉，我還能自己架個 web server 所以沒差。但是相對的寫文章的成本就很高，有時候我自己都覺得寫 Blog 好累，一年寫個幾篇就不錯了，正如我開頭所說，需要打起精神才能「認真寫一篇」，累啊</p><p>相較之下在 twitter / FB 發牢騷的字數多出百倍。如果寫 blog 變成一種需要刻意為之的選項，那麼它自然難以持續</p><h1 id="我總是期待-Social-Network-能夠留下些什麼"><a href="#我總是期待-Social-Network-能夠留下些什麼" class="headerlink" title="我總是期待 Social Network 能夠留下些什麼"></a>我總是期待 Social Network 能夠留下些什麼</h1><p>前面講了一大堆，是想闡述在我的理解之中，演變成今天這樣是很自然的。我擔心 Social Network 對民主的傷害，但我坦然接受 Social Network 取代 Blog 的事情。而且在我的感受裡，不管是 FB / Twitter / Tiktok / Mastodon 都沒什麼太大的差別，它們對網路環境的影響最終都會差不多，至少在我說的「累積」這一塊是相同的。</p><p>我只是有時候在想，有沒有哪個平台，會在陰錯陽差之下設計出更容易累積文章的功能？</p><p>寫 Blog 只是一種形式，我所在乎的是，那些在 Social Network 上面的優秀文章，能夠以更長久更公開的形式被保留下來。以 Facebook 為例，雖然說文章設定成公開地球，理論上就要能被 Google 搜尋到。但實際上就是鮮少搜尋得到。</p><p>譬如說聖騎士大仁哥，帳號掛著藍勾勾，發的文章都是開地球，他的公衛專業發出的文章值得一看，但你在 FB 以外的地方就是搜尋不到。這可能是 Google 不夠力，也可能是 FB 給搜尋引擎穿小鞋，總之就是看不到。</p><p>這件事情又回到目前 Social Network 的主流設計：你心裡明白你的產出最終不是放進你的收藏櫃，而是放上別人 timeline 架上的競爭品</p><p>這其中有個很微妙的落差。首先我們可以假設，累積的文章這麼少，是因為很多人寫文章本來就想過那麼遠，當下寫了大家看完就算了。但是如果針對那些想要被傳播的長文，一篇一篇問，希望不希望這篇文章能夠被更多人看見，被保存的更久？我想多數的回答是：「沒什麼不好」。</p><p>Social Network 不加分辨地，預設地把這些長文跟一般的社交文章用同樣的方式處理，以至於這些文章就隨著時間消失。</p><p>從技術的角度來看，解法倒也沒有太難。給這些擁有藍勾勾的人，一個類似 Blog 網站的個人頁面，姑且叫它展示櫃好了。一定長度的文章，在發布前就跳個選項問：「是否要放進展示櫃？」，然後同步複製過去就可以了。只要這些展示櫃同樣有 RSS 也能被爬蟲看到，那麼好文就容易被留下來。</p><p>這是我希望的，Social Network 能有的另外一個樣貌，跟現在差不多，只是有點不一樣。</p><p>只是，我想不到這對檯面上的 Social Network 大公司有什麼好處，這件事情沒發生，我也不怎麼意外。也許某些平台有類似的功能可以做到類似的事情，但我想這不會是 Social Network 公司覺得有價值的事情，自然也不會是被推崇的方向，UX 的設計更不會讓這件事情那麼容易作到。換句話說就是，做得到但是不會讓人想去做，因為沒必要</p><p>有另外一個取巧的作法，就是自己寫程式，把別人的文章轉貼出來到第三方的網站，做個自己的「公開收藏櫃」。技術上當然是可以，但是一來有授權的問題，二來 hosting 要錢，如果只能自己玩玩，那麼對於「累積好文」這個目標就沒什麼幫助。更重要的是，我覺得這種作法不健康，轉貼文章會稀釋原作者的帳號的價值，要看原作者的好文，還是要回到他的家/官方頁面去看，才能夠鼓勵原作者持續創作。</p><p>說到底，還是要靠 Social Network 平台自己去推動才有可能改變，但我自己是完全看不出來有什麼動力可以讓任一平台做這種事情。所以我自己是悲觀地認為，這是一個死局</p><p>以上，就是中年大叔的超長牢騷。黃金週結束前我大概都沒力氣寫其他東西了 (捅自己一刀)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;隨手在 FB 寫了些對於最近鄉民從 Twitter 逃難到 Mastodon 的感想，竟然意外有不少朋友回應&lt;/p&gt;
&lt;p&gt;雖然我一開始的本意，只是想要重述我在私下講過好多次的想法，想要提醒那些沒那麼熟悉科技工具的朋友，他們應該找個地方把他們的論述好好保存下來。結果卻演變成我對 Social Network 的看法，仔細再想一下，我也可以趁機好好整理一下我自己的想法，於是就打算來「認真寫一篇」&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
  </entry>
  
  <entry>
    <title>在本機上存取 Android 的 sqlite 檔案</title>
    <link href="https://jchu.cc/2022/04/17-sqlite.html"/>
    <id>https://jchu.cc/2022/04/17-sqlite.html</id>
    <published>2022-04-17T13:14:04.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>之前紀錄過一篇怎麼在 Android Studio 裡面用 SQLScout 的 Plugin 存取 sqlite database</p><p>其實用指令把 sqlite db 抓到本機端測試也一樣</p><span id="more"></span><p>先確保你安裝的是 debuggable app，假設 package 是 <code>foo.bar</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ run-as foo.bar</span><br><span class="line">$ <span class="built_in">cd</span> /data/data/foo.bar/database</span><br></pre></td></tr></table></figure><p>找 <code>db</code> 結尾的檔案就是 sqlte 的資料庫檔案了。如果你的資料庫名稱是 <code>my-db</code>，多半檔名就是 <code>MyDb.db</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp MyDb.db /sdcard</span><br></pre></td></tr></table></figure><p>接下來用 adb pull 就能抓下來了。知道路徑的話，可以用一行指令做完</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb exec-out run-as foo.bar cat /data/data/foo.bar/databases/MyDb.db &gt; backup.db</span><br></pre></td></tr></table></figure><p>以後用 sqlte3 的指令操作這個檔案就可以測試了，習慣指令操作的人，會覺得比起用 plugin 更有彈性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前紀錄過一篇怎麼在 Android Studio 裡面用 SQLScout 的 Plugin 存取 sqlite database&lt;/p&gt;
&lt;p&gt;其實用指令把 sqlite db 抓到本機端測試也一樣&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>kotlinx-coroutines-test migrate to 1.6 紀錄</title>
    <link href="https://jchu.cc/2022/03/30-coroutine-migration.html"/>
    <id>https://jchu.cc/2022/03/30-coroutine-migration.html</id>
    <published>2022-03-30T13:07:18.000Z</published>
    <updated>2022-04-01T16:46:25.178Z</updated>
    
    <content type="html"><![CDATA[<p>之前因為工作的需要，把 kotlin 從 <code>1.5.2</code> 升級到 <code>1.6.0</code>，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。</p><span id="more"></span><p>kotlin 升級到 1.6.0 的時候，有把許多元件標為 <code>Deprecated</code>。這在一般的小專案裡面不是什麼大問題，但我的公司有很多部門都會把程式送到同一個 repository 裡面，當然許多人都有寫 unit test 的習慣，而且我們也有打開 <strong>-Werror(Warning as Error)</strong> 的選項。於是必須在一個 PR 裡面，升級 coroutine 版本的同時，就把上百個 unit test 類別裡面的過時寫法一口氣更新。</p><p>這種改測試的任務，配分到各個跨國團隊底下，很容易大家就因為各自的時程壓力而搞到永遠作不完。跟同事討論之後，決定我跳下去動手改。除了改程式碼的苦工之外，還要跟不同的團隊合作避免把測試改壞，同時要保持 commit 的清晰才容易解決 merge conflict，追上最新的開發版。來來回回搞了一個月，終於送出一個增減超過五千行的巨大 PR，算是最近工作比較難忘的一件事。</p><p>這過程中也看到各種不同的使用 coroutine 的實作與單元測試寫法，我盡量把我記得的東西寫下來。</p><h1 id="關於升級-kotlinx-coroutine-1-6"><a href="#關於升級-kotlinx-coroutine-1-6" class="headerlink" title="關於升級 kotlinx coroutine 1.6"></a>關於升級 kotlinx coroutine 1.6</h1><p>首先要看官方的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md">Migration Guide</a>，列了不少步驟以及細節。說實在我也是來來回回看了好多遍，才搞懂大部分的意思。需要作 migration 的人可以認真看一下，一方面也是搞懂如何用比較簡潔的方式寫 coroutine unit test</p><p>大致上有幾個重點，在寫 unit test 的時候</p><ol><li>不要用 <code>runBlocking</code> 或是 <code>runBlockingTest</code>，改用 <code>runTest</code></li><li>不要用 <code>TestCoroutineScope</code>，改用 <code>TestScope</code></li><li>不要用 <code>TestCoroutineDispatcher</code>，改用 <code>StandardTestDispatcher</code></li><li>如果實作同時用到其他非同步的工具，好比 RxJava，可以試 <code>UnconfinedTestDispatcher</code> 看看有無奇效</li><li>必要的時候用 <code>runCurrent</code> 確保 pending 的 coroutine 有跑完</li><li>用到 <code>ViewModel.viewModelScope</code> 的話，用 <code>Dispatchers.setMain</code> 把 dispatcher 塞進去</li><li>實作要是有用到 <code>delay</code>，可以用 <code>advanceTimeBy</code> 來控制時間進度</li></ol><p>掌握上面的幾個重點，應該就能處理絕大多數的測試。</p><h1 id="好處：使用一致的風格撰寫-coroutine-的測試"><a href="#好處：使用一致的風格撰寫-coroutine-的測試" class="headerlink" title="好處：使用一致的風格撰寫 coroutine 的測試"></a>好處：使用一致的風格撰寫 coroutine 的測試</h1><p>升級到 <code>1.6.0</code> 之後，我覺得寫 unit test 有比較簡潔一點，而且我把絕大多數的測試包進 <code>runTest</code> 之後，也不需要依賴 Mockito 提供的一些為了測試 coroutine 而增加的工具。整體來說能夠用比較一致的風格來寫單元測試，對於大團隊算是好事。</p><p>寫 coroutine unit test 的主要精神就是，產生一個 <code>TestDispatcher</code>，然後透過這個 <code>TestDispatcher</code> 生出 <code>TestScope</code>，然後注入這些測試專用的 Dispatcher 或是 Scope 到實作的程式裡面。因為這些測試用的物件提供了我們上下其手的空間，所以我們就能預期被測試的實作會如何被執行，以此來進行單元測試。</p><p>Coroutine 的測試最後大概都能寫成這樣，以下是我覺得不錯的風格。(當然一個測試檔案只應該測試一個對象，我一次塞進 <code>foo</code>, <code>bar</code>, <code>foobar</code>, <code>foobarViewModel</code> 只是為了節省空間)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.test.assertEquals</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.ExperimentalCoroutinesApi</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.StandardTestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runCurrent</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runTest</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.setMain</span><br><span class="line"><span class="keyword">import</span> org.junit.Before</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith</span><br><span class="line"><span class="keyword">import</span> org.robolectric.RobolectricTestRunner</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="meta">@RunWith(RobolectricTestRunner::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope) <span class="comment">// inject Scope to implementation Foo</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher) <span class="comment">// inject Dispatcher to implementation Bar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = foo.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = bar.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        foobar.suspendableFunc()</span><br><span class="line"></span><br><span class="line">        runCurrent() <span class="comment">// ensure foobar completed its job</span></span><br><span class="line">        assertEquals(<span class="number">5987</span>, foobar.fetchedResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從上方的範例可以看到</p><ol><li>我用 <code>StandardTestDispatcher</code> 產生一個 <code>TestDispatcher</code></li><li>並且用 <code>TestDispatcher</code> 產生一個 <code>TestScope</code></li><li>這些 Dispatcher 跟 Scope 被注入進 <code>Foo</code>, <code>Bar</code>…等</li></ol><p>接著列出一些常見的例子，解釋該怎麼寫測試比較好。<strong>注意：下方範例裡面的類別，即使同名，介面可能跟上面完全不同，請不要訝異上面下面對不起來。</strong></p><h1 id="如何測試-suspend-function"><a href="#如何測試-suspend-function" class="headerlink" title="如何測試 suspend function"></a>如何測試 suspend function</h1><p>測試一個單純的 <code>suspend</code> function 最簡單了，因為我們可以直接掛在 testScope 底下執行該 function，過程輕鬆簡單</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentValue = fetchRemoteWithDelay(currentValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemoteWithDelay</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar()</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, bar.currentValue)</span><br><span class="line">    bar.suspendableFetch()</span><br><span class="line">    assertEquals(<span class="number">1</span>, bar.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runTest</code> 會產生一個 <code>TestScope</code>，所以在它的 block 裡面，我們可以直接執行 <code>suspend</code> function 而不用擔心太多。</p><h1 id="以注入的-Scope-來執行-suspend-function-的程式，該如何測試"><a href="#以注入的-Scope-來執行-suspend-function-的程式，該如何測試" class="headerlink" title="以注入的 Scope 來執行 suspend function 的程式，該如何測試"></a>以注入的 Scope 來執行 suspend function 的程式，該如何測試</h1><p>以下的範例有個看起來很普通的函式 <code>asyncRead</code>，其實裡面會透過注入的 coroutine scope 執行 suspend function。<code>asyncRead</code> 會直接返回，但我們又想要測試 <code>currentValue</code> 是否有按照預期地被更動</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            currentValue = fetchRemote(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的例子來說，<code>asyncRead</code> 是一個在任何地方都可以呼叫的普通函式，射後不理的特徵讓我們不知道該怎麼測試。但是它是掛在注入的 <code>injectedScope</code> 下來執行，其實很好解決。既然已經注入了 scope，那麼只要在 assert 之前確保 scope 把該做的事情都做完就好。要確保這件事情，就是出動 <code>runCurrent</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.runCurrent()</span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外還有其他寫法，譬如說底下的作法也會通</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;  <span class="comment">// 指定了 dispatcher</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    runCurrent()  <span class="comment">// 不需指定 scope</span></span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要看懂上面這個寫法，就要先弄懂 <code>runTest</code> 做了什麼事。<code>runTest</code> 可以接受一個 CoroutineContext，用它生出一個新的 TestScope。而 <code>runCurrent</code> 雖然是 <code>TestScope</code> 的 extension，實際上拿 <code>TestScope</code> 裡面的 scheduler 來用。因為我們把 <code>testDispatcher</code> 塞給了 <code>runTest</code>，同時又把跟 <code>testDispatcher</code> 綁在一起的 <code>testScope</code> 注入進去 <code>foo</code>。所以 <code>runCurrent()</code> 用的 scheduler 是同一個。</p><p>結論就像下方的 pseudo code 演示的概念</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Just Psuedo Code **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theScheduler = testDispatcher.testScheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(theScheduler) &#123; theScheduler -&gt;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    theScheduler.runCurrent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以什麼時候會用 <code>runTest(testDispatcher)</code> 呢？<strong>想要確保 <code>runTest() &#123;....&#125;</code> 的 block 裡面是用哪個 scheduler 的時候</strong>。(另外也能寫成 <code>testScop.runTest &#123;...&#125;</code>，但我覺得寫 coroutine 的單元測試，控制流程進度應該從 Dispatcher 切入，而非 Scope，所以我都會避免這樣的寫法)</p><h1 id="ViewModel-如何測試"><a href="#ViewModel-如何測試" class="headerlink" title="ViewModel 如何測試"></a>ViewModel 如何測試</h1><p><strong>androidx.lifecycle.lifecycle-viewmodel-ktx</strong> 提供了一個 extension <code>ViewModel.viewModelScope</code>，讓你在 ViewModel 裡面可以莫名其妙就拿到一個 Coroutine Scope 來用。其實實作很簡單，就是拿 <code>Dispatchers.Main</code> 來生出一個 scope 而已。所以在寫單元測試的時候，只要把 Main Dispatcher 換成我們自己的 TestDispatcher 就搞定了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBarViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            updateValue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">()</span></span> = withContext(viewModelScope.coroutineContext) &#123;</span><br><span class="line">        currentValue = <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoobarViewModel</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        foobarViewModel.testFunc()</span><br><span class="line"></span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        runCurrent()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, foobarViewModel.currentValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果跳進去看實作，就會看到 <code>StandardTestDispatcher</code> 跟 <code>UnconfinedTestDispatcher</code> 在建立的時候，如果沒有指定 Scheduler，就會拿同一個 Scheduler 來用，而且是同一個。而且執行 <code>Dispatcher.setMain</code> 的時候把這個 Dispatchers 指定給 Main，<code>TestSceop</code> 也說建購的時期如果沒有指定 Dispatcher，也會拿 Main Dispatcher 來用。所以到最後，這幾個背後都是同一個 Scheduler，也因此 <code>runCurrent</code> 幾乎是隨便亂用都會動(嘖嘖)。</p><h1 id="StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪"><a href="#StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪" class="headerlink" title="StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪"></a>StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪</h1><p>官方 Guide 會看到這句話</p><blockquote><p>In these cases, UnconfinedTestDispatcher() should be used. We ensured that, when run with an UnconfinedTestDispatcher, runTest also eagerly enters launch and async blocks.</p></blockquote><p>當一個 coroutine 由 <code>UnconfinedTestDispatcher</code> 所啟動 (launch)，它會積極地在 caller 的 thread 執行。也就是說當你用這個 Dispatcher 跑起了一個 coroutine，它裡面又產生了一個 coroutine，那麼 <code>UnconfinedTestDispatcher</code> 會盡量去執行這個新的 coroutine。舉例來說</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foobar</span></span>(injectedDispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(injectedDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine A</span></span><br><span class="line">            funA()</span><br><span class="line">        &#125;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funB()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcA&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine C</span></span><br><span class="line">           funC()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcA&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcB&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funcD()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcB&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funC</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;running funcC&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funcD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;running funcD&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printMsg</code> 會產生兩個 coroutine，一個跑 <code>funA</code>，一個跑 <code>funB</code>。<code>funA</code> 執行的時候會 launch 一個 coroutine 來跑 <code>funC</code>，<code>funB</code> 也會 launch 一個 coroutine 來跑 <code>funD</code></p><p>用 <code>StandardTestDispatcher</code> 的測試程式如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    assert(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>如果把依序把 <code>funA</code> 產生的 coroutine 稱為 <code>coroutine A</code>，那麼執行的順序就是</p><ol><li>coroutine A</li><li>coroutine B</li><li>coroutine C</li><li>coroutine D</li></ol><p>接著改用 <code>UnconfinedTestDispatcher</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = UnconfinedTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>執行順序變成</p><ol><li>coroutine A</li><li>coroutine C</li><li>coroutine B</li><li>coroutine D</li></ol><p>A 排在 B 前面，而 A 裡面產生的 C 被 Dispatcher 積極執行，所以插隊在 B 前面，這就是 Guide 裡面說的 Eagerly</p><p>如果你的實作混用了其他 library 的非同步功能(ie: Rx)，有時候用 <code>UnconfinedTestDispatcher</code> 可以讓程式的執行順序跑得比較像一般函式呼叫的順序。但是長久來說，還是避免一堆工具混在一起作牛丸，盡量用單一工具來做非同步比較好。</p><h1 id="何時使用-advanceTimeBy"><a href="#何時使用-advanceTimeBy" class="headerlink" title="何時使用 advanceTimeBy"></a>何時使用 advanceTimeBy</h1><p>有時候會用到 <code>delay</code> 或是其他函式對一個 coroutine 的執行時間作調整</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            delay(<span class="number">2000</span>) <span class="comment">// 白金之星！...好吧，它是 delay 而非暫停時間</span></span><br><span class="line">            currentValue = <span class="number">9527</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>advanceTimeBy</code> 可以把 dispatcher 裡面的虛擬時鐘調快，就像老闆的替身能力克里姆王的那樣刪除一段時間</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(-<span class="number">1</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.advanceTimeBy(<span class="number">3000</span>) <span class="comment">// 老闆能力發動！</span></span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Troubleshooting-用到兩個-TestDispatcher-會出錯"><a href="#Troubleshooting-用到兩個-TestDispatcher-會出錯" class="headerlink" title="Troubleshooting: 用到兩個 TestDispatcher 會出錯"></a>Troubleshooting: 用到兩個 TestDispatcher 會出錯</h1><p>有時候會看到這個錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br><span class="line">java.lang.IllegalStateException: Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br></pre></td></tr></table></figure><p>那是因為不小心產生了兩個 TestDispatcher，好比以下這段程式，使用 <code>withContext</code> 的時候經常發生這個錯誤。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>(<span class="keyword">val</span> dispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFunc</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(dispatcher)&#123; <span class="comment">// 這裡用注入的 Dispatcher</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123; <span class="comment">// runTest 自己產生一個 Dispatcher，接著再以此生出 TestScope</span></span><br><span class="line">        bar.suspendableFunc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bar.suspendableFunc()</code> 會用注入的 Dispathcer，<code>runTest</code> 如果不指定一個 <code>TestDispatcher</code>，它內部實作也會產生一個新的。</p><p>讓兩邊都用同一個 TestDispatcher 就可以解決問題。下面就是讓 runTest 使用同一個 Dispatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">    bar.suspendableFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果有個函式用到-withContext-Dispatcher-IO-，該如何測試"><a href="#如果有個函式用到-withContext-Dispatcher-IO-，該如何測試" class="headerlink" title="如果有個函式用到 withContext(Dispatcher.IO)，該如何測試"></a>如果有個函式用到 withContext(Dispatcher.IO)，該如何測試</h2><p>有時候我們會看到以下這樣的作法。<code>fetchRemote</code> 是個跑在 <code>Dispatcher.IO</code> 上面的耗時函數，外部呼叫 <code>asyncRead</code> 之後就可以射後不理，等到 <code>returnValue</code> 更新了，再去更新 UI</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> returnedValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            returnedValue = fetchRemote()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要測試 <code>asyncRead</code> 就會變得很麻煩，雖然已經注入了一個 <code>injectedScope</code>，但是在 <code>fetchRemote</code> 跑在我們測試程式碼裡面完全碰不到的 <code>Dispatchers.IO</code>。</p><p>有個滿噁心的寫法：利用 <code>withContext</code> 來測試。</p><p><code>withContext</code> 會拿當下的 coroutine context 跟透過參數指定進去的 context，兩個 merge 起來產生新的 context，接著用新的 context 裡面的 coroutine scope 執行 block 裡面的程式，直到該 scope 完成之後才離開 block。所以單元測試只要拿 <code>withContext</code> 產生的 scop 注入進去測試對象就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    <span class="keyword">var</span> localFoo: Foo</span><br><span class="line">    withContext(testDispatcher) &#123;</span><br><span class="line">        localFoo = Foo(<span class="keyword">this</span>) <span class="comment">// `this` is a coroutineScope that created by withContext</span></span><br><span class="line">        localFoo.asyncRead()</span><br><span class="line">        assertEquals(<span class="number">0</span>, localFoo.returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line">    assertEquals(<span class="number">9527</span>, localFoo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我覺得測試寫成這樣太過取巧，很可能遭天譴或是被人恥笑。有辦法修改的話，還是把類別改寫得比較容易測試才是正途。譬如說”inject Dispatcher” + “default value”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope: CoroutineScope,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ioDispatcher: CoroutineDispatcher = Dispatchers.IO</span><br><span class="line">) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(ioDispatcher) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scope, dispatcher, 球員，裁判都是我的，測試就會變得很好寫</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope, testDispatcher)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.returnedValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line"></span><br><span class="line">    runCurrent()</span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>寫 coroutine 的單元測試，主要是要先搞懂當下在用的是哪個 Scope 或 Dispatcher，釐清它執行的順序，接著就是確保在 assert 之前把該做的事情做完。既然談到執行順序，又回到大家早就知道的概念，實作的時候要適當地注入 Dispatcher，這樣測試才會好寫。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前因為工作的需要，把 kotlin 從 &lt;code&gt;1.5.2&lt;/code&gt; 升級到 &lt;code&gt;1.6.0&lt;/code&gt;，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>紀錄三讀通過交通處罰條例</title>
    <link href="https://jchu.cc/2021/12/10-ly.html"/>
    <id>https://jchu.cc/2021/12/10-ly.html</id>
    <published>2021-12-10T13:32:34.000Z</published>
    <updated>2021-12-10T14:48:04.034Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    ol li {        line-height: 1.3rem;    }    .del {        background-color: #FCC;    }    .add {        background-color: #CFC;    }</style><p>今天看到<strong>道路交通管理處罰條例第七條之二條文修正草案</strong>三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下</p><span id="more"></span><h1 id="三讀通過的條文"><a href="#三讀通過的條文" class="headerlink" title="三讀通過的條文"></a>三讀通過的條文</h1><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100412:LCEWA01_100412_00092">立法院第 10 屆第 4 會期第 12 次會議議案關係文書</a> (備份檔： <a href="/2021/12/10-ly/final.pdf" title="final.pdf">final.pdf</a> )</p><p>法條修改的部份如下</p><p><strong>現行條文</strong></p><blockquote><p>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p></blockquote><p><strong>通過條文</strong></p><blockquote><p>第七條之一 民眾對於下列違反本條例之行為者，得敘明違規事實並檢具違規證據資料，向公路主管或警察機關檢舉：<br>(…..略….)<br>公路主管機關或警察機關對於第一項之檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。民眾依第一項規定檢舉同一輛汽車二以上違反本條例同一規定之行為，其違規時間相隔未逾六分鐘及行駛未經過一個路口以上，公路主管或警察機關以舉發一次為限。公路主管或警察機關對第一項檢舉之逕行舉發，依本條例第七條之二第五項規定辦理。</p></blockquote><p>主要的變化是，原本民眾可以針對道路交通管理處罰條例的違規事項做檢舉，現在變成只有正面表列的違規事項才能檢舉。「略」裏面放了一長串的條文 reference，指出哪些違規事項是民眾可以檢舉的，底下列出各個被參考條文的大意</p><ol><li><p>第三十條第一項第二款。</p><ul><li>汽車裝載時，有下列情形之一者…所載貨物滲漏、飛散、脫落、掉落或氣味惡臭。</li></ul></li><li><p>第三十一條第六項或第三十一條之一第一項至第三項。</p><ul><li>機車駕駛人或附載座人未依規定戴安全帽者，處駕駛人新臺幣五百元罰鍰。</li><li>汽車駕駛人於行駛道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣三千元罰鍰。</li><li>機車駕駛人行駛於道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣一千元罰鍰。</li><li>汽機車駕駛人行駛於道路，手持香菸、吸食、點燃香菸致有影響他人行車安全之行為者，處新臺幣六百元罰鍰。</li></ul></li><li><p>第三十三條第一項第二款、第三款、第四款、第七款、第九款、第十一款至第十六款、第四項或第九十二條第七項。</p><ul><li>汽車行駛於高速公路、快速公路或設站管制之道路…有下列行為者…<ul><li>未保持安全距離</li><li>未依規定行駛車道</li><li>未依規定變換車道</li><li>違規超車、迴車、倒車、逆向行駛</li><li>未依規定使用路肩</li><li>裝置貨物未依規定覆蓋、捆紮。</li><li>未依標誌、標線、號誌指示行車。</li><li>進入或行駛禁止通行之路段。</li><li>連續密集按鳴喇叭、變換燈光或其他方式迫使前車讓道。</li><li>行駛中向車外丟棄物品或廢棄物。</li><li>車輪、輪胎膠皮或車輛機件脫落</li></ul></li><li>不得行駛或進入第一項道路之人員、車輛或動力機械，而行駛或進入者</li><li>汽缸排氣量五百五十立方公分以上之大型重型機車行駛高速公路，有下列行為者…..</li></ul></li><li><p>第四十二條。</p><ul><li>汽車駕駛人，不依規定使用燈光者</li></ul></li><li><p>第四十三條第一項第一款、第三款、第四款或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者…道路上蛇行，或以其他危險方式駕車</li></ul></li><li><p>第四十四條第二項或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者<ul><li>行近未設行車管制號誌之行人穿越道，不減速慢行</li><li>行經設有彎道、坡路、狹路、狹橋或隧道標誌之路段或道路施工路段，不減速慢行</li></ul></li></ul></li><li><p>第四十五條第一項第一款、第三款、第四款、第六款、第十三款、第十六款或第二項。</p><ul><li>汽車駕駛人，爭道行駛有下列情形之一者….<ul><li>不按遵行之方向行駛</li><li>不依規定駛入來車道</li><li>在多車道不依規定駕車</li><li>駕車行駛人行道</li><li>機車不在規定車道行駛</li><li>佔用自行車專用道</li></ul></li><li>聞消防車、救護車、警備車、工程救險車、毒性化學物質災害事故應變車之警號，不立即避讓者</li></ul></li><li><p>第四十七條。</p><ul><li>汽車駕駛人超車時，有下列情形之一者…..注：各種危險超車</li></ul></li><li><p>第四十八條第一項第二款、第四款、第五款或第七款。</p><ul><li>汽車駕駛人轉彎或變換車道時，有下列情形之一者….不依標誌、標線、號誌指示</li></ul></li><li><p>第四十九條。</p><ul><li>汽車駕駛人迴車時，有下列情形之一者…注：各種危險迴轉</li></ul></li><li><p>第五十三條或第五十三條之一。</p><ul><li>汽車駕駛人，行經有燈光號誌管制之交岔路口闖紅燈者，及前項紅燈右轉行為者</li><li>車駕駛人，行經有燈光號誌管制之大眾捷運系統車輛共用通行交岔路口闖紅燈者，及前項紅燈右轉行為者</li></ul></li><li><p>第五十四條。</p><ul><li>汽車駕駛人，駕車在鐵路平交道有下列情形之一者….注：各種平交道危險事項</li></ul></li><li><p><code>第五十五條第一項第二款或第四款併排臨時停車。</code></p></li><li><p><code>在第五十五條第一項第二款規定禁止臨時停車之處所停車。</code></p></li><li><p><code>第五十六條第一項第十款及第二項。</code></p></li><li><p>第六十條第二項第三款</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一，而本章各條無處罰之規定者….注：各種不遵守指揮的行為</li></ul></li></ol><p>上面可以看到列了一大堆東西，其實都是一般人不太會去檢舉的事項，我們最關心的就是違規停車。也就是第 13, 14, 15 個項目提及的東西。第五十五條跟第五十六條裡面，我們還剩下哪些能檢舉呢？</p><p>塗上紅色的，就是民眾在修法過後，不能檢舉的事項</p><p>第 55 條</span></p><ol><li><span class="del">汽車駕駛人，臨時停車有下列情形之一者，處新臺幣三百元以上六百元以下罰鍰：</span><ul><li><span class="del">一、在橋樑、隧道、圓環、障礙物對面、人行道、行人穿越道、快車道臨時停車。</span></li><li><span class="add">二、在交岔路口、公共汽車招呼站十公尺內或消防車出、入口五公尺內臨時停車。</span></li><li><span class="del">三、在設有禁止臨時停車標誌、標線處所臨時停車。</span></li><li><span class="add">四、不依順行之方向，或不緊靠道路右側，或單行道不緊靠路邊，或併排臨時停車。</span></li><li><span class="del">五、在道路交通標誌前臨時停車，遮蔽標誌。</span></li></ul></li><li><span class="del">接送未滿七歲之兒童、行動不便之人上、下車者，臨時停車不受三分鐘之限制。</span></li></ol><p>第 56 條</p><ol><li><span class="del">汽車駕駛人停車時，有下列情形之一者，處新臺幣六百元以上一千二百元以下罰鍰：</span><ul><li><span class="del">一、在禁止臨時停車處所停車。</span></li><li><span class="del">二、在設有彎道、險坡、狹路標誌之路段、槽化線、交通島或道路修理地段停車。</span></li><li><span class="del">三、在機場、車站、碼頭、學校、娛樂、展覽、競技、市場、或其他公共場所出、入口或消防栓之前停車。</span></li><li><span class="del">四、在設有禁止停車標誌、標線之處所停車。</span></li><li><span class="del">五、在顯有妨礙其他人、車通行處所停車。</span></li><li><span class="del">六、不依順行方向，或不緊靠道路右側，或單行道不緊靠路邊停車。</span></li><li><span class="del">七、於路邊劃有停放車輛線之處所停車營業。</span></li><li><span class="del">八、自用汽車在營業汽車招呼站停車。</span></li><li><span class="del">九、停車時間、位置、方式、車種不依規定。</span></li><li><span class="add">十、於身心障礙專用停車位違規停車。</span></li></ul></li><li><span class="add">汽車駕駛人停車時，有併排停車之情事者，處汽車駕駛人新臺幣二千四百元罰鍰。</span></li><li><span class="del">汽車駕駛人在道路收費停車處所停車，依規定繳費，主管機關應書面通知駕駛人於七日內補繳，並收取必要之工本費用，逾期再不繳納，處新臺幣三百元罰鍰。</span></li><li><span class="del">第一項及第二項情形，交通勤務警察、依法令執行交通稽查任務人員或交通助理人員，應責令汽車駕駛人將車移置適當處所；如汽車駕駛人不予移置或不在車內時，得由該交通勤務警察、依法令執行交通稽查任務人員或交通助理人員為之。</span></li><li><span class="del">第一項第十款應以最高額處罰之，第三項之欠費追繳之。</span></li><li><span class="del">在圓環、交岔路口十公尺內，公路主管機關、市區道路主管機關或警察機關得在不妨害行人通行或行車安全無虞之原則，設置必要之標誌或標線另行規定汽車之停車處所。</span></li></ol><h1 id="委員提案"><a href="#委員提案" class="headerlink" title="委員提案"></a>委員提案</h1><p>看完了三讀通過的法案，再看一下立委的原始提案。</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100114:LCEWA01_100114_00063">院總第 756 號 委員提案第 24811 號</a> (備份檔： <a href="/2021/12/10-ly/24811.pdf" title="24811.pdf">24811.pdf</a> )</p><p>提案人：陳歐珀<br>連署人：莊競程 陳亭妃 賴惠員 賴品妤 莊瑞雄 林楚茵 吳玉琴 楊 曜 黃國書 黃秀芳 王美惠 邱泰源 劉世芳 陳明文 洪申翰 何欣純 林宜瑾 范雲</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/24811.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="del">應即舉發</span>。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="add">先給予勸導，若同一違規事實再犯者，即予舉發</span>。但行為終了日起逾七日之檢舉，不予舉發</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100202:LCEWA01_100202_00068aa">院總第 756 號 委員提案第 25053 號</a> (備份檔： <a href="/2021/12/10-ly/25053.pdf" title="25053.pdf">25053.pdf</a> )</p><p>提案人：鄭正鈐<br>連署人：陳玉珍 翁重鈞 鄭天財 Sra Kacaw 張育美 謝衣鳯 李貴敏 李德維 吳怡玎 陳以信 呂玉玲 廖婉汝 魯明哲 陳雪生 洪孟楷 林文瑞 徐志榮 葉毓蘭 林德福 孔文卲 林思銘 吳斯懷 溫玉霞 蔣萬安</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/25053.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">對於不影響交通安全之違規檢舉案件，應先開立勸導單，其類型由主管機關定之。</span></p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100306:LCEWA01_100306_00015">院總第 756 號 委員提案第 26098 號</a> (備份檔： <a href="/2021/12/10-ly/26098.pdf" title="26098.pdf">26098.pdf</a> )</p><p>提案人：林俊憲 林宜瑾<br>連署人：陳歐珀 羅美玲 蘇巧慧 陳明文 趙天麟 邱議瑩 陳素月 賴惠員 劉建國 周春米 蔡易餘 蘇治芬 邱志偉 劉櫂豪</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/26098.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">兩件違規舉發事項之時間需相隔六分鐘以上或行駛經過一個路口以上。</span></p><h1 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h1><p>我是相當在意交通環境的人，長期以來對於台灣的交通一直都是非常失望。好不容易近幾年來大家開始知道要尊重行人路權，知道要減少違規停車，交通安全意識要開始進步的時候，立委修法限縮了這個人民對付交通惡霸的武器。</p><p>不管修法的方向是什麼，總是要有個冠冕堂皇的理由。今天立委們刻意放大「惡意檢舉」的案例來強化自己修法的正當性，而避談無獎金的踴躍檢舉，是因為民眾對糟糕的交通環境累積的長期不滿，現在立委的修法討好了喜歡貪便宜的人，犧牲的是乖乖遵守交通規則的人</p><p>修法的提案人，有國民黨的鄭正鈐，也有民進黨的陳歐珀，林俊憲，林宜瑾。為了討好民眾，甘願犧牲台灣長久利益的這種作為，藍綠沒什麼差別。</p><p>我不談道德，只談利益。遵守規則往往也要付出成本，如果不能讓迴避規則的人承受更大的壓力，要怎麼說服多數的人去遵守交通規則呢？</p><p>今天立委這樣的修法，正是告訴人民：違規停車只要沒被警察看到，就沒關係。如果你會為了交通安全，乖乖地花錢把車停到停車場，再花三十分鐘來回只為買個便當？那是你笨，不懂得精打細算省錢省時間</p><p>我當這種笨蛋很多年了，今天我真是深深覺得自己笨得可以</p><p>立委都開綠燈了，台灣的交通安全？你要學著當聰明用路人啊！</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://www.youtube.com/watch?v=3pRnMH1iqrA"> 羅火花 - 縮限檢舉來啦！大違規時代人行道紅線爽違停！我教你怎樣減少違規停車啦立委們！</a></li><li><a href="https://www.thenewslens.com/article/135482">要消滅檢舉達人，形象清新的賴品妤為何成為「羅淑蕾第二」？</a></li><li><a href="https://www.thenewslens.com/article/132505">這天新竹碾死一個機車騎士，真正的兇手是充滿人情味的「微罪不罰」</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    ol li {
        line-height: 1.3rem;
    }
    .del {
        background-color: #FCC;
    }
    .add {
        background-color: #CFC;
    }

&lt;/style&gt;

&lt;p&gt;今天看到&lt;strong&gt;道路交通管理處罰條例第七條之二條文修正草案&lt;/strong&gt;三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
    <category term="government" scheme="https://jchu.cc/tags/government/"/>
    
  </entry>
  
  <entry>
    <title>ActivityPub 簡單介紹</title>
    <link href="https://jchu.cc/2021/07/27-activitypub.html"/>
    <id>https://jchu.cc/2021/07/27-activitypub.html</id>
    <published>2021-07-27T12:43:59.000Z</published>
    <updated>2021-07-27T14:57:33.752Z</updated>
    
    <content type="html"><![CDATA[<p><a href="devpoga.org">Poga</a> 架了 <a href="https://g0v.social/">g0v.social</a> 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。</p><p>不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。</p><span id="more"></span><p>Mastodon 是一個類似 Twitter 的 Microblog service application，比起 Twitter 這樣的集中式服務，Mastodon 讓你對自己帳號的掌控權「更多一點」。</p><p>Mastodon 稱自己為去中心化、聯邦式(Federation)的程式。</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_federation.svg" class=""></div><p>Twitter 是集中式(Centralized)的服務，我們都很清楚 Centralized 的運作方式：要連上一個別人管理的網站，在上面註冊帳號、與其他帳號互動。</p><p>Git 就是我們習慣的分散式(Distributed)工具，在 Git 的使用情境裡，任何人都可以弄個 repository 成為別人的 upstream，彼此之間地位相等，隨時可以增加或減少網絡裡的節點。</p><p>Federation 則是介於兩者中間。基本上我們還是要連上某個別人架設好的伺服器；當然你要自己 host 一個也可以。各個服務器之間透過一個公認的規則(ActivityPub)交換訊息，或是透過某種潛規則排擠某一個伺服器。</p><p>於是乎，我就有了三個問題</p><ol><li>如果我的帳號在 Server A，而我的朋友十分鐘前剛剛自己架了一個 Server B，我有辦法 follow 他在新伺服器的帳號嗎？<ul><li>簡答：基本上可以，但有可能不行</li></ul></li><li>當我寫了一個新的 Post，我的 100 個 follower(來自 20 個不同 servers) 該怎麼知道我的新貼文？<ul><li>簡答：由 Server to Server federation protocol 處理</li></ul></li><li>既然沒有一個專屬的機構負責當真理部，該如何避免 spam 或是仇恨言論？<ul><li>簡答：潛規則的政治手段解決</li></ul></li></ol><p>查詢相關的 Spec，一定會看到三個 W3C spec: Activity Vocabulary, ActivityStream 與 ActivityPub</p><p>其實我覺得這三份文件，比起 RFC 都寫得滿籠統，定義會在三者之間相互指涉，看到後面都不懂某個名詞的確切意義是什麼，可能是我看 W3C 規格的功力不夠，這三份又特別有彈性。</p><p>我盡可能列出我對這三份文件的理解。以我的淺薄理解，很明顯對於實作沒有太大的幫助，可能要看過 Mastodon 的程式碼的人比較能回答細節的問題。</p><h3 id="Activity-Vocabulary"><a href="#Activity-Vocabulary" class="headerlink" title="Activity Vocabulary"></a>Activity Vocabulary</h3><blockquote><p>It is intended to be used in the context of the ActivityStreams 2.0 format and provides a foundational vocabulary for activity structures, and specific activity types.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-vocabulary/">Activity Vocabulary</a></li></ul><p>這一份文件為 ActivityStream 會用到的字彙給出更細微的定義，定義每個 Type 或是 property 的意義。這裡面定義了三個 Core types <code>Object</code> <code>Link</code> and <code>Activity</code>。他們之間以及子類別的關係大致如下</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_activity_vocabulary.svg" class=""></div><p>雖然 Activity Vocabulary 只定義了一些類別，但是開發者可以添加更多的延伸類別(由 Activity Stream 定義)。</p><p>一個基本的 Activity 看起來像這樣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@context&quot;</span>: <span class="string">&quot;https://www.w3.org/ns/activitystreams&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Activity&quot;</span>,</span><br><span class="line">  <span class="string">&quot;summary&quot;</span>: <span class="string">&quot;Sally did something to a note&quot;</span>,</span><br><span class="line">  <span class="string">&quot;actor&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sally&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Note&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;A Note&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity Vocabulary 文件試著解釋每個 property 的用處為何。在閱讀 spec 的時候看到 <code>Domain</code> 指的是這個 property 可以被用在哪個 type 上面。<code>Range</code> 則是說這個 property 可以塞進哪些值</p><h3 id="Activity-Stream"><a href="#Activity-Stream" class="headerlink" title="Activity Stream"></a>Activity Stream</h3><blockquote><p>This specification details a model for representing potential and completed activities using the JSON format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-core/">ActivityStream</a></li></ul><p>以 JSON 的格式，拿 Activity Vocabulary 定義好的 properties, type 來組合使用，呈現「活動」(actities)，換句話說，這份文件定義了，Activity Vocabulary 定義好的東西，該怎麼拿來用，才能呈現一個事件(Activity)</p><p>這個 Spec 對大多數的 Object 僅僅只有定義不完備的語意，所以可以在 Activity Vocabulary 之外延伸定義更多的細節，也能定義新的 Object type。但是如果仰賴太多延伸定義的類型，那麼 Server 之間會不能溝通</p><h3 id="ActivityPub"><a href="#ActivityPub" class="headerlink" title="ActivityPub"></a>ActivityPub</h3><blockquote><p>The ActivityPub protocol is a decentralized social networking protocol based upon the ActivityStreams 2.0 data format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitypub/">ActivityPub</a></li></ul><p>以 ActivityStream 為基礎，定義出去中心化的社交網路協定分成兩部分</p><ul><li>Server to server federation protocol</li><li>Client to server protocol</li></ul><p>這份 Spec 裡面介紹了什麼是 Actor 以及幾個常見的 Activity</p><p>我們所創立的帳號就是 Actor (有沒有其他 Actor 我不確定)。一個 Actor 必須要有這些欄位</p><ul><li>inbox (OrderedCollection)</li><li>outbox (OrderedCollection)</li><li>following</li><li>followers<ul><li>記錄這個 Actor 有多少 follower。以後新增 Activity 的時候會通知這些 follower</li><li>實作上可以設定 filter 讓 authenticated user 有更高的優先權</li></ul></li><li>liked</li><li>streams</li><li>……</li></ul><p>Activity 就是 Actor 在平台上產生的活動，包括但不限於送訊息、追蹤別人、發貼文等等</p><p>Spec 裡面舉例了訊息該怎麼傳遞，畫成圖就是下面的樣子。每個帳號(Actor)都會有一個 INBOX 與 OUTBOX，送出訊息的話，先是把訊息透過 Client-to-Server-protocol 寫進自己的 OUTBOX，接著再由 Server-to-Server-federation-protol 把訊息送到對方的 INBOX。對方上線後去看自己的 INBOX 就能讀到訊息</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_send_message.svg" class=""></div><p>從上面的訊息傳遞，可以看到一個重點：</p><p><strong>Server 之間的訊息傳遞，是以 POST 為主，而非 GET</strong></p><p>也就是說，當 Actor B 想要知道 Actor A 有沒有送訊息過來，並非發出請求叫 Server B 去 Server A 看看 Actor A 的 OUTBOX，而是 Server A 比需要主動檢查 Actor A 的 OUTBOX，把訊息傳遞給對應的 Server B (也可能是其他 Server)。如果 Server A 沒做好這件事情，則 Actor B 永遠不會知道 Actor A 對 B 說了某些話。這個互動的模型看起來是發生在 ActivityPub 的所有 Server-to-Server-federation-protocol 上面，也影響了後續的很多行為</p><p>接著來看 Follow，假設有 Actor A 想要 Follow Actor B</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_follow_activity.svg" class=""></div><p>Actor A 發出了一個 Follow Activity 想要訂閱 Actor B，到 Step 3 之前都跟前面一樣。Step 4 就是一個由實作彈性決定的步驟：「要不要接受這個 follow」，也就是說要不要送出一個 Accept Activity</p><p>以 Twitter 的行為來舉例的話，就是「預設 Accept 所有的 Follow Request」，但是在 Activity Pub 裡面可以有 Reject 的空間，也可以預設就是 Accept</p><p>這邊的重點在於 <strong>發出的 <code>Follow Activity</code> 要被接受，才會把 Actor 放進 Follower</strong>。回到上一段講到的重點，Server 之間的互動是以 POST 為主。當 Actor A 的 Follow activity 被 Actor B 接受之後，Actor B 才會把 A 放進 Follower 的清單裡面。當 Actor B 發出新貼文的時候，只會通知 Follower。如果 A 不在清單裡面，那麼它不會知道 B 有新的貼文</p><p>畫成圖片就像這樣</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_create_activity.svg" class=""></div><p>Actor B 寫了一篇新文，產生了 <code>Create Activity</code>，Step 2 找出 Actor B 想要通知 (POST) 的對象，然後把訊息送出去 (Step 3, 4, 5)。送出的接受對象可能是單一的 Actor，也可能是一個共用的 INBOX</p><p>ActivityPub 裡面就大概定義了這些看起來滿高階的行為，但是更細節的部分就沒討論到，大概是保留實作的彈性吧</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>回到前面一開始的三個問題。理論上只要 Server 可以把 Follow Activity 送到其他 Server，那麼我就可以追蹤任意 Server 上面的帳號。但是 Server 之間可以相互封鎖對方，因此我認為答案是 Yes and No。問題二上面已經回答了。至於問題三，我認為是透過 Server 之間的封鎖(過濾)行為來達成的。</p><p>Server admin 可以決定哪些 Server 的訊息可以進來，就像每個城市都可以決定規則，允許哪些外人進入城內。對於總是產出壞人的城市予以拒絕，對於表現優良的城市給予通行，於是 Server 之間就組成了 Federation。Mastodon 的服務群，還能夠組成 <a href="https://en.wikipedia.org/wiki/Fediverse">Fediverse</a>。</p><p>Serve 之間是依照彼此的價值觀組成一個群體，所以我認為是潛規則驅動，用政治方式解決仇恨言論的問題。有興趣的還可以看這篇 <a href="https://www.theverge.com/2019/7/12/20691957/mastodon-decentralized-social-network-gab-migration-fediverse-app-blocking">How the biggest decentralized social network is dealing with its Nazi problem</a>。至於 Server 內的仇恨言論？當然就由 Admin 決定要不要一巴掌拍死囉</p><p>對於一般來說使用者來說還是受制於 Server admin 的管轄，所以我會說使用者只是對自己的帳號稍微多了一點掌控權(你不一定要從某個你很討厭的 server 加入 federation)</p><p>雖然這樣感覺起來似乎有稍微擺脫科技巨頭的箝制。但是回頭想想，Hosting, Domain name 跟我們註冊的 e-mail 帳號還是給大公司牢牢抓著，小個體戶擁有的自由依然比想像中小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;devpoga.org&quot;&gt;Poga&lt;/a&gt; 架了 &lt;a href=&quot;https://g0v.social/&quot;&gt;g0v.social&lt;/a&gt; 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。&lt;/p&gt;
&lt;p&gt;不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>Thinkpad TrackPoint Keyboard 2 works well on Macbook Pro 2019</title>
    <link href="https://jchu.cc/2021/07/05-tp-keyboard.html"/>
    <id>https://jchu.cc/2021/07/05-tp-keyboard.html</id>
    <published>2021-07-05T13:47:12.000Z</published>
    <updated>2021-07-06T14:31:35.318Z</updated>
    
    <content type="html"><![CDATA[<p>Conclusion: I had bought a Thinkpad TrackPoint Keyboard 2 yesterday (2021 July 4th), it works well on my Macbook Pro. I don’t find a way to adjust scroll direction (becase I enabled Natural scroll direction for built-in trackpad). Except this. I would like to say: it works perfect.</p><span id="more"></span><p>My configuration</p><ul><li>Mac OS X 11.4 Big Sur</li><li>Macbook Pro 15-inch 2019, Intel Core i9</li></ul><p>Test result</p><ul><li>✅ Bluetooth connection has no problem</li><li>✅ 2.4G connection has no problem</li><li>✅ Fn key has no problem</li><li>✅ TrackPoint has no problem</li></ul><p>When pairing TP keyboard to MBP, do not forget to input Pin code. If you don’t like the default key mapping, <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a> will help you a lot. Inlcudes switching key layout, or disabling TrackPoint middle key.</p><p>Pressing <code>Fn</code> + <code>Esc</code> to enable FnLock, then you could use Function keys as usual.</p><p>Since I enabled Natural scroll direction in MBP for its built-in trackpad, using TrackPoint for scrolling will apply opposit direction, and I haven’t found a way to address this issue. But this is not big deal for me.</p><div style="max-width: 300px; margin: auto;"><img src="/2021/07/05-tp-keyboard/pic.jpg" class=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Conclusion: I had bought a Thinkpad TrackPoint Keyboard 2 yesterday (2021 July 4th), it works well on my Macbook Pro. I don’t find a way to adjust scroll direction (becase I enabled Natural scroll direction for built-in trackpad). Except this. I would like to say: it works perfect.&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="tools" scheme="https://jchu.cc/tags/tools/"/>
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>What is 「交通規則をにげろ」</title>
    <link href="https://jchu.cc/2021/07/02-nihongo.html"/>
    <id>https://jchu.cc/2021/07/02-nihongo.html</id>
    <published>2021-07-01T17:13:33.000Z</published>
    <updated>2021-07-06T14:32:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>It is funny that there were lots of Japanese languae learner were asking the meaning of “交通規則を逃げろ(にげろ)”, but every japanese native speaker answers “this sentence doesn’t make sense”.</p><span id="more"></span><p>But, why there were so many learners asking same question?</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_1.jpg" class=""></div><p>Because they all used みなの日本語II as text book. In page. 62 you will find this example</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_2.jpg" class=""></div><p>The answer is quite simple: We misinterpreted the format.</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_3.jpg" class=""></div><p>Wrong</p><ol><li>交通規則を逃げろ</li><li>交通規則をまもれ</li></ol><p>Correct</p><ol><li>逃げろ</li><li>交通規則をまもれ</li></ol><p>Oh, yes, I made the same mistake yesterday, haha!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;It is funny that there were lots of Japanese languae learner were asking the meaning of “交通規則を逃げろ(にげろ)”, but every japanese native speaker answers “this sentence doesn’t make sense”.&lt;/p&gt;</summary>
    
    
    
    <category term="japan" scheme="https://jchu.cc/categories/japan/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>《BLEACH 死神》雜感</title>
    <link href="https://jchu.cc/2021/06/22-bleach.html"/>
    <id>https://jchu.cc/2021/06/22-bleach.html</id>
    <published>2021-06-22T13:25:07.000Z</published>
    <updated>2021-06-26T16:39:14.814Z</updated>
    
    <content type="html"><![CDATA[<p>漫畫<a href="https://zh.wikipedia.org/wiki/BLEACH">BLEACH 死神</a> 是從 2001 年我高中時期就開始連載的漫畫，一直到 2016 年出了完結篇，此時我不但已經工作好多年，連小孩都已經出生了。這部漫畫最輝煌的時候，也橫跨了我的整個青少年時期，最後差不多以相當難堪的結局收場，不免唏噓。稍微紀錄一下心得，也當作是給模糊的青春記憶加個分號</p><span id="more"></span><h2 id="跟咒術迴戰的比較"><a href="#跟咒術迴戰的比較" class="headerlink" title="跟咒術迴戰的比較"></a>跟咒術迴戰的比較</h2><p>會想起這部漫畫，老實說是因為咒術迴戰。雖然五条悟因為遮眼與朝天髮讓人頗容易聯想到卡卡西，但是咒術迴戰的主題是人與妖怪咒物的互動，而且美型的人物，還有片尾曲的日常生活細節溢滿渋谷青少年的時尚感，很難不聯想到 BLEACH。網路上不少文章也提到，芥見下下的偶像就是 BLEACH 的作者久保帶人，所以咒術迴戰有 BLEACH 的影子也不意外。</p><p>咒術迴戰的主角虎杖悠仁，跟 BLEACH 的男主角黑崎一護兩者也都還滿多相近的設定。同樣都是以高中生為副業，打怪物為本業，能力當然有主角威能加持而天生神力，體內也都有個神秘而難以控制的強大力量，這些都算是王道漫畫的基本配備。此外兩人同樣都是會用心替朋友著想的好心腸，日常生活中也都是同學圈裡的重心，當然還有其他漫畫主角也是同樣的設定，但是比較到這邊就能確認，芥見的虎杖跟久保的一護有相當程度的重疊。</p><p>只是，虎杖在網路上大家都相當疼惜地叫他「乖孫」，雖然有些人沒有很愛他，但是大致上虎杖角色拿到的都是好評。相反地，一護的評價就差得多，不外乎是重聽(常常講：「你..你說什麼」)跟情緒化的嘶吼(「你說什麼！！」)，常常叫到連漫畫裡面的其他人物都請他安靜一點。明明是相當類似的主角性格，得到的評價卻天差地遠，只能說是久保把故事導壞了</p><h2 id="強度崩壞是問題但不是致命傷"><a href="#強度崩壞是問題但不是致命傷" class="headerlink" title="強度崩壞是問題但不是致命傷"></a>強度崩壞是問題但不是致命傷</h2><p>忘了是哪看到的大師名言： <strong>所有的故事就是在追尋某樣東西的過程</strong> ，我不確定這個標準適用的範圍能有多廣，但是在少年漫畫上大致成立。不管是找爸爸、找弟弟的身體、大秘寶，或是要找到魔王把他揍一頓，少年漫畫就是一個在實踐目標的過程所發生的事情。作者就是導演，絕大多數的漫畫我們都猜得到結局(或說就是那幾種組合)，正如絕大多數的電影。但我們想看的是主角怎麼走完這段路。</p><p>強度的設定一直都是少年漫畫的宿命，因為主角要變強，所以一開始讓人絕望的反派角色，常常到中後期就會覺得強度像雜魚。但是強度崩壞，其實是個太常見以至於能夠被自然忽視的問題。就像霹靂布袋戲，除了幾個不死系的主角，每個在新章節登場的人物，常常都是能夠橫掃武林的傳說強者(白骨靈車、一葉知秋太黃君、武皇半尺劍、三途判…不勝枚舉)，到了章末又會變成一群雜魚都能追著打的弱角。</p><p>但是一個角色能不能引起共鳴，其實跟強度沒有直接的關係。譬如說自來也雖然在故事前期被稱為「傳說中的三忍」，從後期的忍界大戰來比較，很容易就能找到強過他的人，他就是標準的早期強者無法把強度撐到後期的案例。但是自來也這個角色的經典程度不需贅言，他會受歡迎不是因為他最強，而是他的人生故事講得很好。從一開始的強者前輩，接著成為傳授主角技術的職人，後來又是主角的人生導師，最後又付出生命確實完成了自己的使命。對恩師、舊友、戀人、敵人、愛徒、還有憨孫的互動，讓這個角色變得很豐滿。而且自來也一生的信念與情緒轉折，都讓人覺得合理而有共鳴，所以自來也豪傑的故事才會讓人那麼著迷。</p><p>看少年漫畫是在看故事，看故事是在看人跟人的情緒互動。要是中間「跳 tone」了，讀者就會出戲，就會覺得漫畫不合理。雖然 NARUTO 跟 BLEACH 都有強度崩壞的問題，但是 NARUTO 至少把其中幾個角色的故事講得完整，BLEACH 可說是沒有任何一個善終。</p><p>更何況 BLEACH 連戰鬥都寫壞了</p><h2 id="故事大綱"><a href="#故事大綱" class="headerlink" title="故事大綱"></a>故事大綱</h2><p>BLEACH 一共 74 集，用我印象比較深的故事劇情來排列，大概會是這樣</p><ul><li>代理死神篇<ul><li>故事開始，意外取得死神能力並活躍</li><li>介紹學校同學，豐富同學個性並提供舞台</li><li>持續解決案件，補足世界觀(虛)</li><li>埋下一護身世的伏筆</li></ul></li><li>屍魂界・潛入篇<ul><li>故事進入轉折，引入新的組織護廷十三隊</li><li>一護與同學跟浦原深交，各自開始提升能力</li><li>進入屍魂界外圍，補足屍魂界世界觀</li><li>以煙火的方式進入瀞靈廷</li></ul></li><li>屍魂界・救出篇<ul><li>各自與護廷十三隊戰鬥</li><li>藍染的陰謀浮上檯面</li><li>一護戰敗、增強能力</li><li>繼續護廷十三隊戰鬥，一護認識愈來愈多朋友</li><li>救出露琪雅，藍染大魔王正式登場</li></ul></li><li>破面・出現篇<ul><li>假面軍勢登場，護廷十三隊進入現世</li><li>破面痛擊護廷十三隊</li><li>一護鍛鍊虛化能力</li></ul></li><li>破面・虛圏救出篇<ul><li>破面再次痛擊護廷十三隊，同時井上被帶走</li><li>一護等人進入虛圈，往目標前進的同時收集夥伴與打倒敵人</li><li>一護被第 4 十刃烏爾奇奧拉擊敗</li><li>一護擊敗第 6 十刃葛力姆喬</li></ul></li><li>破面・VS.死神篇<ul><li>隊長群進入虛圈開始帥一波</li><li>藍染率領破面進攻假的空座町</li></ul></li><li>破面・空座決戰篇<ul><li>交代假面軍勢的過去</li><li>一護擊敗第 4 十刃烏爾奇奧拉</li><li>死神大戰破面</li></ul></li><li>破面・滅亡篇<ul><li>藍染輾壓眾人，融合崩玉</li><li>藍染進入真正的空座町</li><li>一護在斷界進行精神時光屋修行，擊敗藍染</li></ul></li><li>代理死神消失篇<ul><li>完現術者集團 XCUTION 登場</li><li>一護取回死神能力</li><li>死神完勝 XCUTION</li></ul></li><li>千年血戰篇<ul><li>無形帝國登場，攻佔虛圈並重創瀞靈廷</li><li>零番隊登場，一護身世解謎並提升能力</li><li>無形帝國毀滅瀞靈廷，擊敗零番隊攻下靈王宮</li><li>死神群進入被改造後的無形帝國，與最後的滅卻師交戰</li><li>一護等人擊敗友哈巴赫，故事完結</li></ul></li></ul><p>整個故事的起承轉合就是序章開始、打死神、打虛、打滅卻師，把人類以外的三界都打完一遍就完結了。屍魂界救出篇奠定了 BLEACH 的地位，至此 21 集的長度算是適中，所以也不少人認為 BLEACH 如果在屍魂界篇就結束，就是像鬼滅之刃那樣以高人氣的身份完結；就算拖到藍染大魔王打完的 48 集，雖然有點難堪，還能算是善終。可能是作者的意願，或是出版社的意志，總之 BLEACH 拖到了千年血戰篇，完全消耗掉所有人的耐性，以相當草率的方式收場。</p><h2 id="久保其實很能夠打造有趣的角色"><a href="#久保其實很能夠打造有趣的角色" class="headerlink" title="久保其實很能夠打造有趣的角色"></a>久保其實很能夠打造有趣的角色</h2><p>整個死神的世界觀相當龐大，如果一段一段地探討章節，在白哉第一次要把露琪亞抓回去以前，基本上故事圍繞在一護與他的親友身上。這時候的風格比較接近青春校園番，也是幽遊白書在戶愚呂出場前的風格。每個同學的性格鮮明，有相互吐槽的機會絕對不放過。魂大爺第一次出場，拿著一護的身體出風頭惡搞時，一護還很擔心地說：「這樣我的形象不就毀了」，魂心中的OS：『原來這傢伙還會經營形象啊….』</p><p>看似很帥很全能的一護，其實有點悶騷也會在意同學的眼光，同學的觀察結論也是，如果要模仿一護就要抓緊眉頭深鎖的特色。這時露琪亞的吐槽功力，再加上可愛插畫(及其衍生的被吐槽功力)，完全是表現搶眼又討喜的女主角。這個時期一護身邊每個人都能夠好好地演出，基本上沒有戲份不均的問題。</p><h2 id="人數膨脹之後開始出現問題"><a href="#人數膨脹之後開始出現問題" class="headerlink" title="人數膨脹之後開始出現問題"></a>人數膨脹之後開始出現問題</h2><p>久保在設定角色的部分相當用心，但是不看細節互動的話，其實人的個性大致上就只能分成幾十類，漫畫又沒那麼多篇幅去談每個人的細節，通常就是用更誇張的方式去表現性格，或說是「演得很用力」。人數愈多，個別角色就要演得愈用力才能在有限的篇章講完，情緒太多而沒有故事，這個情緒就乾掉了。這個問題特別容易發生在反派身上，所以可以看到很多根本能用歇斯底里來形容的反派。</p><p>同時久保捨不得毀掉精心做好的角色，於是開啟了很淒慘的輪迴</p><ol><li>設定出很好角色</li><li>為了要讓喜歡的角色表現，只好推出新的反派角色，反正新反派殺死不心疼</li><li>反派剛出現要有特色，但是篇幅不夠，只能用充滿精神病的方式表達反派性格，為了要表達反派的強度，所以要追加新的階級設定</li><li>因為是熱血漫畫要有危機感，所以反派與正方要不斷地拿出「我原本不想用這招的」壓箱寶，把對方打得半死</li></ol><p>我第一個有印象的，就是第一次要闖入瀞靈廷遇到的看門人，掛了一堆豪華的設定接著很快就被打爆。從此類似的角色及出場就不斷重複。久保創造了大量的免洗反派，用完就扔，這些精神有問題的反派存在的意義就是填充戰鬥場合。</p><p>雖然說少年漫畫總是要有源源不絕的反派，承太郎打迪奧也是不斷解決各種替身使者，小呆也是要一個個打下去才能接近巴恩大魔王，一步想當上拳王更是要逐場打下去。但是好看的少年漫畫，你也能找到印象深刻的反派。BLEACH 裡面是有些比較突出的反派，藍染就不用說了，銀或是葛力姆喬算是很有戲份的人</p><p>但問題是，為了要給一大群的隊長、副隊長，以及最後淪為一護快樂夥伴的同學們有表現的機會，久保創作太～多的免洗角色，完全稀釋了重要反派角色的存在感。十刃裡面除了烏爾奇奧拉與葛力姆喬還有哪些角色真正讓人有印象呢？星十字騎士團還設定了一堆「文字」，最後讀者又能記得幾個？又為了要增加「特色」，只好塞進一堆奇怪的個性。像最後幾個滅卻師，除了一個墨西哥風的摔角選手，還有個會不斷長大外型像雷神索的大塊頭，每次看到這幾個對手都有點尷尬。</p><p>在平均戲份跟表現性格上，目前為止我只有看過黑色五葉草做得比 BLEACH 差勁</p><h2 id="各式各樣的追加設定與修改"><a href="#各式各樣的追加設定與修改" class="headerlink" title="各式各樣的追加設定與修改"></a>各式各樣的追加設定與修改</h2><p>連載漫畫常常就一邊創作追加各種設定，畢竟漫畫一開頭誰也料不到會有多受歡迎，想不到能夠走多久。只是 BLEACH 在許多小細節上面不斷加入沒有脈絡的新東西，而新東西常常只用在問題發生的當下，事情過後就束之高閣，這樣的事情反覆出現使得整個結構變得更加鬆散。以道具來說，因應劇情當下的需要，經常就會突然拿出新道具。譬如說一護首次到雙亟的下方，被夜一帶到小時候跟浦原玩樂的地方，接著就拿出新道具，可以模仿某人來讓一護修煉。</p><p>道具的問題還算小，畢竟每個漫畫都有。但是「新招」的問題就大了。尤其是正派角色，在遇到困境之後就會演出：「我其實不想用這招的」，接著就是黑頁回想前一段時間，其實之前曾在某個不為人知的時候暗自修煉了新的招式，現在剛好可以拿出來用。這樣的敘事方式用個幾次還可以，但是在 BLEACH 已經被過度濫用。又譬如說日番谷隊長的卍解背後會有幾個花瓣，碎光了就是撐不下去強制解除卍解。結果到後面又遇到同樣危機的時候，全部花瓣碎光了反倒變更強，僅僅只是因為「日番谷變強了」之類的解釋</p><p>少年漫畫裡面，人物怎麼變強都可以，但是必須要有脈絡或是伏筆。譬如說悟空明明第一次只能慘勝達爾，但是到那美克星以前因為有 100 倍重力的訓練，就算戰鬥力飛躍到可以電爆基紐特戰隊，讀者也不會意外。如果在大戰前，能夠簡單地為這些轉折埋下伏筆，苦戰的時候跑出新招其實就是解謎，讀者通常都能接受。但是 BLEACH 的問題是缺乏脈絡的轉折太多，最後讓人覺得敘事缺乏邏輯。</p><p>「第0十刃」的出現也很尷尬。這傢伙最早出場然後被打爆，等到篇章的後期對上朽木跟劍八的時候，為了要成為配得上的對手，身上的數字突然從 10 消去一個數字而轉變成0，接著補了一句：「誰跟你說十刃是 1 ~ 10 的啊？」，不過這個透過數字代表最強實力的十刃，最後只是拖了一些沒意義的戲份就被結果了。這個 10 到 0 的變化，對於劇情的推進毫無影響，只能說又是一塊人氣角色的墊腳石。更何況十刃的數字一開始讓人以為是紋身，結果還可以透過某個不明的機制轉變數字，虛圈竟然有個全知全能的靈力測量系統？</p><p>虛圈也是很奇怪的設定。原本設定成死去的人變成的虛，最後面莫名其妙成為了像是另外一種生物圈，裡面還有悠久的階級與種類，還有個統帥虛圈卻覺得日子很無聊的人。屍魂界跟虛戰鬥了幾千年還不知道有這樣的角色？</p><p>滅卻師更奇怪。一開始解釋成一群擁有戰鬥力的人類，後來卻好像是另外一個人型種族，甚至有好一群人住在類似中古歐洲的村莊裡面，還能透過選拔挑出星十字騎士團。從這邊回頭看雨龍剛出場所說的「最後的滅卻師」感覺就像笑話一場。</p><p>有看過別人寫的文章，把靈王、滅卻師的各種關係串在一起。但我覺得從現實的創作過程與壓力，以及久保的敘事方式來看，太多深入的解釋只是把各種相關的線頭綁在一起，實際上久保只是現在需要什麼就臨時補什麼下去。</p><p>曾經我跟大多數人一樣，覺得虛圈或是千年血戰的部分是多出來的。後來看到別人說，其實久保只想畫千年血戰，反倒虛圈跟護廷十三隊是多出來的設定。後來想想還滿有道理的，如果把瀞靈廷、護廷十三隊、破面、虛圈全部砍掉。那個架構就會變得很單純，屍魂界其實只有創造各種基本規則的零番隊，以及為數不明的死神，剩下普通人被送過去的靈魂也不需要被刻意安排在遊民區，因為遊民區的設定也不需要了。虛圈更簡單，就維持著偶有強力大虛的野蠻世界就好。</p><p>那麼故事就能簡化成，曾經被滅亡的人類滅卻師一族復活後向死神復仇，撼動整個世界的平衡，一個兼有死神與虛的力量的特例人類，站在人類的對立面去守護世界，感覺起來還滿平衡的劇情。不過 BLEACH 已經完結，究竟事情是不是這樣？現在也不可能驗證了</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我根本沒想到會囉唆地打這麽多字！</p><p>雖然批評了一大堆，但是只論破面篇之前的話，其實我還是相當享受這部漫畫。在此之後的部分，撇開絕大多數的戰鬥場景，日常番的部分我也還是看得滿開心。尤其每一話之間的扉頁或是吐槽，久保還是畫得非常棒，吐槽也很夠味。</p><p>就算 BLEACH 結束得草率，我想至少還是比獵人負責任吧 :P</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;漫畫&lt;a href=&quot;https://zh.wikipedia.org/wiki/BLEACH&quot;&gt;BLEACH 死神&lt;/a&gt; 是從 2001 年我高中時期就開始連載的漫畫，一直到 2016 年出了完結篇，此時我不但已經工作好多年，連小孩都已經出生了。這部漫畫最輝煌的時候，也橫跨了我的整個青少年時期，最後差不多以相當難堪的結局收場，不免唏噓。稍微紀錄一下心得，也當作是給模糊的青春記憶加個分號&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="acg" scheme="https://jchu.cc/tags/acg/"/>
    
    <category term="comic" scheme="https://jchu.cc/tags/comic/"/>
    
  </entry>
  
  <entry>
    <title>神奈川縣更新日本駕照</title>
    <link href="https://jchu.cc/2021/05/24-license.html"/>
    <id>https://jchu.cc/2021/05/24-license.html</id>
    <published>2021-05-24T13:29:24.000Z</published>
    <updated>2021-05-24T14:09:07.012Z</updated>
    
    <content type="html"><![CDATA[<p>時光匆匆，上一次<a href="/2019/05/29-license.html">更換日本駕照</a>之後，一下就過了兩年，到了第一次更新駕照的時間。比起第一次的更換駕照，更新的過程相對簡單而且有效率</p><a id="more"></a><p>駕照到期的日子是該年生日的前後一個月，所以在生日的一個月之前就會收到通知書。通知書上會清楚地寫下更新期間，講習的課程種類與價格</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_1.jpg"></div><p>因為我是初次更換，所以一定要到運転免許センター去更新駕照。雖然要跑一趟，但是當天就能拿到駕照，不需另外準備照片，講習的課程也很多，算起來也沒什麼不好。</p><h1 id="準備物品"><a href="#準備物品" class="headerlink" title="準備物品"></a>準備物品</h1><p>住在神奈川縣的鄉親可以參考<a href="https://www.police.pref.kanagawa.jp/mes/mes83002.htm" target="_blank" rel="noopener">運転免許証の更新手続について</a>，需要準備帶去的東西有</p><ul><li>正在使用，快要過期的駕照(運転免許証)</li><li>更新連絡書 (就是上圖那張)</li><li>在留カード</li><li>初次更新的人需要 3850 日圓</li><li><span style="color: grey"><del>運転免許証更新申請書</del>(如果去センター就不需要此項)</span></li><li><span style="color: grey"><del>申請用写真</del>(如果去センター就不需要此項)</span></li></ul><h1 id="跑大地遊戲"><a href="#跑大地遊戲" class="headerlink" title="跑大地遊戲"></a>跑大地遊戲</h1><p>我是大約平日早上八點多快九點才到中心，大門口進去看到人山人海在排隊的地方就是大地遊戲的起點。基本上照著牆上的數字跑完每個關卡就行了。</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_2.jpg"></div><p>第一關就準備好你的<strong>駕照</strong>與<strong>更新通知書</strong>開始登記，登記完之後會要求你輸入兩組四位數字的密碼，印出一張帶有 Bar code 的熱感應紙，後面拍完照就是交出這張紙來設定密碼。</p><p>過了第一關會拿到兩張紙，一張是密碼紙(登録カード)，另外一張更新講習申請書，接著拿申請書去繳費，證明你是優良用路人</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_3.jpg"></div><br><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_4.jpg"></div><p>拿到好寶寶貼紙之後，就像上圖將貼紙貼上去。填完幾個基本資料，別忘記背面還有幾個良心測驗要填。而且要看一下旁邊寫的大字：「請不要彎折這張申請書」</p><p>沒記錯的話，接著就是要檢查視力確認你沒有瞎掉，有戴隱形眼鏡的人記得跟考官說「コンタクトレンズ(contact lens)」對方就會懂了。接著說出上(うえ)下(した)左(ひだり)右(みぎ)證明眼睛功能正常即可。</p><p>之後是查驗證件，查驗完會請你到旁邊的另外一區等待唱名，我猜這時候正在幫你分配講習的場次。唱完名就會拿到單子(有點忘記順序了)，我當時是四號教室。接著就去拍駕照用的囚犯照，再到教室等上課就好</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_5.jpg"></div><h1 id="講習"><a href="#講習" class="headerlink" title="講習"></a>講習</h1><p>講習的過程會要求你把閒書收起來專心聽課，其實看完影片聽一些課程再加上休息時間，大概一小時四十分鐘就結束了，實際感受比想像中快。除了中間要自我評量一下看看你是不是個喪心病狂的駕駛？除此之外都沒有任何問答，所以像我這樣的日文苦手也不用擔心</p><p>講習的內容都是講很快的日文，說真的我都聽不懂，不過靠漢字跟基本文法，用看的也能懂個八成。一開始是 25 分鐘的影片，給你看看常見的車禍案例，以及因為車禍變成植物人的家庭是怎麼過生活。影片的核心就是</p><p><strong>當你握了方向盤，你就有責任</strong></p><p>接著開始講要怎麼在路上安全駕駛。譬如說什麼情況可能會有不長眼的腳踏車從你旁邊鑽過去，什麼情況可能會有小屁孩衝到馬路上，什麼情況可能會有白目老人橫斷馬路。</p><p>怎麼講來講去都是別人犯錯卻是駕駛要注意？</p><p>我覺得這就是日本的倡導的駕駛觀念。發生車禍時，責任歸屬是一回事，但是誰會受傷又是另外一回事。到後半段講師又再強調了一次，握了方向盤，你就有責任。一次車禍可能就是一個家庭的一生不幸。</p><p>對於從小在車流逆境中長大的台灣人，應該很難理解吧。雖然聽課前覺得很花時間，但是實際聽完之後我覺得這樣的課程很好。哪怕是僅僅降低百分之一的車禍率，就是減少很多心碎的家庭。</p><p>聽完課程之後就是按照生日的尾數日期依次領證，結束今天的任務。第一次更新駕照，大概花了三個小時左右。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;時光匆匆，上一次&lt;a href=&quot;/2019/05/29-license.html&quot;&gt;更換日本駕照&lt;/a&gt;之後，一下就過了兩年，到了第一次更新駕照的時間。比起第一次的更換駕照，更新的過程相對簡單而且有效率&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
  </entry>
  
  <entry>
    <title>第 10 屆修憲委員會待審議案列表</title>
    <link href="https://jchu.cc/2021/03/06-constitution.html"/>
    <id>https://jchu.cc/2021/03/06-constitution.html</id>
    <published>2021-03-05T16:23:24.000Z</published>
    <updated>2021-03-07T16:46:08.037Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    .kmt:before {        content:"▉";        color: blue;    }    .dpp:before {        content:"▉";        color: green;    }    .npp:before {        content:"▉";        color: gold;    }    .tpp:before {        content:"▉";        color: turquoise;    }    .sbp:before {        content:"▉";        color: brown;    }    .none:before {        content:"▉";        color: gray;    }    article p {        margin-top: 2.3rem;        margin-bottom: 0px;    }    blockquote > p {        margin: 0px;        font-size: 1.1rem;    }    .content h1 {        margin-top: 3rem;    }    .content h2 {        color: black;    }</style><p>修憲一直是我很關心的議題，前幾天看到了<a href="https://www.ly.gov.tw/Pages/Detail.aspx?nodeid=44173&amp;pid=202974" target="_blank" rel="noopener">立法院第10屆修憲委員會待審議案一覽表</a>，就找了一下各委員的修憲提案，整理在這裡。</p><a id="more"></a><p>談到憲法，很多人第一個反應就是想到統獨。的確，憲法是國家主權的展現，裡面一定會涉及到領土的問題。但是憲法的範圍遠遠不止於此，還有許多與內政相關的東西。好比行政院長與各部會首長的產生方式就由憲法的<a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=56" target="_blank" rel="noopener">第 56 條</a>決定(當然就影響到怎麼拚經濟賺錢)；憲法也決定了我國的價值觀，經過釋憲促成的同婚之路就是一個例子。</p><p>簡單地說，憲法決定了我們國家的政府該怎麼運作。</p><p>所以憲法也必須隨著社會變遷而做出更動，才能夠因應新發生的問題，推動國家順利地往前進。</p><p>只是很不幸在 2004 年的第七次修憲，我國的修憲門檻被拉得非常高，自此之後修憲幾乎被視為近乎不可能的任務。修憲的門檻有多高呢？我國立法委員總數為 113 席，即需要 85 位出席，出席者之中要有 64 位同意。這屆的國會黨派組成為</p><ul><li><span class="dpp">民進黨: 61 席</span></li><li><span class="kmt">國民黨: 38 席</span></li><li><span class="tpp">台灣民眾黨: 5 席</span></li><li><span class="npp">時代力量: 3 席</span></li><li><span class="sbp">基進黨 1 席</span></li><li><span class="none">無黨籍: 5 (傅崐萁 林昶佐 趙正宇 高金素梅 蘇震清-剛退出民進黨)</span></li></ul><p>即使所有非國民黨的立委加起來也不過 75 席，換句話說，只要國民黨與民進黨沒有取得共識，就不可能達成修憲，這是第一個門檻。第二個門檻是全民公投，即使修憲案達成共識出了國會，還需要公告半年之後再公投，取得選舉人總額之半數的同意票，<a href="選舉人總額之半數">以風傳媒的計算</a>來看，需要 <strong>967</strong> 萬人同意，也高過蔡總統連任獲得的史上最高 <strong>871</strong> 萬票。</p><p>這次修憲共識最高的是 <strong>18 歲公民權</strong>，除此之外的修憲提案目前感覺起來也是各吹各的調。希望在修憲委員會裡面，各黨能夠以務實的態度尋求共識，消弭黨派之間的成見，推動國家前進。 <strong>同時也希望台灣的民眾，能夠給予修憲委員會多一點關注與壓力</strong></p><ul><li><a href="https://www.thenewslens.com/article/140487" target="_blank" rel="noopener">The News Lens: 睽違15年立法院將成立修憲委員會，各黨提出哪些憲改議題？</a></li><li><a href="https://www.thenewslens.com/article/147369" target="_blank" rel="noopener">The News Lens: 立法院修憲啟動倒數，除了共識最高的「18歲公民權」還有哪些提案？</a></li></ul><p>根據待審議案的表格，我在立法院的<a href="https://lis.ly.gov.tw/lylgmeetc/lgmeetkm" target="_blank" rel="noopener">議事系統</a>找出了對應的議員提案，對修憲有興趣的人，可以去看看到底委員們提了什麼案子，想要如何修憲；也根據提案人、連署人的黨派標上顏色。有幾個提案同時放了兩個不同方向的內容，所以會重複出現。如果標題分類得不好請見諒，如果有更好的建議，歡迎<a href="https://twitter.com/walkingice" target="_blank" rel="noopener">在 Twitter 告訴我</a>。</p><h1 id="參政年齡"><a href="#參政年齡" class="headerlink" title="參政年齡"></a>參政年齡</h1><h2 id="投票年齡下修"><a href="#投票年齡下修" class="headerlink" title="投票年齡下修"></a>投票年齡下修</h2><p>提案建議下修擁有選舉權的年齡。幾乎各黨都有人提出，所以有高度共識，極有可能成案。</p><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=130" target="_blank" rel="noopener">中華民國憲法第 130 條</a><br>中華民國國民年滿二十歲者，有依法選舉之權，除本憲法及法律別有規定者外，年滿二十三歲者，有依法被選舉之權。</p></blockquote><ul><li><span class="kmt">國民黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100106:LCEWA01_100106_00044" target="_blank" rel="noopener">江啟臣</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00046" target="_blank" rel="noopener">林為洲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100112:LCEWA01_100112_00052" target="_blank" rel="noopener">蔣萬安</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00007" target="_blank" rel="noopener">林奕華</a></li><li><span class="dpp">民進黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00020" target="_blank" rel="noopener">蘇巧慧</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00035" target="_blank" rel="noopener">范雲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100108:LCEWA01_100108_00213" target="_blank" rel="noopener">陳亭妃</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100109:LCEWA01_100109_00052" target="_blank" rel="noopener">高嘉瑜</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100111:LCEWA01_100111_00093" target="_blank" rel="noopener">賴瑞隆</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10190" target="_blank" rel="noopener">洪申翰</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:LCEWA01_100203_00005" target="_blank" rel="noopener">王定宇</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00132" target="_blank" rel="noopener">林俊憲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00107" target="_blank" rel="noopener">鍾佳濱</a></li><li><span class="npp">時代力量：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100211:LCEWA01_100211_00019" target="_blank" rel="noopener">邱顯智</a></li><li><span class="tpp">民眾黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10173" target="_blank" rel="noopener">張其祿</a></li></ul><h2 id="總統副總統參選年齡調降"><a href="#總統副總統參選年齡調降" class="headerlink" title="總統副總統參選年齡調降"></a>總統副總統參選年齡調降</h2><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10183" target="_blank" rel="noopener">院總第1607號 委員提案第25125號</a><ul><li>委員蘇巧慧等38人擬具中華民國憲法增修條文第二條條文修正草案（參政年齡-總統副總統參選年齡調降）</li><li>提案與連署：<span class="dpp"><span class="sbp"></span></span></li></ul></li></ul><h1 id="政府體制"><a href="#政府體制" class="headerlink" title="政府體制"></a>政府體制</h1><h2 id="恢復閣揆同意權"><a href="#恢復閣揆同意權" class="headerlink" title="恢復閣揆同意權"></a>恢復閣揆同意權</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=3" target="_blank" rel="noopener">中華民國憲法增修條文第 3 條</a><br>行政院院長由總統任命之…. 行政院依左列規定，對立法院負責</p></blockquote><p>這是相當重大的改變，但也不是第一次被提出。目前為止我國的運作方式是總統直接決定行政院長，不需國會同意，但是行政院的施政都需要經過國會同意，或接受國會監督。如果總統與國會多數黨為同一政黨，問題會比較小；但若朝小野大，則有可能讓總統直接任命的行政院長不被國會信任，形成政治僵局。若國會擁有閣揆同意權，則能降低這類政治衝突。但朝小野大時亦可能發生總統提名的行政院長總是無法通過反對黨的同意，形成政治僵局。此外，閣揆同意權實際上會削弱同樣獲得民意基礎的總統的權力，所以這是很大的憲政改變，需要非常多的考量，更多的細節請尋找有足夠憲法知識的其他前輩的文章，這部分我不敢妄言。(不過，實際上應該不會通過修憲委員會吧 XD)</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:10136" target="_blank" rel="noopener">院總第1607號 委員提案第24968號</a><ul><li>委員賴士葆等30人擬具中華民國憲法增修條文第三條條文修正草案（政府體制-恢復閣揆同意權、修正覆議案及不信任案之規定）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h2 id="立委任期調整"><a href="#立委任期調整" class="headerlink" title="立委任期調整"></a>立委任期調整</h2><p>總統與立委雖然是同一天選舉，但是一月如果選出不同執政黨的總統，要到 520 就職才能行駛職權，就是偶爾會聽見的「憲政空窗期」，針對這點難得藍綠都有提案。</p><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00039" target="_blank" rel="noopener">院總第1607號 委員提案第24949號</a></p><ul><li>委員林德福等29人擬具中華民國憲法增修條文第二條及第四條條文修正草案（制度改革-總統及立委任期調整、立法院會期調整、國情報告常態化）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00038" target="_blank" rel="noopener">院總第1607號 委員提案第25909號</a></p><ul><li>委員郭國文等37人擬具中華民國憲法增修條文第二條、第三條及第四條條文修正草案（制度改革-刪除總統解散立法院之權、總統及立委任期調整、立法院會期調整等）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h2 id="確立總統制政體"><a href="#確立總統制政體" class="headerlink" title="確立總統制政體"></a>確立總統制政體</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=53" target="_blank" rel="noopener">中華民國憲法第 53 條</a><br>行政院為國家最高行政機關。</p></blockquote><p>我國的憲政實務為，總統主管外交國防，行政院長主管內政，但是行政院長由總統直接指派(通常視為執行總統意志)，但是行政院長要到立法院備詢，而總統不需要。所以總統會不會管到內政？目前是由總統個人意志或是政治現實決定。</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:10349" target="_blank" rel="noopener">院總第1607號 委員提案第25241號</a><ul><li>委員林為洲等30人擬具中華民國憲法增修條文第二條及第三條條文修正草案（政府體制-總統制）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="修憲門檻"><a href="#修憲門檻" class="headerlink" title="修憲門檻"></a>修憲門檻</h1><h2 id="下修修憲門檻"><a href="#下修修憲門檻" class="headerlink" title="下修修憲門檻"></a>下修修憲門檻</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=12" target="_blank" rel="noopener">中華民國憲法增修條文第 12 條</a><br>憲法之修改，須經立法院立法委員四分之一之提議，四分之三之出席，及出席委員四分之三之決議，提出憲法修正案，並於公告半年後，經中華民國自由地區選舉人投票複決，有效同意票過選舉人總額之半數，即通過之，不適用憲法第一百七十四條之規定。</p></blockquote><p>我個人私心覺得這是我最在意的修憲案，但也是通過的希望渺茫。</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00057" target="_blank" rel="noopener">院總第1607號 委員提案第25369號</a><ul><li>委員林昶佐等32人擬具中華民國憲法增修條文第十二條條文修正草案（修憲門檻-降低修憲門檻）</li><li>提案與連署：<span class="none"><span class="dpp"></span></span></li></ul></li></ul><h1 id="權力分立"><a href="#權力分立" class="headerlink" title="權力分立"></a>權力分立</h1><h2 id="廢止考試院、監察院及其職權移轉"><a href="#廢止考試院、監察院及其職權移轉" class="headerlink" title="廢止考試院、監察院及其職權移轉"></a>廢止考試院、監察院及其職權移轉</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=6" target="_blank" rel="noopener">中華民國憲法增修條文第 6 條</a><br> 考試院為國家最高考試機關….<br><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=7" target="_blank" rel="noopener">中華民國憲法增修條文第 7 條</a><br> 監察院為國家最高監察機關，行使彈劾、糾舉及審計權….</p></blockquote><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100108:LCEWA01_100108_00215" target="_blank" rel="noopener">院總第1607號 委員提案第24329號</a></p><ul><li>委員陳亭妃等29人擬具中華民國憲法增修條文部分條文修正草案(第3、4、6、7條)（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉</li><li>提案與連署：<span class="dpp"><span class="none"></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100115:LCEWA01_100115_00052" target="_blank" rel="noopener">院總第1607號 委員提案第24867號</a></p><ul><li>委員吳思瑤等30人擬具中華民國憲法增修條文第四條之一、第六條及第七條條文修正草案（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:LCEWA01_100203_00005" target="_blank" rel="noopener">院總第1607號 委員提案第25024號</a></p><ul><li>委員王定宇等32人擬具中華民國憲法增修條文部分條文修正草案(第4、6、7、11條)（1.權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉</li><li>提案與連署：<span class="dpp"><span class="none"><span class="sbp"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00182" target="_blank" rel="noopener">院總第1607號 委員提案第25414號</a></p><ul><li>委員鍾佳濱等32人擬具中華民國憲法增修條文第三條及第六條條文修正草案（權力分立-廢止考試院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100207:LCEWA01_100207_00018" target="_blank" rel="noopener">院總第1607號 委員提案第25637號</a></p><ul><li>委員范雲等33人擬具中華民國憲法增修條文部分條文修正草案(第3-1、4-1、4-2、4-3、6、7、7-1、7-2條)（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h1 id="國會職權"><a href="#國會職權" class="headerlink" title="國會職權"></a>國會職權</h1><h2 id="立法院聽證調查權入憲"><a href="#立法院聽證調查權入憲" class="headerlink" title="立法院聽證調查權入憲"></a>立法院聽證調查權入憲</h2><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00133" target="_blank" rel="noopener">院總第1607號 委員提案第25243號</a><ul><li>委員林俊憲等30人擬具中華民國憲法增修條文增訂第四條之一條文草案（國會職權-立法院聽證調查權入憲）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h2 id="提高立法院對司法院、考試院及監察院人事同意權門檻"><a href="#提高立法院對司法院、考試院及監察院人事同意權門檻" class="headerlink" title="提高立法院對司法院、考試院及監察院人事同意權門檻"></a>提高立法院對司法院、考試院及監察院人事同意權門檻</h2><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00045" target="_blank" rel="noopener">院總第1607號 委員提案第24963號</a></p><ul><li>委員曾銘宗等31人擬具中華民國憲法增修條文第五條、第六條及第七條條文修正草案（國會職權-提高立法院對司法院、考試院及監察院人事同意權門檻）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:10350" target="_blank" rel="noopener">院總第1607號 委員提案第25154號</a></p><ul><li>委員吳怡玎等29人擬具中華民國憲法增修條文部分條文修正草案(第5、6、7、10條) （1.國會職權-提高立法院對司法院、考試院及監察院人事同意權門檻。2.基本國策-保障幼兒接受教育之基本權）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h2 id="國情報告常態化"><a href="#國情報告常態化" class="headerlink" title="國情報告常態化"></a>國情報告常態化</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=4" target="_blank" rel="noopener">中華民國憲法增修條文第 4 條</a><br>立法院於每年集會時，得聽取總統國情報告。</p></blockquote><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:10137" target="_blank" rel="noopener">院總第1607號 委員提案第24969號</a><ul><li>委員賴士葆等30人擬具中華民國憲法增修條文第四條條文修正草案（制度改革-國情報告常態化）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="基本國策"><a href="#基本國策" class="headerlink" title="基本國策"></a>基本國策</h1><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00040" target="_blank" rel="noopener">院總第1607號 委員提案第24950號</a></p><ul><li>委員林德福等29人擬具中華民國憲法增修條文第十條條文修正草案（基本國策-寬列青年發展經費）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10141" target="_blank" rel="noopener">院總第1607號 委員提案第25094號</a></p><ul><li>委員鄭麗文等29人擬具中華民國憲法增修條文增訂第十三條條文草案（基本國策-保障人民數位權）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10142" target="_blank" rel="noopener">院總第1607號 委員提案第25095號</a></p><ul><li>委員鄭麗文等30人擬具中華民國憲法增修條文增訂第十四條條文草案（基本國策-保障人民享有安全、健康與環境永續的氣候環境）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10143" target="_blank" rel="noopener">院總第1607號 委員提案第25096號</a></p><ul><li>委員鄭麗文等29人擬具中華民國憲法增修條文增訂第十五條條文草案（基本國策-保障生物多樣性、重視動物保護等）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:LCEWA01_100204_00017" target="_blank" rel="noopener">院總第1607號 委員提案第25307號</a></p><ul><li>委員陳柏惟等32人擬具中華民國憲法增修條文增訂第十條之一條文草案（基本國策-落實轉型正義）</li><li>提案與連署：<span class="sbp"><span class="dpp"><span class="npp"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00219" target="_blank" rel="noopener">院總第1607號 委員提案第25350號</a></p><ul><li>委員曾銘宗等32人擬具中華民國憲法增修條文增訂第十三條條文草案（基本國策-落實財政紀律）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100209:LCEWA01_100209_00081" target="_blank" rel="noopener">院總第1607號 委員提案第25851號</a></p><ul><li>委員蔡壁如等33人擬具中華民國憲法增修條文增訂第十條之一條文草案。（基本國策-重視動物保護等）</li><li>提案與連署：<span class="tpp"><span class="dpp"><span class="kmt"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00006" target="_blank" rel="noopener">院總第1607號 委員提案第25880號</a></p><ul><li>委員林奕華等31人擬具中華民國憲法增修條文第十條條文修正草案（基本國策-動物保護入憲）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="總統誓詞"><a href="#總統誓詞" class="headerlink" title="總統誓詞"></a>總統誓詞</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10156" target="_blank" rel="noopener">院總第1607號 委員提案第25143號</a><ul><li>委員江啟臣等31人擬具中華民國憲法增修條文增訂第二條之一條文草案（總統誓詞-修正總統就職宣誓誓詞）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="人性尊嚴"><a href="#人性尊嚴" class="headerlink" title="人性尊嚴"></a>人性尊嚴</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100111:LCEWA01_100111_00029" target="_blank" rel="noopener">院總第1607號 委員提案第24516號</a><ul><li>委員林昶佐等35人擬具中華民國憲法增修條文增訂第一條之一、第一條之二及第一條之三條文草案（人權保障-人性尊嚴等項）</li><li>提案與連署：<span class="none"><span class="dpp"><span class="npp"><span class="sbp"></span></span></span></span></li></ul></li></ul><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100207:LCEWA01_100207_00019" target="_blank" rel="noopener">院總第1607號 委員提案第25638號</a><ul><li>委員范雲等34人擬具中華民國憲法增修條文增訂部分條文草案(第1-1、1-2、1-3、1-4條)（人權保障-人性尊嚴等項）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h1 id="制度改革"><a href="#制度改革" class="headerlink" title="制度改革"></a>制度改革</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00078" target="_blank" rel="noopener">院總第1607號 委員提案第25410號</a><ul><li>委員伍麗華等39人擬具中華民國憲法增修條文第四條條文修正草案（制度改革-刪除平地山地原住民分類）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><p>最後讓我多碎嘴幾句。修憲真的很困難，各黨之間要是失去信任，修憲幾乎可以視為破局。不管你的立場站在哪一方，盡量都多忍忍，不要口出惡言或醜化對方陣營。我甚至覺得，只要能夠下修修憲門檻就已經是萬幸，我國的憲法就有再次改造的機會，否則未來也想不到還有什麼類似 18 歲投票權的議題，能夠提供足夠的修憲能量。如果憲政制度不能往前走，現有的政府制度遇到挑戰，只能疊床架屋繞過問題，效率低落的苦果還是全民承擔。</p><p>也希望能看到更多憲法專家的精闢討論與意見</p>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    .kmt:before {
        content:&quot;▉&quot;;
        color: blue;
    }
    .dpp:before {
        content:&quot;▉&quot;;
        color: green;
    }
    .npp:before {
        content:&quot;▉&quot;;
        color: gold;
    }
    .tpp:before {
        content:&quot;▉&quot;;
        color: turquoise;
    }
    .sbp:before {
        content:&quot;▉&quot;;
        color: brown;
    }
    .none:before {
        content:&quot;▉&quot;;
        color: gray;
    }

    article p {
        margin-top: 2.3rem;
        margin-bottom: 0px;
    }

    blockquote &gt; p {
        margin: 0px;
        font-size: 1.1rem;
    }

    .content h1 {
        margin-top: 3rem;
    }

    .content h2 {
        color: black;
    }

&lt;/style&gt;

&lt;p&gt;修憲一直是我很關心的議題，前幾天看到了&lt;a href=&quot;https://www.ly.gov.tw/Pages/Detail.aspx?nodeid=44173&amp;amp;pid=202974&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;立法院第10屆修憲委員會待審議案一覽表&lt;/a&gt;，就找了一下各委員的修憲提案，整理在這裡。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>使用 Mayflash 把舊搖桿接上 Nintendo Switch</title>
    <link href="https://jchu.cc/2021/03/04-mayflash.html"/>
    <id>https://jchu.cc/2021/03/04-mayflash.html</id>
    <published>2021-03-03T17:18:59.000Z</published>
    <updated>2021-03-03T16:36:46.775Z</updated>
    
    <content type="html"><![CDATA[<p>結論：利用 Mayflash Magic S-Pro，可以用 Logitech F310 玩 Nintendo Switch</p><a id="more"></a><div style="margin: auto;"><img src="/2021/03/04-mayflash/f310.jpg"></div><p>Joy Con 的飄移問題讓人詬病已久，在家玩 Switch 的時候早就已經遇到這個問題。雖然還在保固內可以送修，但是未來用久了還是會再次遇到這個問題。突然想到我有專門用來玩 PC game 的 Logitech F710 跟 F310，不是很昂貴的搖桿，用起來還算順手，如果能夠拿來玩 Switch 就太好了。</p><p>稍微搜尋一下，只要買某幾支 USB Dongle 接上去就可以玩，於是選了<a href="https://www.mayflash.com/Products/NINTENDOWiiU/MAGIC-S%20PRO.html" target="_blank" rel="noopener">Mayflasy Magic S-Pro</a>，只比 Magic-NS 多上一點價格，如果哪天有 PS4 也可以用。</p><p>剛拿到 Dongle 接上 Switch 卻怎麼也連不上搖桿，試了一下就知道要認真看看官網上面的說明：要進入 Switch 的設定畫面 / Controller and Sensors / 打開 Pro Controller Wired Communication，接著 Switch 就會把外接的搖桿當成 Nintendo Switch Pro Controller 連接了</p><p>玩一些 FC/SFC 的老遊戲，尤其是動作類的遊戲，還是傳統有線搖桿比較順手</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;結論：利用 Mayflash Magic S-Pro，可以用 Logitech F310 玩 Nintendo Switch&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>離線閱讀 Android Doc</title>
    <link href="https://jchu.cc/2020/12/10-android-doc.html"/>
    <id>https://jchu.cc/2020/12/10-android-doc.html</id>
    <published>2020-12-10T13:53:39.000Z</published>
    <updated>2021-03-03T16:18:26.852Z</updated>
    
    <content type="html"><![CDATA[<p>寫 Android 的程式總是要時時閱讀本草綱目(API documentation)，才會確定應該呼叫哪個 API，就我所知某些人的做法是在 Android Studio 裡面直接看程式碼，不過我還是比較喜歡看精美的 HTML 檔案</p><p>雖然很多人是看 online 的版本，不過我從大學時期養成的習慣，還是比較喜歡下載一份 offline 的版本，自己開瀏覽器閱讀。只是這件事情在 Android 上面愈來愈難做到了…</p><a id="more"></a><p>JAVA JDK 的文件一直都能<a href="https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html" target="_blank" rel="noopener">直接下載</a>，但是 Android 我還沒看到這樣的東西，幾年前我還會從 source code 自己 <a href="http://0xwalkingice.blogspot.com/2010/03/javadoc-at-android.html" target="_blank" rel="noopener">make doc</a>，隨著 AOSP 愈來愈癡肥，我也懶得自己生出 javadoc。</p><p>在 Android SDK Manager 裡面，可以直接下載 doc。很遺憾地，最近已經無法下載。在 stackoverflow 上頭有人說 <a href="https://stackoverflow.com/a/49262913" target="_blank" rel="noopener">已經不再提供下載</a>，也只能無奈地接受這個很 Google 的現況。</p><p>還好網路上還找得到一些 for Zeal 的 offline doc 可以直接下載，湊合著用尚且過得去，哪天受不了了再自己生出一份 doc 吧。Zeal/Dash 都很好，但我不是很喜歡再額外開個 app 來讀文件，如果能在瀏覽器裡面就搞定，我會盡量待在瀏覽器裡頭。</p><p>Android doc 雖然很長一段時間可以直接下載，但是有個搜尋的功能在 Android 7 之後在 offline 版本就壞掉了，使得我其實停留在 Android 6 doc 很久，真的需要查詢新的文件我才會開線上版本。</p><p>按下 <code>Command + /</code> 之後就能快速搜尋出某一個類別。</p><div style="max-width: 100%; margin: auto;"><img src="/2020/12/10-android-doc/search_official.gif"></div><p>不過線上版的這個搜尋功能做得很爛，總是先顯示一堆 Guide，殊不知真的來看文件的人，其實要看的是類別的說明，而不是 Guide。</p><p>前兩天突然想通，其實要做個簡易版本也不是很難。就先準備好每個頁面的連結與關鍵字的資料，頁面讀完的時候塞個 dom，輸入文字的時候去資料裡面查一下就好</p><p>就快速地花一個晚上寫了兩個小小的 script</p><ul><li><a href="/2020/12/10-android-doc/parser.pl" title="parser.pl">parser.pl</a> - 很簡單的 perl script，搜尋出目錄底下的 html 檔，parse 之後吐到 stdout。所以把輸出的文字 pipe 到一個 js 檔就好</li><li><a href="/2020/12/10-android-doc/loader.js_" title="loader.js_">loader.js_</a> - 這個 js 檔會在頁面塞進一個 input DOM，並且拿前述的資料來用</li><li>恰好 Android offline doc 的每一頁都會讀進固定的 js 檔，所以把前面兩個 js 檔塞到必讀的 js 檔的最尾端就好了</li></ul><p>跑起來像這樣</p><div style="max-width: 100%; margin: auto;"><img src="/2020/12/10-android-doc/search_mine.gif"></div><p>其實還可以寫成 browser extension。不過仔細想想，也不知道多少人會有類似的需求，搞不好只有我會用這麼彆扭的方式開發，所以現在花一個晚上隨便弄弄會動就好，不要花太多力氣在這上面(聳肩)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫 Android 的程式總是要時時閱讀本草綱目(API documentation)，才會確定應該呼叫哪個 API，就我所知某些人的做法是在 Android Studio 裡面直接看程式碼，不過我還是比較喜歡看精美的 HTML 檔案&lt;/p&gt;
&lt;p&gt;雖然很多人是看 online 的版本，不過我從大學時期養成的習慣，還是比較喜歡下載一份 offline 的版本，自己開瀏覽器閱讀。只是這件事情在 Android 上面愈來愈難做到了…&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
</feed>
