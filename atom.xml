<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只放拖鞋的鞋櫃</title>
  
  <subtitle>程式中的迷途小書僮</subtitle>
  <link href="https://jchu.cc/atom.xml" rel="self"/>
  
  <link href="https://jchu.cc/"/>
  <updated>2022-04-01T16:46:25.178Z</updated>
  <id>https://jchu.cc/</id>
  
  <author>
    <name>Walkingice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlinx-coroutines-test migrate to 1.6 紀錄</title>
    <link href="https://jchu.cc/2022/03/30-coroutine-migration.html"/>
    <id>https://jchu.cc/2022/03/30-coroutine-migration.html</id>
    <published>2022-03-30T13:07:18.000Z</published>
    <updated>2022-04-01T16:46:25.178Z</updated>
    
    <content type="html"><![CDATA[<p>之前因為工作的需要，把 kotlin 從 <code>1.5.2</code> 升級到 <code>1.6.0</code>，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。</p><span id="more"></span><p>kotlin 升級到 1.6.0 的時候，有把許多元件標為 <code>Deprecated</code>。這在一般的小專案裡面不是什麼大問題，但我的公司有很多部門都會把程式送到同一個 repository 裡面，當然許多人都有寫 unit test 的習慣，而且我們也有打開 <strong>-Werror(Warning as Error)</strong> 的選項。於是必須在一個 PR 裡面，升級 coroutine 版本的同時，就把上百個 unit test 類別裡面的過時寫法一口氣更新。</p><p>這種改測試的任務，配分到各個跨國團隊底下，很容易大家就因為各自的時程壓力而搞到永遠作不完。跟同事討論之後，決定我跳下去動手改。除了改程式碼的苦工之外，還要跟不同的團隊合作避免把測試改壞，同時要保持 commit 的清晰才容易解決 merge conflict，追上最新的開發版。來來回回搞了一個月，終於送出一個增減超過五千行的巨大 PR，算是最近工作比較難忘的一件事。</p><p>這過程中也看到各種不同的使用 coroutine 的實作與單元測試寫法，我盡量把我記得的東西寫下來。</p><h1 id="關於升級-kotlinx-coroutine-1-6"><a href="#關於升級-kotlinx-coroutine-1-6" class="headerlink" title="關於升級 kotlinx coroutine 1.6"></a>關於升級 kotlinx coroutine 1.6</h1><p>首先要看官方的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md">Migration Guide</a>，列了不少步驟以及細節。說實在我也是來來回回看了好多遍，才搞懂大部分的意思。需要作 migration 的人可以認真看一下，一方面也是搞懂如何用比較簡潔的方式寫 coroutine unit test</p><p>大致上有幾個重點，在寫 unit test 的時候</p><ol><li>不要用 <code>runBlocking</code> 或是 <code>runBlockingTest</code>，改用 <code>runTest</code></li><li>不要用 <code>TestCoroutineScope</code>，改用 <code>TestScope</code></li><li>不要用 <code>TestCoroutineDispatcher</code>，改用 <code>StandardTestDispatcher</code></li><li>如果實作同時用到其他非同步的工具，好比 RxJava，可以試 <code>UnconfinedTestDispatcher</code> 看看有無奇效</li><li>必要的時候用 <code>runCurrent</code> 確保 pending 的 coroutine 有跑完</li><li>用到 <code>ViewModel.viewModelScope</code> 的話，用 <code>Dispatchers.setMain</code> 把 dispatcher 塞進去</li><li>實作要是有用到 <code>delay</code>，可以用 <code>advanceTimeBy</code> 來控制時間進度</li></ol><p>掌握上面的幾個重點，應該就能處理絕大多數的測試。</p><h1 id="好處：使用一致的風格撰寫-coroutine-的測試"><a href="#好處：使用一致的風格撰寫-coroutine-的測試" class="headerlink" title="好處：使用一致的風格撰寫 coroutine 的測試"></a>好處：使用一致的風格撰寫 coroutine 的測試</h1><p>升級到 <code>1.6.0</code> 之後，我覺得寫 unit test 有比較簡潔一點，而且我把絕大多數的測試包進 <code>runTest</code> 之後，也不需要依賴 Mockito 提供的一些為了測試 coroutine 而增加的工具。整體來說能夠用比較一致的風格來寫單元測試，對於大團隊算是好事。</p><p>寫 coroutine unit test 的主要精神就是，產生一個 <code>TestDispatcher</code>，然後透過這個 <code>TestDispatcher</code> 生出 <code>TestScope</code>，然後注入這些測試專用的 Dispatcher 或是 Scope 到實作的程式裡面。因為這些測試用的物件提供了我們上下其手的空間，所以我們就能預期被測試的實作會如何被執行，以此來進行單元測試。</p><p>Coroutine 的測試最後大概都能寫成這樣，以下是我覺得不錯的風格。(當然一個測試檔案只應該測試一個對象，我一次塞進 <code>foo</code>, <code>bar</code>, <code>foobar</code>, <code>foobarViewModel</code> 只是為了節省空間)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.test.assertEquals</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.ExperimentalCoroutinesApi</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.StandardTestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runCurrent</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runTest</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.setMain</span><br><span class="line"><span class="keyword">import</span> org.junit.Before</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith</span><br><span class="line"><span class="keyword">import</span> org.robolectric.RobolectricTestRunner</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="meta">@RunWith(RobolectricTestRunner::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope) <span class="comment">// inject Scope to implementation Foo</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher) <span class="comment">// inject Dispatcher to implementation Bar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = foo.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = bar.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        foobar.suspendableFunc()</span><br><span class="line"></span><br><span class="line">        runCurrent() <span class="comment">// ensure foobar completed its job</span></span><br><span class="line">        assertEquals(<span class="number">5987</span>, foobar.fetchedResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從上方的範例可以看到</p><ol><li>我用 <code>StandardTestDispatcher</code> 產生一個 <code>TestDispatcher</code></li><li>並且用 <code>TestDispatcher</code> 產生一個 <code>TestScope</code></li><li>這些 Dispatcher 跟 Scope 被注入進 <code>Foo</code>, <code>Bar</code>…等</li></ol><p>接著列出一些常見的例子，解釋該怎麼寫測試比較好。<strong>注意：下方範例裡面的類別，即使同名，介面可能跟上面完全不同，請不要訝異上面下面對不起來。</strong></p><h1 id="如何測試-suspend-function"><a href="#如何測試-suspend-function" class="headerlink" title="如何測試 suspend function"></a>如何測試 suspend function</h1><p>測試一個單純的 <code>suspend</code> function 最簡單了，因為我們可以直接掛在 testScope 底下執行該 function，過程輕鬆簡單</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentValue = fetchRemoteWithDelay(currentValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemoteWithDelay</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar()</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, bar.currentValue)</span><br><span class="line">    bar.suspendableFetch()</span><br><span class="line">    assertEquals(<span class="number">1</span>, bar.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runTest</code> 會產生一個 <code>TestScope</code>，所以在它的 block 裡面，我們可以直接執行 <code>suspend</code> function 而不用擔心太多。</p><h1 id="以注入的-Scope-來執行-suspend-function-的程式，該如何測試"><a href="#以注入的-Scope-來執行-suspend-function-的程式，該如何測試" class="headerlink" title="以注入的 Scope 來執行 suspend function 的程式，該如何測試"></a>以注入的 Scope 來執行 suspend function 的程式，該如何測試</h1><p>以下的範例有個看起來很普通的函式 <code>asyncRead</code>，其實裡面會透過注入的 coroutine scope 執行 suspend function。<code>asyncRead</code> 會直接返回，但我們又想要測試 <code>currentValue</code> 是否有按照預期地被更動</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            currentValue = fetchRemote(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的例子來說，<code>asyncRead</code> 是一個在任何地方都可以呼叫的普通函式，射後不理的特徵讓我們不知道該怎麼測試。但是它是掛在注入的 <code>injectedScope</code> 下來執行，其實很好解決。既然已經注入了 scope，那麼只要在 assert 之前確保 scope 把該做的事情都做完就好。要確保這件事情，就是出動 <code>runCurrent</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.runCurrent()</span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外還有其他寫法，譬如說底下的作法也會通</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;  <span class="comment">// 指定了 dispatcher</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    runCurrent()  <span class="comment">// 不需指定 scope</span></span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要看懂上面這個寫法，就要先弄懂 <code>runTest</code> 做了什麼事。<code>runTest</code> 可以接受一個 CoroutineContext，用它生出一個新的 TestScope。而 <code>runCurrent</code> 雖然是 <code>TestScope</code> 的 extension，實際上拿 <code>TestScope</code> 裡面的 scheduler 來用。因為我們把 <code>testDispatcher</code> 塞給了 <code>runTest</code>，同時又把跟 <code>testDispatcher</code> 綁在一起的 <code>testScope</code> 注入進去 <code>foo</code>。所以 <code>runCurrent()</code> 用的 scheduler 是同一個。</p><p>結論就像下方的 pseudo code 演示的概念</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Just Psuedo Code **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theScheduler = testDispatcher.testScheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(theScheduler) &#123; theScheduler -&gt;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    theScheduler.runCurrent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以什麼時候會用 <code>runTest(testDispatcher)</code> 呢？<strong>想要確保 <code>runTest() &#123;....&#125;</code> 的 block 裡面是用哪個 scheduler 的時候</strong>。(另外也能寫成 <code>testScop.runTest &#123;...&#125;</code>，但我覺得寫 coroutine 的單元測試，控制流程進度應該從 Dispatcher 切入，而非 Scope，所以我都會避免這樣的寫法)</p><h1 id="ViewModel-如何測試"><a href="#ViewModel-如何測試" class="headerlink" title="ViewModel 如何測試"></a>ViewModel 如何測試</h1><p><strong>androidx.lifecycle.lifecycle-viewmodel-ktx</strong> 提供了一個 extension <code>ViewModel.viewModelScope</code>，讓你在 ViewModel 裡面可以莫名其妙就拿到一個 Coroutine Scope 來用。其實實作很簡單，就是拿 <code>Dispatchers.Main</code> 來生出一個 scope 而已。所以在寫單元測試的時候，只要把 Main Dispatcher 換成我們自己的 TestDispatcher 就搞定了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBarViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            updateValue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">()</span></span> = withContext(viewModelScope.coroutineContext) &#123;</span><br><span class="line">        currentValue = <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoobarViewModel</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        foobarViewModel.testFunc()</span><br><span class="line"></span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        runCurrent()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, foobarViewModel.currentValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果跳進去看實作，就會看到 <code>StandardTestDispatcher</code> 跟 <code>UnconfinedTestDispatcher</code> 在建立的時候，如果沒有指定 Scheduler，就會拿同一個 Scheduler 來用，而且是同一個。而且執行 <code>Dispatcher.setMain</code> 的時候把這個 Dispatchers 指定給 Main，<code>TestSceop</code> 也說建購的時期如果沒有指定 Dispatcher，也會拿 Main Dispatcher 來用。所以到最後，這幾個背後都是同一個 Scheduler，也因此 <code>runCurrent</code> 幾乎是隨便亂用都會動(嘖嘖)。</p><h1 id="StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪"><a href="#StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪" class="headerlink" title="StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪"></a>StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪</h1><p>官方 Guide 會看到這句話</p><blockquote><p>In these cases, UnconfinedTestDispatcher() should be used. We ensured that, when run with an UnconfinedTestDispatcher, runTest also eagerly enters launch and async blocks.</p></blockquote><p>當一個 coroutine 由 <code>UnconfinedTestDispatcher</code> 所啟動 (launch)，它會積極地在 caller 的 thread 執行。也就是說當你用這個 Dispatcher 跑起了一個 coroutine，它裡面又產生了一個 coroutine，那麼 <code>UnconfinedTestDispatcher</code> 會盡量去執行這個新的 coroutine。舉例來說</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foobar</span></span>(injectedDispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(injectedDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine A</span></span><br><span class="line">            funA()</span><br><span class="line">        &#125;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funB()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcA&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine C</span></span><br><span class="line">           funC()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcA&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcB&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funcD()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcB&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funC</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;running funcC&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funcD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;running funcD&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printMsg</code> 會產生兩個 coroutine，一個跑 <code>funA</code>，一個跑 <code>funB</code>。<code>funA</code> 執行的時候會 launch 一個 coroutine 來跑 <code>funC</code>，<code>funB</code> 也會 launch 一個 coroutine 來跑 <code>funD</code></p><p>用 <code>StandardTestDispatcher</code> 的測試程式如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    assert(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>如果把依序把 <code>funA</code> 產生的 coroutine 稱為 <code>coroutine A</code>，那麼執行的順序就是</p><ol><li>coroutine A</li><li>coroutine B</li><li>coroutine C</li><li>coroutine D</li></ol><p>接著改用 <code>UnconfinedTestDispatcher</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = UnconfinedTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>執行順序變成</p><ol><li>coroutine A</li><li>coroutine C</li><li>coroutine B</li><li>coroutine D</li></ol><p>A 排在 B 前面，而 A 裡面產生的 C 被 Dispatcher 積極執行，所以插隊在 B 前面，這就是 Guide 裡面說的 Eagerly</p><p>如果你的實作混用了其他 library 的非同步功能(ie: Rx)，有時候用 <code>UnconfinedTestDispatcher</code> 可以讓程式的執行順序跑得比較像一般函式呼叫的順序。但是長久來說，還是避免一堆工具混在一起作牛丸，盡量用單一工具來做非同步比較好。</p><h1 id="何時使用-advanceTimeBy"><a href="#何時使用-advanceTimeBy" class="headerlink" title="何時使用 advanceTimeBy"></a>何時使用 advanceTimeBy</h1><p>有時候會用到 <code>delay</code> 或是其他函式對一個 coroutine 的執行時間作調整</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            delay(<span class="number">2000</span>) <span class="comment">// 白金之星！...好吧，它是 delay 而非暫停時間</span></span><br><span class="line">            currentValue = <span class="number">9527</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>advanceTimeBy</code> 可以把 dispatcher 裡面的虛擬時鐘調快，就像老闆的替身能力克里姆王的那樣刪除一段時間</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(-<span class="number">1</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.advanceTimeBy(<span class="number">3000</span>) <span class="comment">// 老闆能力發動！</span></span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Troubleshooting-用到兩個-TestDispatcher-會出錯"><a href="#Troubleshooting-用到兩個-TestDispatcher-會出錯" class="headerlink" title="Troubleshooting: 用到兩個 TestDispatcher 會出錯"></a>Troubleshooting: 用到兩個 TestDispatcher 會出錯</h1><p>有時候會看到這個錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br><span class="line">java.lang.IllegalStateException: Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br></pre></td></tr></table></figure><p>那是因為不小心產生了兩個 TestDispatcher，好比以下這段程式，使用 <code>withContext</code> 的時候經常發生這個錯誤。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>(<span class="keyword">val</span> dispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFunc</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(dispatcher)&#123; <span class="comment">// 這裡用注入的 Dispatcher</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123; <span class="comment">// runTest 自己產生一個 Dispatcher，接著再以此生出 TestScope</span></span><br><span class="line">        bar.suspendableFunc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bar.suspendableFunc()</code> 會用注入的 Dispathcer，<code>runTest</code> 如果不指定一個 <code>TestDispatcher</code>，它內部實作也會產生一個新的。</p><p>讓兩邊都用同一個 TestDispatcher 就可以解決問題。下面就是讓 runTest 使用同一個 Dispatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">    bar.suspendableFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果有個函式用到-withContext-Dispatcher-IO-，該如何測試"><a href="#如果有個函式用到-withContext-Dispatcher-IO-，該如何測試" class="headerlink" title="如果有個函式用到 withContext(Dispatcher.IO)，該如何測試"></a>如果有個函式用到 withContext(Dispatcher.IO)，該如何測試</h2><p>有時候我們會看到以下這樣的作法。<code>fetchRemote</code> 是個跑在 <code>Dispatcher.IO</code> 上面的耗時函數，外部呼叫 <code>asyncRead</code> 之後就可以射後不理，等到 <code>returnValue</code> 更新了，再去更新 UI</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> returnedValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            returnedValue = fetchRemote()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要測試 <code>asyncRead</code> 就會變得很麻煩，雖然已經注入了一個 <code>injectedScope</code>，但是在 <code>fetchRemote</code> 跑在我們測試程式碼裡面完全碰不到的 <code>Dispatchers.IO</code>。</p><p>有個滿噁心的寫法：利用 <code>withContext</code> 來測試。</p><p><code>withContext</code> 會拿當下的 coroutine context 跟透過參數指定進去的 context，兩個 merge 起來產生新的 context，接著用新的 context 裡面的 coroutine scope 執行 block 裡面的程式，直到該 scope 完成之後才離開 block。所以單元測試只要拿 <code>withContext</code> 產生的 scop 注入進去測試對象就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    <span class="keyword">var</span> localFoo: Foo</span><br><span class="line">    withContext(testDispatcher) &#123;</span><br><span class="line">        localFoo = Foo(<span class="keyword">this</span>) <span class="comment">// `this` is a coroutineScope that created by withContext</span></span><br><span class="line">        localFoo.asyncRead()</span><br><span class="line">        assertEquals(<span class="number">0</span>, localFoo.returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line">    assertEquals(<span class="number">9527</span>, localFoo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我覺得測試寫成這樣太過取巧，很可能遭天譴或是被人恥笑。有辦法修改的話，還是把類別改寫得比較容易測試才是正途。譬如說”inject Dispatcher” + “default value”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope: CoroutineScope,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ioDispatcher: CoroutineDispatcher = Dispatchers.IO</span><br><span class="line">) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(ioDispatcher) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scope, dispatcher, 球員，裁判都是我的，測試就會變得很好寫</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope, testDispatcher)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.returnedValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line"></span><br><span class="line">    runCurrent()</span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>寫 coroutine 的單元測試，主要是要先搞懂當下在用的是哪個 Scope 或 Dispatcher，釐清它執行的順序，接著就是確保在 assert 之前把該做的事情做完。既然談到執行順序，又回到大家早就知道的概念，實作的時候要適當地注入 Dispatcher，這樣測試才會好寫。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前因為工作的需要，把 kotlin 從 &lt;code&gt;1.5.2&lt;/code&gt; 升級到 &lt;code&gt;1.6.0&lt;/code&gt;，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>紀錄三讀通過交通處罰條例</title>
    <link href="https://jchu.cc/2021/12/10-ly.html"/>
    <id>https://jchu.cc/2021/12/10-ly.html</id>
    <published>2021-12-10T13:32:34.000Z</published>
    <updated>2021-12-10T14:48:04.034Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    ol li {        line-height: 1.3rem;    }    .del {        background-color: #FCC;    }    .add {        background-color: #CFC;    }</style><p>今天看到<strong>道路交通管理處罰條例第七條之二條文修正草案</strong>三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下</p><span id="more"></span><h1 id="三讀通過的條文"><a href="#三讀通過的條文" class="headerlink" title="三讀通過的條文"></a>三讀通過的條文</h1><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100412:LCEWA01_100412_00092">立法院第 10 屆第 4 會期第 12 次會議議案關係文書</a> (備份檔： <a href="/2021/12/10-ly/final.pdf" title="final.pdf">final.pdf</a> )</p><p>法條修改的部份如下</p><p><strong>現行條文</strong></p><blockquote><p>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p></blockquote><p><strong>通過條文</strong></p><blockquote><p>第七條之一 民眾對於下列違反本條例之行為者，得敘明違規事實並檢具違規證據資料，向公路主管或警察機關檢舉：<br>(…..略….)<br>公路主管機關或警察機關對於第一項之檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。民眾依第一項規定檢舉同一輛汽車二以上違反本條例同一規定之行為，其違規時間相隔未逾六分鐘及行駛未經過一個路口以上，公路主管或警察機關以舉發一次為限。公路主管或警察機關對第一項檢舉之逕行舉發，依本條例第七條之二第五項規定辦理。</p></blockquote><p>主要的變化是，原本民眾可以針對道路交通管理處罰條例的違規事項做檢舉，現在變成只有正面表列的違規事項才能檢舉。「略」裏面放了一長串的條文 reference，指出哪些違規事項是民眾可以檢舉的，底下列出各個被參考條文的大意</p><ol><li><p>第三十條第一項第二款。</p><ul><li>汽車裝載時，有下列情形之一者…所載貨物滲漏、飛散、脫落、掉落或氣味惡臭。</li></ul></li><li><p>第三十一條第六項或第三十一條之一第一項至第三項。</p><ul><li>機車駕駛人或附載座人未依規定戴安全帽者，處駕駛人新臺幣五百元罰鍰。</li><li>汽車駕駛人於行駛道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣三千元罰鍰。</li><li>機車駕駛人行駛於道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣一千元罰鍰。</li><li>汽機車駕駛人行駛於道路，手持香菸、吸食、點燃香菸致有影響他人行車安全之行為者，處新臺幣六百元罰鍰。</li></ul></li><li><p>第三十三條第一項第二款、第三款、第四款、第七款、第九款、第十一款至第十六款、第四項或第九十二條第七項。</p><ul><li>汽車行駛於高速公路、快速公路或設站管制之道路…有下列行為者…<ul><li>未保持安全距離</li><li>未依規定行駛車道</li><li>未依規定變換車道</li><li>違規超車、迴車、倒車、逆向行駛</li><li>未依規定使用路肩</li><li>裝置貨物未依規定覆蓋、捆紮。</li><li>未依標誌、標線、號誌指示行車。</li><li>進入或行駛禁止通行之路段。</li><li>連續密集按鳴喇叭、變換燈光或其他方式迫使前車讓道。</li><li>行駛中向車外丟棄物品或廢棄物。</li><li>車輪、輪胎膠皮或車輛機件脫落</li></ul></li><li>不得行駛或進入第一項道路之人員、車輛或動力機械，而行駛或進入者</li><li>汽缸排氣量五百五十立方公分以上之大型重型機車行駛高速公路，有下列行為者…..</li></ul></li><li><p>第四十二條。</p><ul><li>汽車駕駛人，不依規定使用燈光者</li></ul></li><li><p>第四十三條第一項第一款、第三款、第四款或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者…道路上蛇行，或以其他危險方式駕車</li></ul></li><li><p>第四十四條第二項或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者<ul><li>行近未設行車管制號誌之行人穿越道，不減速慢行</li><li>行經設有彎道、坡路、狹路、狹橋或隧道標誌之路段或道路施工路段，不減速慢行</li></ul></li></ul></li><li><p>第四十五條第一項第一款、第三款、第四款、第六款、第十三款、第十六款或第二項。</p><ul><li>汽車駕駛人，爭道行駛有下列情形之一者….<ul><li>不按遵行之方向行駛</li><li>不依規定駛入來車道</li><li>在多車道不依規定駕車</li><li>駕車行駛人行道</li><li>機車不在規定車道行駛</li><li>佔用自行車專用道</li></ul></li><li>聞消防車、救護車、警備車、工程救險車、毒性化學物質災害事故應變車之警號，不立即避讓者</li></ul></li><li><p>第四十七條。</p><ul><li>汽車駕駛人超車時，有下列情形之一者…..注：各種危險超車</li></ul></li><li><p>第四十八條第一項第二款、第四款、第五款或第七款。</p><ul><li>汽車駕駛人轉彎或變換車道時，有下列情形之一者….不依標誌、標線、號誌指示</li></ul></li><li><p>第四十九條。</p><ul><li>汽車駕駛人迴車時，有下列情形之一者…注：各種危險迴轉</li></ul></li><li><p>第五十三條或第五十三條之一。</p><ul><li>汽車駕駛人，行經有燈光號誌管制之交岔路口闖紅燈者，及前項紅燈右轉行為者</li><li>車駕駛人，行經有燈光號誌管制之大眾捷運系統車輛共用通行交岔路口闖紅燈者，及前項紅燈右轉行為者</li></ul></li><li><p>第五十四條。</p><ul><li>汽車駕駛人，駕車在鐵路平交道有下列情形之一者….注：各種平交道危險事項</li></ul></li><li><p><code>第五十五條第一項第二款或第四款併排臨時停車。</code></p></li><li><p><code>在第五十五條第一項第二款規定禁止臨時停車之處所停車。</code></p></li><li><p><code>第五十六條第一項第十款及第二項。</code></p></li><li><p>第六十條第二項第三款</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一，而本章各條無處罰之規定者….注：各種不遵守指揮的行為</li></ul></li></ol><p>上面可以看到列了一大堆東西，其實都是一般人不太會去檢舉的事項，我們最關心的就是違規停車。也就是第 13, 14, 15 個項目提及的東西。第五十五條跟第五十六條裡面，我們還剩下哪些能檢舉呢？</p><p>塗上紅色的，就是民眾在修法過後，不能檢舉的事項</p><p>第 55 條</span></p><ol><li><span class="del">汽車駕駛人，臨時停車有下列情形之一者，處新臺幣三百元以上六百元以下罰鍰：</span><ul><li><span class="del">一、在橋樑、隧道、圓環、障礙物對面、人行道、行人穿越道、快車道臨時停車。</span></li><li><span class="add">二、在交岔路口、公共汽車招呼站十公尺內或消防車出、入口五公尺內臨時停車。</span></li><li><span class="del">三、在設有禁止臨時停車標誌、標線處所臨時停車。</span></li><li><span class="add">四、不依順行之方向，或不緊靠道路右側，或單行道不緊靠路邊，或併排臨時停車。</span></li><li><span class="del">五、在道路交通標誌前臨時停車，遮蔽標誌。</span></li></ul></li><li><span class="del">接送未滿七歲之兒童、行動不便之人上、下車者，臨時停車不受三分鐘之限制。</span></li></ol><p>第 56 條</p><ol><li><span class="del">汽車駕駛人停車時，有下列情形之一者，處新臺幣六百元以上一千二百元以下罰鍰：</span><ul><li><span class="del">一、在禁止臨時停車處所停車。</span></li><li><span class="del">二、在設有彎道、險坡、狹路標誌之路段、槽化線、交通島或道路修理地段停車。</span></li><li><span class="del">三、在機場、車站、碼頭、學校、娛樂、展覽、競技、市場、或其他公共場所出、入口或消防栓之前停車。</span></li><li><span class="del">四、在設有禁止停車標誌、標線之處所停車。</span></li><li><span class="del">五、在顯有妨礙其他人、車通行處所停車。</span></li><li><span class="del">六、不依順行方向，或不緊靠道路右側，或單行道不緊靠路邊停車。</span></li><li><span class="del">七、於路邊劃有停放車輛線之處所停車營業。</span></li><li><span class="del">八、自用汽車在營業汽車招呼站停車。</span></li><li><span class="del">九、停車時間、位置、方式、車種不依規定。</span></li><li><span class="add">十、於身心障礙專用停車位違規停車。</span></li></ul></li><li><span class="add">汽車駕駛人停車時，有併排停車之情事者，處汽車駕駛人新臺幣二千四百元罰鍰。</span></li><li><span class="del">汽車駕駛人在道路收費停車處所停車，依規定繳費，主管機關應書面通知駕駛人於七日內補繳，並收取必要之工本費用，逾期再不繳納，處新臺幣三百元罰鍰。</span></li><li><span class="del">第一項及第二項情形，交通勤務警察、依法令執行交通稽查任務人員或交通助理人員，應責令汽車駕駛人將車移置適當處所；如汽車駕駛人不予移置或不在車內時，得由該交通勤務警察、依法令執行交通稽查任務人員或交通助理人員為之。</span></li><li><span class="del">第一項第十款應以最高額處罰之，第三項之欠費追繳之。</span></li><li><span class="del">在圓環、交岔路口十公尺內，公路主管機關、市區道路主管機關或警察機關得在不妨害行人通行或行車安全無虞之原則，設置必要之標誌或標線另行規定汽車之停車處所。</span></li></ol><h1 id="委員提案"><a href="#委員提案" class="headerlink" title="委員提案"></a>委員提案</h1><p>看完了三讀通過的法案，再看一下立委的原始提案。</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100114:LCEWA01_100114_00063">院總第 756 號 委員提案第 24811 號</a> (備份檔： <a href="/2021/12/10-ly/24811.pdf" title="24811.pdf">24811.pdf</a> )</p><p>提案人：陳歐珀<br>連署人：莊競程 陳亭妃 賴惠員 賴品妤 莊瑞雄 林楚茵 吳玉琴 楊 曜 黃國書 黃秀芳 王美惠 邱泰源 劉世芳 陳明文 洪申翰 何欣純 林宜瑾 范雲</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/24811.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="del">應即舉發</span>。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="add">先給予勸導，若同一違規事實再犯者，即予舉發</span>。但行為終了日起逾七日之檢舉，不予舉發</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100202:LCEWA01_100202_00068aa">院總第 756 號 委員提案第 25053 號</a> (備份檔： <a href="/2021/12/10-ly/25053.pdf" title="25053.pdf">25053.pdf</a> )</p><p>提案人：鄭正鈐<br>連署人：陳玉珍 翁重鈞 鄭天財 Sra Kacaw 張育美 謝衣鳯 李貴敏 李德維 吳怡玎 陳以信 呂玉玲 廖婉汝 魯明哲 陳雪生 洪孟楷 林文瑞 徐志榮 葉毓蘭 林德福 孔文卲 林思銘 吳斯懷 溫玉霞 蔣萬安</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/25053.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">對於不影響交通安全之違規檢舉案件，應先開立勸導單，其類型由主管機關定之。</span></p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100306:LCEWA01_100306_00015">院總第 756 號 委員提案第 26098 號</a> (備份檔： <a href="/2021/12/10-ly/26098.pdf" title="26098.pdf">26098.pdf</a> )</p><p>提案人：林俊憲 林宜瑾<br>連署人：陳歐珀 羅美玲 蘇巧慧 陳明文 趙天麟 邱議瑩 陳素月 賴惠員 劉建國 周春米 蔡易餘 蘇治芬 邱志偉 劉櫂豪</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/26098.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">兩件違規舉發事項之時間需相隔六分鐘以上或行駛經過一個路口以上。</span></p><h1 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h1><p>我是相當在意交通環境的人，長期以來對於台灣的交通一直都是非常失望。好不容易近幾年來大家開始知道要尊重行人路權，知道要減少違規停車，交通安全意識要開始進步的時候，立委修法限縮了這個人民對付交通惡霸的武器。</p><p>不管修法的方向是什麼，總是要有個冠冕堂皇的理由。今天立委們刻意放大「惡意檢舉」的案例來強化自己修法的正當性，而避談無獎金的踴躍檢舉，是因為民眾對糟糕的交通環境累積的長期不滿，現在立委的修法討好了喜歡貪便宜的人，犧牲的是乖乖遵守交通規則的人</p><p>修法的提案人，有國民黨的鄭正鈐，也有民進黨的陳歐珀，林俊憲，林宜瑾。為了討好民眾，甘願犧牲台灣長久利益的這種作為，藍綠沒什麼差別。</p><p>我不談道德，只談利益。遵守規則往往也要付出成本，如果不能讓迴避規則的人承受更大的壓力，要怎麼說服多數的人去遵守交通規則呢？</p><p>今天立委這樣的修法，正是告訴人民：違規停車只要沒被警察看到，就沒關係。如果你會為了交通安全，乖乖地花錢把車停到停車場，再花三十分鐘來回只為買個便當？那是你笨，不懂得精打細算省錢省時間</p><p>我當這種笨蛋很多年了，今天我真是深深覺得自己笨得可以</p><p>立委都開綠燈了，台灣的交通安全？你要學著當聰明用路人啊！</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://www.youtube.com/watch?v=3pRnMH1iqrA"> 羅火花 - 縮限檢舉來啦！大違規時代人行道紅線爽違停！我教你怎樣減少違規停車啦立委們！</a></li><li><a href="https://www.thenewslens.com/article/135482">要消滅檢舉達人，形象清新的賴品妤為何成為「羅淑蕾第二」？</a></li><li><a href="https://www.thenewslens.com/article/132505">這天新竹碾死一個機車騎士，真正的兇手是充滿人情味的「微罪不罰」</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    ol li {
        line-height: 1.3rem;
    }
    .del {
        background-color: #FCC;
    }
    .add {
        background-color: #CFC;
    }

&lt;/style&gt;

&lt;p&gt;今天看到&lt;strong&gt;道路交通管理處罰條例第七條之二條文修正草案&lt;/strong&gt;三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
    <category term="government" scheme="https://jchu.cc/tags/government/"/>
    
  </entry>
  
  <entry>
    <title>ActivityPub 簡單介紹</title>
    <link href="https://jchu.cc/2021/07/27-activitypub.html"/>
    <id>https://jchu.cc/2021/07/27-activitypub.html</id>
    <published>2021-07-27T12:43:59.000Z</published>
    <updated>2021-07-27T14:57:33.752Z</updated>
    
    <content type="html"><![CDATA[<p><a href="devpoga.org">Poga</a> 架了 <a href="https://g0v.social/">g0v.social</a> 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。</p><p>不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。</p><span id="more"></span><p>Mastodon 是一個類似 Twitter 的 Microblog service application，比起 Twitter 這樣的集中式服務，Mastodon 讓你對自己帳號的掌控權「更多一點」。</p><p>Mastodon 稱自己為去中心化、聯邦式(Federation)的程式。</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_federation.svg" class=""></div><p>Twitter 是集中式(Centralized)的服務，我們都很清楚 Centralized 的運作方式：要連上一個別人管理的網站，在上面註冊帳號、與其他帳號互動。</p><p>Git 就是我們習慣的分散式(Distributed)工具，在 Git 的使用情境裡，任何人都可以弄個 repository 成為別人的 upstream，彼此之間地位相等，隨時可以增加或減少網絡裡的節點。</p><p>Federation 則是介於兩者中間。基本上我們還是要連上某個別人架設好的伺服器；當然你要自己 host 一個也可以。各個服務器之間透過一個公認的規則(ActivityPub)交換訊息，或是透過某種潛規則排擠某一個伺服器。</p><p>於是乎，我就有了三個問題</p><ol><li>如果我的帳號在 Server A，而我的朋友十分鐘前剛剛自己架了一個 Server B，我有辦法 follow 他在新伺服器的帳號嗎？<ul><li>簡答：基本上可以，但有可能不行</li></ul></li><li>當我寫了一個新的 Post，我的 100 個 follower(來自 20 個不同 servers) 該怎麼知道我的新貼文？<ul><li>簡答：由 Server to Server federation protocol 處理</li></ul></li><li>既然沒有一個專屬的機構負責當真理部，該如何避免 spam 或是仇恨言論？<ul><li>簡答：潛規則的政治手段解決</li></ul></li></ol><p>查詢相關的 Spec，一定會看到三個 W3C spec: Activity Vocabulary, ActivityStream 與 ActivityPub</p><p>其實我覺得這三份文件，比起 RFC 都寫得滿籠統，定義會在三者之間相互指涉，看到後面都不懂某個名詞的確切意義是什麼，可能是我看 W3C 規格的功力不夠，這三份又特別有彈性。</p><p>我盡可能列出我對這三份文件的理解。以我的淺薄理解，很明顯對於實作沒有太大的幫助，可能要看過 Mastodon 的程式碼的人比較能回答細節的問題。</p><h3 id="Activity-Vocabulary"><a href="#Activity-Vocabulary" class="headerlink" title="Activity Vocabulary"></a>Activity Vocabulary</h3><blockquote><p>It is intended to be used in the context of the ActivityStreams 2.0 format and provides a foundational vocabulary for activity structures, and specific activity types.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-vocabulary/">Activity Vocabulary</a></li></ul><p>這一份文件為 ActivityStream 會用到的字彙給出更細微的定義，定義每個 Type 或是 property 的意義。這裡面定義了三個 Core types <code>Object</code> <code>Link</code> and <code>Activity</code>。他們之間以及子類別的關係大致如下</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_activity_vocabulary.svg" class=""></div><p>雖然 Activity Vocabulary 只定義了一些類別，但是開發者可以添加更多的延伸類別(由 Activity Stream 定義)。</p><p>一個基本的 Activity 看起來像這樣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@context&quot;</span>: <span class="string">&quot;https://www.w3.org/ns/activitystreams&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Activity&quot;</span>,</span><br><span class="line">  <span class="string">&quot;summary&quot;</span>: <span class="string">&quot;Sally did something to a note&quot;</span>,</span><br><span class="line">  <span class="string">&quot;actor&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sally&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Note&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;A Note&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity Vocabulary 文件試著解釋每個 property 的用處為何。在閱讀 spec 的時候看到 <code>Domain</code> 指的是這個 property 可以被用在哪個 type 上面。<code>Range</code> 則是說這個 property 可以塞進哪些值</p><h3 id="Activity-Stream"><a href="#Activity-Stream" class="headerlink" title="Activity Stream"></a>Activity Stream</h3><blockquote><p>This specification details a model for representing potential and completed activities using the JSON format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-core/">ActivityStream</a></li></ul><p>以 JSON 的格式，拿 Activity Vocabulary 定義好的 properties, type 來組合使用，呈現「活動」(actities)，換句話說，這份文件定義了，Activity Vocabulary 定義好的東西，該怎麼拿來用，才能呈現一個事件(Activity)</p><p>這個 Spec 對大多數的 Object 僅僅只有定義不完備的語意，所以可以在 Activity Vocabulary 之外延伸定義更多的細節，也能定義新的 Object type。但是如果仰賴太多延伸定義的類型，那麼 Server 之間會不能溝通</p><h3 id="ActivityPub"><a href="#ActivityPub" class="headerlink" title="ActivityPub"></a>ActivityPub</h3><blockquote><p>The ActivityPub protocol is a decentralized social networking protocol based upon the ActivityStreams 2.0 data format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitypub/">ActivityPub</a></li></ul><p>以 ActivityStream 為基礎，定義出去中心化的社交網路協定分成兩部分</p><ul><li>Server to server federation protocol</li><li>Client to server protocol</li></ul><p>這份 Spec 裡面介紹了什麼是 Actor 以及幾個常見的 Activity</p><p>我們所創立的帳號就是 Actor (有沒有其他 Actor 我不確定)。一個 Actor 必須要有這些欄位</p><ul><li>inbox (OrderedCollection)</li><li>outbox (OrderedCollection)</li><li>following</li><li>followers<ul><li>記錄這個 Actor 有多少 follower。以後新增 Activity 的時候會通知這些 follower</li><li>實作上可以設定 filter 讓 authenticated user 有更高的優先權</li></ul></li><li>liked</li><li>streams</li><li>……</li></ul><p>Activity 就是 Actor 在平台上產生的活動，包括但不限於送訊息、追蹤別人、發貼文等等</p><p>Spec 裡面舉例了訊息該怎麼傳遞，畫成圖就是下面的樣子。每個帳號(Actor)都會有一個 INBOX 與 OUTBOX，送出訊息的話，先是把訊息透過 Client-to-Server-protocol 寫進自己的 OUTBOX，接著再由 Server-to-Server-federation-protol 把訊息送到對方的 INBOX。對方上線後去看自己的 INBOX 就能讀到訊息</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_send_message.svg" class=""></div><p>從上面的訊息傳遞，可以看到一個重點：</p><p><strong>Server 之間的訊息傳遞，是以 POST 為主，而非 GET</strong></p><p>也就是說，當 Actor B 想要知道 Actor A 有沒有送訊息過來，並非發出請求叫 Server B 去 Server A 看看 Actor A 的 OUTBOX，而是 Server A 比需要主動檢查 Actor A 的 OUTBOX，把訊息傳遞給對應的 Server B (也可能是其他 Server)。如果 Server A 沒做好這件事情，則 Actor B 永遠不會知道 Actor A 對 B 說了某些話。這個互動的模型看起來是發生在 ActivityPub 的所有 Server-to-Server-federation-protocol 上面，也影響了後續的很多行為</p><p>接著來看 Follow，假設有 Actor A 想要 Follow Actor B</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_follow_activity.svg" class=""></div><p>Actor A 發出了一個 Follow Activity 想要訂閱 Actor B，到 Step 3 之前都跟前面一樣。Step 4 就是一個由實作彈性決定的步驟：「要不要接受這個 follow」，也就是說要不要送出一個 Accept Activity</p><p>以 Twitter 的行為來舉例的話，就是「預設 Accept 所有的 Follow Request」，但是在 Activity Pub 裡面可以有 Reject 的空間，也可以預設就是 Accept</p><p>這邊的重點在於 <strong>發出的 <code>Follow Activity</code> 要被接受，才會把 Actor 放進 Follower</strong>。回到上一段講到的重點，Server 之間的互動是以 POST 為主。當 Actor A 的 Follow activity 被 Actor B 接受之後，Actor B 才會把 A 放進 Follower 的清單裡面。當 Actor B 發出新貼文的時候，只會通知 Follower。如果 A 不在清單裡面，那麼它不會知道 B 有新的貼文</p><p>畫成圖片就像這樣</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_create_activity.svg" class=""></div><p>Actor B 寫了一篇新文，產生了 <code>Create Activity</code>，Step 2 找出 Actor B 想要通知 (POST) 的對象，然後把訊息送出去 (Step 3, 4, 5)。送出的接受對象可能是單一的 Actor，也可能是一個共用的 INBOX</p><p>ActivityPub 裡面就大概定義了這些看起來滿高階的行為，但是更細節的部分就沒討論到，大概是保留實作的彈性吧</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>回到前面一開始的三個問題。理論上只要 Server 可以把 Follow Activity 送到其他 Server，那麼我就可以追蹤任意 Server 上面的帳號。但是 Server 之間可以相互封鎖對方，因此我認為答案是 Yes and No。問題二上面已經回答了。至於問題三，我認為是透過 Server 之間的封鎖(過濾)行為來達成的。</p><p>Server admin 可以決定哪些 Server 的訊息可以進來，就像每個城市都可以決定規則，允許哪些外人進入城內。對於總是產出壞人的城市予以拒絕，對於表現優良的城市給予通行，於是 Server 之間就組成了 Federation。Mastodon 的服務群，還能夠組成 <a href="https://en.wikipedia.org/wiki/Fediverse">Fediverse</a>。</p><p>Serve 之間是依照彼此的價值觀組成一個群體，所以我認為是潛規則驅動，用政治方式解決仇恨言論的問題。有興趣的還可以看這篇 <a href="https://www.theverge.com/2019/7/12/20691957/mastodon-decentralized-social-network-gab-migration-fediverse-app-blocking">How the biggest decentralized social network is dealing with its Nazi problem</a>。至於 Server 內的仇恨言論？當然就由 Admin 決定要不要一巴掌拍死囉</p><p>對於一般來說使用者來說還是受制於 Server admin 的管轄，所以我會說使用者只是對自己的帳號稍微多了一點掌控權(你不一定要從某個你很討厭的 server 加入 federation)</p><p>雖然這樣感覺起來似乎有稍微擺脫科技巨頭的箝制。但是回頭想想，Hosting, Domain name 跟我們註冊的 e-mail 帳號還是給大公司牢牢抓著，小個體戶擁有的自由依然比想像中小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;devpoga.org&quot;&gt;Poga&lt;/a&gt; 架了 &lt;a href=&quot;https://g0v.social/&quot;&gt;g0v.social&lt;/a&gt; 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。&lt;/p&gt;
&lt;p&gt;不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>Thinkpad TrackPoint Keyboard 2 works well on Macbook Pro 2019</title>
    <link href="https://jchu.cc/2021/07/05-tp-keyboard.html"/>
    <id>https://jchu.cc/2021/07/05-tp-keyboard.html</id>
    <published>2021-07-05T13:47:12.000Z</published>
    <updated>2021-07-06T14:31:35.318Z</updated>
    
    <content type="html"><![CDATA[<p>Conclusion: I had bought a Thinkpad TrackPoint Keyboard 2 yesterday (2021 July 4th), it works well on my Macbook Pro. I don’t find a way to adjust scroll direction (becase I enabled Natural scroll direction for built-in trackpad). Except this. I would like to say: it works perfect.</p><span id="more"></span><p>My configuration</p><ul><li>Mac OS X 11.4 Big Sur</li><li>Macbook Pro 15-inch 2019, Intel Core i9</li></ul><p>Test result</p><ul><li>✅ Bluetooth connection has no problem</li><li>✅ 2.4G connection has no problem</li><li>✅ Fn key has no problem</li><li>✅ TrackPoint has no problem</li></ul><p>When pairing TP keyboard to MBP, do not forget to input Pin code. If you don’t like the default key mapping, <a href="https://karabiner-elements.pqrs.org/">Karabiner Elements</a> will help you a lot. Inlcudes switching key layout, or disabling TrackPoint middle key.</p><p>Pressing <code>Fn</code> + <code>Esc</code> to enable FnLock, then you could use Function keys as usual.</p><p>Since I enabled Natural scroll direction in MBP for its built-in trackpad, using TrackPoint for scrolling will apply opposit direction, and I haven’t found a way to address this issue. But this is not big deal for me.</p><div style="max-width: 300px; margin: auto;"><img src="/2021/07/05-tp-keyboard/pic.jpg" class=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Conclusion: I had bought a Thinkpad TrackPoint Keyboard 2 yesterday (2021 July 4th), it works well on my Macbook Pro. I don’t find a way to adjust scroll direction (becase I enabled Natural scroll direction for built-in trackpad). Except this. I would like to say: it works perfect.&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="tools" scheme="https://jchu.cc/tags/tools/"/>
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>What is 「交通規則をにげろ」</title>
    <link href="https://jchu.cc/2021/07/02-nihongo.html"/>
    <id>https://jchu.cc/2021/07/02-nihongo.html</id>
    <published>2021-07-01T17:13:33.000Z</published>
    <updated>2021-07-06T14:32:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>It is funny that there were lots of Japanese languae learner were asking the meaning of “交通規則を逃げろ(にげろ)”, but every japanese native speaker answers “this sentence doesn’t make sense”.</p><span id="more"></span><p>But, why there were so many learners asking same question?</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_1.jpg" class=""></div><p>Because they all used みなの日本語II as text book. In page. 62 you will find this example</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_2.jpg" class=""></div><p>The answer is quite simple: We misinterpreted the format.</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/02-nihongo/pic_3.jpg" class=""></div><p>Wrong</p><ol><li>交通規則を逃げろ</li><li>交通規則をまもれ</li></ol><p>Correct</p><ol><li>逃げろ</li><li>交通規則をまもれ</li></ol><p>Oh, yes, I made the same mistake yesterday, haha!</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;It is funny that there were lots of Japanese languae learner were asking the meaning of “交通規則を逃げろ(にげろ)”, but every japanese native speaker answers “this sentence doesn’t make sense”.&lt;/p&gt;</summary>
    
    
    
    <category term="japan" scheme="https://jchu.cc/categories/japan/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>《BLEACH 死神》雜感</title>
    <link href="https://jchu.cc/2021/06/22-bleach.html"/>
    <id>https://jchu.cc/2021/06/22-bleach.html</id>
    <published>2021-06-22T13:25:07.000Z</published>
    <updated>2021-06-26T16:39:14.814Z</updated>
    
    <content type="html"><![CDATA[<p>漫畫<a href="https://zh.wikipedia.org/wiki/BLEACH">BLEACH 死神</a> 是從 2001 年我高中時期就開始連載的漫畫，一直到 2016 年出了完結篇，此時我不但已經工作好多年，連小孩都已經出生了。這部漫畫最輝煌的時候，也橫跨了我的整個青少年時期，最後差不多以相當難堪的結局收場，不免唏噓。稍微紀錄一下心得，也當作是給模糊的青春記憶加個分號</p><span id="more"></span><h2 id="跟咒術迴戰的比較"><a href="#跟咒術迴戰的比較" class="headerlink" title="跟咒術迴戰的比較"></a>跟咒術迴戰的比較</h2><p>會想起這部漫畫，老實說是因為咒術迴戰。雖然五条悟因為遮眼與朝天髮讓人頗容易聯想到卡卡西，但是咒術迴戰的主題是人與妖怪咒物的互動，而且美型的人物，還有片尾曲的日常生活細節溢滿渋谷青少年的時尚感，很難不聯想到 BLEACH。網路上不少文章也提到，芥見下下的偶像就是 BLEACH 的作者久保帶人，所以咒術迴戰有 BLEACH 的影子也不意外。</p><p>咒術迴戰的主角虎杖悠仁，跟 BLEACH 的男主角黑崎一護兩者也都還滿多相近的設定。同樣都是以高中生為副業，打怪物為本業，能力當然有主角威能加持而天生神力，體內也都有個神秘而難以控制的強大力量，這些都算是王道漫畫的基本配備。此外兩人同樣都是會用心替朋友著想的好心腸，日常生活中也都是同學圈裡的重心，當然還有其他漫畫主角也是同樣的設定，但是比較到這邊就能確認，芥見的虎杖跟久保的一護有相當程度的重疊。</p><p>只是，虎杖在網路上大家都相當疼惜地叫他「乖孫」，雖然有些人沒有很愛他，但是大致上虎杖角色拿到的都是好評。相反地，一護的評價就差得多，不外乎是重聽(常常講：「你..你說什麼」)跟情緒化的嘶吼(「你說什麼！！」)，常常叫到連漫畫裡面的其他人物都請他安靜一點。明明是相當類似的主角性格，得到的評價卻天差地遠，只能說是久保把故事導壞了</p><h2 id="強度崩壞是問題但不是致命傷"><a href="#強度崩壞是問題但不是致命傷" class="headerlink" title="強度崩壞是問題但不是致命傷"></a>強度崩壞是問題但不是致命傷</h2><p>忘了是哪看到的大師名言： <strong>所有的故事就是在追尋某樣東西的過程</strong> ，我不確定這個標準適用的範圍能有多廣，但是在少年漫畫上大致成立。不管是找爸爸、找弟弟的身體、大秘寶，或是要找到魔王把他揍一頓，少年漫畫就是一個在實踐目標的過程所發生的事情。作者就是導演，絕大多數的漫畫我們都猜得到結局(或說就是那幾種組合)，正如絕大多數的電影。但我們想看的是主角怎麼走完這段路。</p><p>強度的設定一直都是少年漫畫的宿命，因為主角要變強，所以一開始讓人絕望的反派角色，常常到中後期就會覺得強度像雜魚。但是強度崩壞，其實是個太常見以至於能夠被自然忽視的問題。就像霹靂布袋戲，除了幾個不死系的主角，每個在新章節登場的人物，常常都是能夠橫掃武林的傳說強者(白骨靈車、一葉知秋太黃君、武皇半尺劍、三途判…不勝枚舉)，到了章末又會變成一群雜魚都能追著打的弱角。</p><p>但是一個角色能不能引起共鳴，其實跟強度沒有直接的關係。譬如說自來也雖然在故事前期被稱為「傳說中的三忍」，從後期的忍界大戰來比較，很容易就能找到強過他的人，他就是標準的早期強者無法把強度撐到後期的案例。但是自來也這個角色的經典程度不需贅言，他會受歡迎不是因為他最強，而是他的人生故事講得很好。從一開始的強者前輩，接著成為傳授主角技術的職人，後來又是主角的人生導師，最後又付出生命確實完成了自己的使命。對恩師、舊友、戀人、敵人、愛徒、還有憨孫的互動，讓這個角色變得很豐滿。而且自來也一生的信念與情緒轉折，都讓人覺得合理而有共鳴，所以自來也豪傑的故事才會讓人那麼著迷。</p><p>看少年漫畫是在看故事，看故事是在看人跟人的情緒互動。要是中間「跳 tone」了，讀者就會出戲，就會覺得漫畫不合理。雖然 NARUTO 跟 BLEACH 都有強度崩壞的問題，但是 NARUTO 至少把其中幾個角色的故事講得完整，BLEACH 可說是沒有任何一個善終。</p><p>更何況 BLEACH 連戰鬥都寫壞了</p><h2 id="故事大綱"><a href="#故事大綱" class="headerlink" title="故事大綱"></a>故事大綱</h2><p>BLEACH 一共 74 集，用我印象比較深的故事劇情來排列，大概會是這樣</p><ul><li>代理死神篇<ul><li>故事開始，意外取得死神能力並活躍</li><li>介紹學校同學，豐富同學個性並提供舞台</li><li>持續解決案件，補足世界觀(虛)</li><li>埋下一護身世的伏筆</li></ul></li><li>屍魂界・潛入篇<ul><li>故事進入轉折，引入新的組織護廷十三隊</li><li>一護與同學跟浦原深交，各自開始提升能力</li><li>進入屍魂界外圍，補足屍魂界世界觀</li><li>以煙火的方式進入瀞靈廷</li></ul></li><li>屍魂界・救出篇<ul><li>各自與護廷十三隊戰鬥</li><li>藍染的陰謀浮上檯面</li><li>一護戰敗、增強能力</li><li>繼續護廷十三隊戰鬥，一護認識愈來愈多朋友</li><li>救出露琪雅，藍染大魔王正式登場</li></ul></li><li>破面・出現篇<ul><li>假面軍勢登場，護廷十三隊進入現世</li><li>破面痛擊護廷十三隊</li><li>一護鍛鍊虛化能力</li></ul></li><li>破面・虛圏救出篇<ul><li>破面再次痛擊護廷十三隊，同時井上被帶走</li><li>一護等人進入虛圈，往目標前進的同時收集夥伴與打倒敵人</li><li>一護被第 4 十刃烏爾奇奧拉擊敗</li><li>一護擊敗第 6 十刃葛力姆喬</li></ul></li><li>破面・VS.死神篇<ul><li>隊長群進入虛圈開始帥一波</li><li>藍染率領破面進攻假的空座町</li></ul></li><li>破面・空座決戰篇<ul><li>交代假面軍勢的過去</li><li>一護擊敗第 4 十刃烏爾奇奧拉</li><li>死神大戰破面</li></ul></li><li>破面・滅亡篇<ul><li>藍染輾壓眾人，融合崩玉</li><li>藍染進入真正的空座町</li><li>一護在斷界進行精神時光屋修行，擊敗藍染</li></ul></li><li>代理死神消失篇<ul><li>完現術者集團 XCUTION 登場</li><li>一護取回死神能力</li><li>死神完勝 XCUTION</li></ul></li><li>千年血戰篇<ul><li>無形帝國登場，攻佔虛圈並重創瀞靈廷</li><li>零番隊登場，一護身世解謎並提升能力</li><li>無形帝國毀滅瀞靈廷，擊敗零番隊攻下靈王宮</li><li>死神群進入被改造後的無形帝國，與最後的滅卻師交戰</li><li>一護等人擊敗友哈巴赫，故事完結</li></ul></li></ul><p>整個故事的起承轉合就是序章開始、打死神、打虛、打滅卻師，把人類以外的三界都打完一遍就完結了。屍魂界救出篇奠定了 BLEACH 的地位，至此 21 集的長度算是適中，所以也不少人認為 BLEACH 如果在屍魂界篇就結束，就是像鬼滅之刃那樣以高人氣的身份完結；就算拖到藍染大魔王打完的 48 集，雖然有點難堪，還能算是善終。可能是作者的意願，或是出版社的意志，總之 BLEACH 拖到了千年血戰篇，完全消耗掉所有人的耐性，以相當草率的方式收場。</p><h2 id="久保其實很能夠打造有趣的角色"><a href="#久保其實很能夠打造有趣的角色" class="headerlink" title="久保其實很能夠打造有趣的角色"></a>久保其實很能夠打造有趣的角色</h2><p>整個死神的世界觀相當龐大，如果一段一段地探討章節，在白哉第一次要把露琪亞抓回去以前，基本上故事圍繞在一護與他的親友身上。這時候的風格比較接近青春校園番，也是幽遊白書在戶愚呂出場前的風格。每個同學的性格鮮明，有相互吐槽的機會絕對不放過。魂大爺第一次出場，拿著一護的身體出風頭惡搞時，一護還很擔心地說：「這樣我的形象不就毀了」，魂心中的OS：『原來這傢伙還會經營形象啊….』</p><p>看似很帥很全能的一護，其實有點悶騷也會在意同學的眼光，同學的觀察結論也是，如果要模仿一護就要抓緊眉頭深鎖的特色。這時露琪亞的吐槽功力，再加上可愛插畫(及其衍生的被吐槽功力)，完全是表現搶眼又討喜的女主角。這個時期一護身邊每個人都能夠好好地演出，基本上沒有戲份不均的問題。</p><h2 id="人數膨脹之後開始出現問題"><a href="#人數膨脹之後開始出現問題" class="headerlink" title="人數膨脹之後開始出現問題"></a>人數膨脹之後開始出現問題</h2><p>久保在設定角色的部分相當用心，但是不看細節互動的話，其實人的個性大致上就只能分成幾十類，漫畫又沒那麼多篇幅去談每個人的細節，通常就是用更誇張的方式去表現性格，或說是「演得很用力」。人數愈多，個別角色就要演得愈用力才能在有限的篇章講完，情緒太多而沒有故事，這個情緒就乾掉了。這個問題特別容易發生在反派身上，所以可以看到很多根本能用歇斯底里來形容的反派。</p><p>同時久保捨不得毀掉精心做好的角色，於是開啟了很淒慘的輪迴</p><ol><li>設定出很好角色</li><li>為了要讓喜歡的角色表現，只好推出新的反派角色，反正新反派殺死不心疼</li><li>反派剛出現要有特色，但是篇幅不夠，只能用充滿精神病的方式表達反派性格，為了要表達反派的強度，所以要追加新的階級設定</li><li>因為是熱血漫畫要有危機感，所以反派與正方要不斷地拿出「我原本不想用這招的」壓箱寶，把對方打得半死</li></ol><p>我第一個有印象的，就是第一次要闖入瀞靈廷遇到的看門人，掛了一堆豪華的設定接著很快就被打爆。從此類似的角色及出場就不斷重複。久保創造了大量的免洗反派，用完就扔，這些精神有問題的反派存在的意義就是填充戰鬥場合。</p><p>雖然說少年漫畫總是要有源源不絕的反派，承太郎打迪奧也是不斷解決各種替身使者，小呆也是要一個個打下去才能接近巴恩大魔王，一步想當上拳王更是要逐場打下去。但是好看的少年漫畫，你也能找到印象深刻的反派。BLEACH 裡面是有些比較突出的反派，藍染就不用說了，銀或是葛力姆喬算是很有戲份的人</p><p>但問題是，為了要給一大群的隊長、副隊長，以及最後淪為一護快樂夥伴的同學們有表現的機會，久保創作太～多的免洗角色，完全稀釋了重要反派角色的存在感。十刃裡面除了烏爾奇奧拉與葛力姆喬還有哪些角色真正讓人有印象呢？星十字騎士團還設定了一堆「文字」，最後讀者又能記得幾個？又為了要增加「特色」，只好塞進一堆奇怪的個性。像最後幾個滅卻師，除了一個墨西哥風的摔角選手，還有個會不斷長大外型像雷神索的大塊頭，每次看到這幾個對手都有點尷尬。</p><p>在平均戲份跟表現性格上，目前為止我只有看過黑色五葉草做得比 BLEACH 差勁</p><h2 id="各式各樣的追加設定與修改"><a href="#各式各樣的追加設定與修改" class="headerlink" title="各式各樣的追加設定與修改"></a>各式各樣的追加設定與修改</h2><p>連載漫畫常常就一邊創作追加各種設定，畢竟漫畫一開頭誰也料不到會有多受歡迎，想不到能夠走多久。只是 BLEACH 在許多小細節上面不斷加入沒有脈絡的新東西，而新東西常常只用在問題發生的當下，事情過後就束之高閣，這樣的事情反覆出現使得整個結構變得更加鬆散。以道具來說，因應劇情當下的需要，經常就會突然拿出新道具。譬如說一護首次到雙亟的下方，被夜一帶到小時候跟浦原玩樂的地方，接著就拿出新道具，可以模仿某人來讓一護修煉。</p><p>道具的問題還算小，畢竟每個漫畫都有。但是「新招」的問題就大了。尤其是正派角色，在遇到困境之後就會演出：「我其實不想用這招的」，接著就是黑頁回想前一段時間，其實之前曾在某個不為人知的時候暗自修煉了新的招式，現在剛好可以拿出來用。這樣的敘事方式用個幾次還可以，但是在 BLEACH 已經被過度濫用。又譬如說日番谷隊長的卍解背後會有幾個花瓣，碎光了就是撐不下去強制解除卍解。結果到後面又遇到同樣危機的時候，全部花瓣碎光了反倒變更強，僅僅只是因為「日番谷變強了」之類的解釋</p><p>少年漫畫裡面，人物怎麼變強都可以，但是必須要有脈絡或是伏筆。譬如說悟空明明第一次只能慘勝達爾，但是到那美克星以前因為有 100 倍重力的訓練，就算戰鬥力飛躍到可以電爆基紐特戰隊，讀者也不會意外。如果在大戰前，能夠簡單地為這些轉折埋下伏筆，苦戰的時候跑出新招其實就是解謎，讀者通常都能接受。但是 BLEACH 的問題是缺乏脈絡的轉折太多，最後讓人覺得敘事缺乏邏輯。</p><p>「第0十刃」的出現也很尷尬。這傢伙最早出場然後被打爆，等到篇章的後期對上朽木跟劍八的時候，為了要成為配得上的對手，身上的數字突然從 10 消去一個數字而轉變成0，接著補了一句：「誰跟你說十刃是 1 ~ 10 的啊？」，不過這個透過數字代表最強實力的十刃，最後只是拖了一些沒意義的戲份就被結果了。這個 10 到 0 的變化，對於劇情的推進毫無影響，只能說又是一塊人氣角色的墊腳石。更何況十刃的數字一開始讓人以為是紋身，結果還可以透過某個不明的機制轉變數字，虛圈竟然有個全知全能的靈力測量系統？</p><p>虛圈也是很奇怪的設定。原本設定成死去的人變成的虛，最後面莫名其妙成為了像是另外一種生物圈，裡面還有悠久的階級與種類，還有個統帥虛圈卻覺得日子很無聊的人。屍魂界跟虛戰鬥了幾千年還不知道有這樣的角色？</p><p>滅卻師更奇怪。一開始解釋成一群擁有戰鬥力的人類，後來卻好像是另外一個人型種族，甚至有好一群人住在類似中古歐洲的村莊裡面，還能透過選拔挑出星十字騎士團。從這邊回頭看雨龍剛出場所說的「最後的滅卻師」感覺就像笑話一場。</p><p>有看過別人寫的文章，把靈王、滅卻師的各種關係串在一起。但我覺得從現實的創作過程與壓力，以及久保的敘事方式來看，太多深入的解釋只是把各種相關的線頭綁在一起，實際上久保只是現在需要什麼就臨時補什麼下去。</p><p>曾經我跟大多數人一樣，覺得虛圈或是千年血戰的部分是多出來的。後來看到別人說，其實久保只想畫千年血戰，反倒虛圈跟護廷十三隊是多出來的設定。後來想想還滿有道理的，如果把瀞靈廷、護廷十三隊、破面、虛圈全部砍掉。那個架構就會變得很單純，屍魂界其實只有創造各種基本規則的零番隊，以及為數不明的死神，剩下普通人被送過去的靈魂也不需要被刻意安排在遊民區，因為遊民區的設定也不需要了。虛圈更簡單，就維持著偶有強力大虛的野蠻世界就好。</p><p>那麼故事就能簡化成，曾經被滅亡的人類滅卻師一族復活後向死神復仇，撼動整個世界的平衡，一個兼有死神與虛的力量的特例人類，站在人類的對立面去守護世界，感覺起來還滿平衡的劇情。不過 BLEACH 已經完結，究竟事情是不是這樣？現在也不可能驗證了</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我根本沒想到會囉唆地打這麽多字！</p><p>雖然批評了一大堆，但是只論破面篇之前的話，其實我還是相當享受這部漫畫。在此之後的部分，撇開絕大多數的戰鬥場景，日常番的部分我也還是看得滿開心。尤其每一話之間的扉頁或是吐槽，久保還是畫得非常棒，吐槽也很夠味。</p><p>就算 BLEACH 結束得草率，我想至少還是比獵人負責任吧 :P</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;漫畫&lt;a href=&quot;https://zh.wikipedia.org/wiki/BLEACH&quot;&gt;BLEACH 死神&lt;/a&gt; 是從 2001 年我高中時期就開始連載的漫畫，一直到 2016 年出了完結篇，此時我不但已經工作好多年，連小孩都已經出生了。這部漫畫最輝煌的時候，也橫跨了我的整個青少年時期，最後差不多以相當難堪的結局收場，不免唏噓。稍微紀錄一下心得，也當作是給模糊的青春記憶加個分號&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="acg" scheme="https://jchu.cc/tags/acg/"/>
    
    <category term="comic" scheme="https://jchu.cc/tags/comic/"/>
    
  </entry>
  
  <entry>
    <title>神奈川縣更新日本駕照</title>
    <link href="https://jchu.cc/2021/05/24-license.html"/>
    <id>https://jchu.cc/2021/05/24-license.html</id>
    <published>2021-05-24T13:29:24.000Z</published>
    <updated>2021-05-24T14:09:07.012Z</updated>
    
    <content type="html"><![CDATA[<p>時光匆匆，上一次<a href="/2019/05/29-license.html">更換日本駕照</a>之後，一下就過了兩年，到了第一次更新駕照的時間。比起第一次的更換駕照，更新的過程相對簡單而且有效率</p><a id="more"></a><p>駕照到期的日子是該年生日的前後一個月，所以在生日的一個月之前就會收到通知書。通知書上會清楚地寫下更新期間，講習的課程種類與價格</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_1.jpg"></div><p>因為我是初次更換，所以一定要到運転免許センター去更新駕照。雖然要跑一趟，但是當天就能拿到駕照，不需另外準備照片，講習的課程也很多，算起來也沒什麼不好。</p><h1 id="準備物品"><a href="#準備物品" class="headerlink" title="準備物品"></a>準備物品</h1><p>住在神奈川縣的鄉親可以參考<a href="https://www.police.pref.kanagawa.jp/mes/mes83002.htm" target="_blank" rel="noopener">運転免許証の更新手続について</a>，需要準備帶去的東西有</p><ul><li>正在使用，快要過期的駕照(運転免許証)</li><li>更新連絡書 (就是上圖那張)</li><li>在留カード</li><li>初次更新的人需要 3850 日圓</li><li><span style="color: grey"><del>運転免許証更新申請書</del>(如果去センター就不需要此項)</span></li><li><span style="color: grey"><del>申請用写真</del>(如果去センター就不需要此項)</span></li></ul><h1 id="跑大地遊戲"><a href="#跑大地遊戲" class="headerlink" title="跑大地遊戲"></a>跑大地遊戲</h1><p>我是大約平日早上八點多快九點才到中心，大門口進去看到人山人海在排隊的地方就是大地遊戲的起點。基本上照著牆上的數字跑完每個關卡就行了。</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_2.jpg"></div><p>第一關就準備好你的<strong>駕照</strong>與<strong>更新通知書</strong>開始登記，登記完之後會要求你輸入兩組四位數字的密碼，印出一張帶有 Bar code 的熱感應紙，後面拍完照就是交出這張紙來設定密碼。</p><p>過了第一關會拿到兩張紙，一張是密碼紙(登録カード)，另外一張更新講習申請書，接著拿申請書去繳費，證明你是優良用路人</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_3.jpg"></div><br><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_4.jpg"></div><p>拿到好寶寶貼紙之後，就像上圖將貼紙貼上去。填完幾個基本資料，別忘記背面還有幾個良心測驗要填。而且要看一下旁邊寫的大字：「請不要彎折這張申請書」</p><p>沒記錯的話，接著就是要檢查視力確認你沒有瞎掉，有戴隱形眼鏡的人記得跟考官說「コンタクトレンズ(contact lens)」對方就會懂了。接著說出上(うえ)下(した)左(ひだり)右(みぎ)證明眼睛功能正常即可。</p><p>之後是查驗證件，查驗完會請你到旁邊的另外一區等待唱名，我猜這時候正在幫你分配講習的場次。唱完名就會拿到單子(有點忘記順序了)，我當時是四號教室。接著就去拍駕照用的囚犯照，再到教室等上課就好</p><div style="max-width: 100%; margin: auto;"><img src="/2021/05/24-license/pic_5.jpg"></div><h1 id="講習"><a href="#講習" class="headerlink" title="講習"></a>講習</h1><p>講習的過程會要求你把閒書收起來專心聽課，其實看完影片聽一些課程再加上休息時間，大概一小時四十分鐘就結束了，實際感受比想像中快。除了中間要自我評量一下看看你是不是個喪心病狂的駕駛？除此之外都沒有任何問答，所以像我這樣的日文苦手也不用擔心</p><p>講習的內容都是講很快的日文，說真的我都聽不懂，不過靠漢字跟基本文法，用看的也能懂個八成。一開始是 25 分鐘的影片，給你看看常見的車禍案例，以及因為車禍變成植物人的家庭是怎麼過生活。影片的核心就是</p><p><strong>當你握了方向盤，你就有責任</strong></p><p>接著開始講要怎麼在路上安全駕駛。譬如說什麼情況可能會有不長眼的腳踏車從你旁邊鑽過去，什麼情況可能會有小屁孩衝到馬路上，什麼情況可能會有白目老人橫斷馬路。</p><p>怎麼講來講去都是別人犯錯卻是駕駛要注意？</p><p>我覺得這就是日本的倡導的駕駛觀念。發生車禍時，責任歸屬是一回事，但是誰會受傷又是另外一回事。到後半段講師又再強調了一次，握了方向盤，你就有責任。一次車禍可能就是一個家庭的一生不幸。</p><p>對於從小在車流逆境中長大的台灣人，應該很難理解吧。雖然聽課前覺得很花時間，但是實際聽完之後我覺得這樣的課程很好。哪怕是僅僅降低百分之一的車禍率，就是減少很多心碎的家庭。</p><p>聽完課程之後就是按照生日的尾數日期依次領證，結束今天的任務。第一次更新駕照，大概花了三個小時左右。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;時光匆匆，上一次&lt;a href=&quot;/2019/05/29-license.html&quot;&gt;更換日本駕照&lt;/a&gt;之後，一下就過了兩年，到了第一次更新駕照的時間。比起第一次的更換駕照，更新的過程相對簡單而且有效率&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
  </entry>
  
  <entry>
    <title>第 10 屆修憲委員會待審議案列表</title>
    <link href="https://jchu.cc/2021/03/06-constitution.html"/>
    <id>https://jchu.cc/2021/03/06-constitution.html</id>
    <published>2021-03-05T16:23:24.000Z</published>
    <updated>2021-03-07T16:46:08.037Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    .kmt:before {        content:"▉";        color: blue;    }    .dpp:before {        content:"▉";        color: green;    }    .npp:before {        content:"▉";        color: gold;    }    .tpp:before {        content:"▉";        color: turquoise;    }    .sbp:before {        content:"▉";        color: brown;    }    .none:before {        content:"▉";        color: gray;    }    article p {        margin-top: 2.3rem;        margin-bottom: 0px;    }    blockquote > p {        margin: 0px;        font-size: 1.1rem;    }    .content h1 {        margin-top: 3rem;    }    .content h2 {        color: black;    }</style><p>修憲一直是我很關心的議題，前幾天看到了<a href="https://www.ly.gov.tw/Pages/Detail.aspx?nodeid=44173&amp;pid=202974" target="_blank" rel="noopener">立法院第10屆修憲委員會待審議案一覽表</a>，就找了一下各委員的修憲提案，整理在這裡。</p><a id="more"></a><p>談到憲法，很多人第一個反應就是想到統獨。的確，憲法是國家主權的展現，裡面一定會涉及到領土的問題。但是憲法的範圍遠遠不止於此，還有許多與內政相關的東西。好比行政院長與各部會首長的產生方式就由憲法的<a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=56" target="_blank" rel="noopener">第 56 條</a>決定(當然就影響到怎麼拚經濟賺錢)；憲法也決定了我國的價值觀，經過釋憲促成的同婚之路就是一個例子。</p><p>簡單地說，憲法決定了我們國家的政府該怎麼運作。</p><p>所以憲法也必須隨著社會變遷而做出更動，才能夠因應新發生的問題，推動國家順利地往前進。</p><p>只是很不幸在 2004 年的第七次修憲，我國的修憲門檻被拉得非常高，自此之後修憲幾乎被視為近乎不可能的任務。修憲的門檻有多高呢？我國立法委員總數為 113 席，即需要 85 位出席，出席者之中要有 64 位同意。這屆的國會黨派組成為</p><ul><li><span class="dpp">民進黨: 61 席</span></li><li><span class="kmt">國民黨: 38 席</span></li><li><span class="tpp">台灣民眾黨: 5 席</span></li><li><span class="npp">時代力量: 3 席</span></li><li><span class="sbp">基進黨 1 席</span></li><li><span class="none">無黨籍: 5 (傅崐萁 林昶佐 趙正宇 高金素梅 蘇震清-剛退出民進黨)</span></li></ul><p>即使所有非國民黨的立委加起來也不過 75 席，換句話說，只要國民黨與民進黨沒有取得共識，就不可能達成修憲，這是第一個門檻。第二個門檻是全民公投，即使修憲案達成共識出了國會，還需要公告半年之後再公投，取得選舉人總額之半數的同意票，<a href="選舉人總額之半數">以風傳媒的計算</a>來看，需要 <strong>967</strong> 萬人同意，也高過蔡總統連任獲得的史上最高 <strong>871</strong> 萬票。</p><p>這次修憲共識最高的是 <strong>18 歲公民權</strong>，除此之外的修憲提案目前感覺起來也是各吹各的調。希望在修憲委員會裡面，各黨能夠以務實的態度尋求共識，消弭黨派之間的成見，推動國家前進。 <strong>同時也希望台灣的民眾，能夠給予修憲委員會多一點關注與壓力</strong></p><ul><li><a href="https://www.thenewslens.com/article/140487" target="_blank" rel="noopener">The News Lens: 睽違15年立法院將成立修憲委員會，各黨提出哪些憲改議題？</a></li><li><a href="https://www.thenewslens.com/article/147369" target="_blank" rel="noopener">The News Lens: 立法院修憲啟動倒數，除了共識最高的「18歲公民權」還有哪些提案？</a></li></ul><p>根據待審議案的表格，我在立法院的<a href="https://lis.ly.gov.tw/lylgmeetc/lgmeetkm" target="_blank" rel="noopener">議事系統</a>找出了對應的議員提案，對修憲有興趣的人，可以去看看到底委員們提了什麼案子，想要如何修憲；也根據提案人、連署人的黨派標上顏色。有幾個提案同時放了兩個不同方向的內容，所以會重複出現。如果標題分類得不好請見諒，如果有更好的建議，歡迎<a href="https://twitter.com/walkingice" target="_blank" rel="noopener">在 Twitter 告訴我</a>。</p><h1 id="參政年齡"><a href="#參政年齡" class="headerlink" title="參政年齡"></a>參政年齡</h1><h2 id="投票年齡下修"><a href="#投票年齡下修" class="headerlink" title="投票年齡下修"></a>投票年齡下修</h2><p>提案建議下修擁有選舉權的年齡。幾乎各黨都有人提出，所以有高度共識，極有可能成案。</p><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=130" target="_blank" rel="noopener">中華民國憲法第 130 條</a><br>中華民國國民年滿二十歲者，有依法選舉之權，除本憲法及法律別有規定者外，年滿二十三歲者，有依法被選舉之權。</p></blockquote><ul><li><span class="kmt">國民黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100106:LCEWA01_100106_00044" target="_blank" rel="noopener">江啟臣</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00046" target="_blank" rel="noopener">林為洲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100112:LCEWA01_100112_00052" target="_blank" rel="noopener">蔣萬安</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00007" target="_blank" rel="noopener">林奕華</a></li><li><span class="dpp">民進黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00020" target="_blank" rel="noopener">蘇巧慧</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100107:LCEWA01_100107_00035" target="_blank" rel="noopener">范雲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100108:LCEWA01_100108_00213" target="_blank" rel="noopener">陳亭妃</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100109:LCEWA01_100109_00052" target="_blank" rel="noopener">高嘉瑜</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100111:LCEWA01_100111_00093" target="_blank" rel="noopener">賴瑞隆</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10190" target="_blank" rel="noopener">洪申翰</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:LCEWA01_100203_00005" target="_blank" rel="noopener">王定宇</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00132" target="_blank" rel="noopener">林俊憲</a>、<a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00107" target="_blank" rel="noopener">鍾佳濱</a></li><li><span class="npp">時代力量：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100211:LCEWA01_100211_00019" target="_blank" rel="noopener">邱顯智</a></li><li><span class="tpp">民眾黨：</span><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10173" target="_blank" rel="noopener">張其祿</a></li></ul><h2 id="總統副總統參選年齡調降"><a href="#總統副總統參選年齡調降" class="headerlink" title="總統副總統參選年齡調降"></a>總統副總統參選年齡調降</h2><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10183" target="_blank" rel="noopener">院總第1607號 委員提案第25125號</a><ul><li>委員蘇巧慧等38人擬具中華民國憲法增修條文第二條條文修正草案（參政年齡-總統副總統參選年齡調降）</li><li>提案與連署：<span class="dpp"><span class="sbp"></span></span></li></ul></li></ul><h1 id="政府體制"><a href="#政府體制" class="headerlink" title="政府體制"></a>政府體制</h1><h2 id="恢復閣揆同意權"><a href="#恢復閣揆同意權" class="headerlink" title="恢復閣揆同意權"></a>恢復閣揆同意權</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=3" target="_blank" rel="noopener">中華民國憲法增修條文第 3 條</a><br>行政院院長由總統任命之…. 行政院依左列規定，對立法院負責</p></blockquote><p>這是相當重大的改變，但也不是第一次被提出。目前為止我國的運作方式是總統直接決定行政院長，不需國會同意，但是行政院的施政都需要經過國會同意，或接受國會監督。如果總統與國會多數黨為同一政黨，問題會比較小；但若朝小野大，則有可能讓總統直接任命的行政院長不被國會信任，形成政治僵局。若國會擁有閣揆同意權，則能降低這類政治衝突。但朝小野大時亦可能發生總統提名的行政院長總是無法通過反對黨的同意，形成政治僵局。此外，閣揆同意權實際上會削弱同樣獲得民意基礎的總統的權力，所以這是很大的憲政改變，需要非常多的考量，更多的細節請尋找有足夠憲法知識的其他前輩的文章，這部分我不敢妄言。(不過，實際上應該不會通過修憲委員會吧 XD)</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:10136" target="_blank" rel="noopener">院總第1607號 委員提案第24968號</a><ul><li>委員賴士葆等30人擬具中華民國憲法增修條文第三條條文修正草案（政府體制-恢復閣揆同意權、修正覆議案及不信任案之規定）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h2 id="立委任期調整"><a href="#立委任期調整" class="headerlink" title="立委任期調整"></a>立委任期調整</h2><p>總統與立委雖然是同一天選舉，但是一月如果選出不同執政黨的總統，要到 520 就職才能行駛職權，就是偶爾會聽見的「憲政空窗期」，針對這點難得藍綠都有提案。</p><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00039" target="_blank" rel="noopener">院總第1607號 委員提案第24949號</a></p><ul><li>委員林德福等29人擬具中華民國憲法增修條文第二條及第四條條文修正草案（制度改革-總統及立委任期調整、立法院會期調整、國情報告常態化）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00038" target="_blank" rel="noopener">院總第1607號 委員提案第25909號</a></p><ul><li>委員郭國文等37人擬具中華民國憲法增修條文第二條、第三條及第四條條文修正草案（制度改革-刪除總統解散立法院之權、總統及立委任期調整、立法院會期調整等）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h2 id="確立總統制政體"><a href="#確立總統制政體" class="headerlink" title="確立總統制政體"></a>確立總統制政體</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000001&amp;flno=53" target="_blank" rel="noopener">中華民國憲法第 53 條</a><br>行政院為國家最高行政機關。</p></blockquote><p>我國的憲政實務為，總統主管外交國防，行政院長主管內政，但是行政院長由總統直接指派(通常視為執行總統意志)，但是行政院長要到立法院備詢，而總統不需要。所以總統會不會管到內政？目前是由總統個人意志或是政治現實決定。</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:10349" target="_blank" rel="noopener">院總第1607號 委員提案第25241號</a><ul><li>委員林為洲等30人擬具中華民國憲法增修條文第二條及第三條條文修正草案（政府體制-總統制）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="修憲門檻"><a href="#修憲門檻" class="headerlink" title="修憲門檻"></a>修憲門檻</h1><h2 id="下修修憲門檻"><a href="#下修修憲門檻" class="headerlink" title="下修修憲門檻"></a>下修修憲門檻</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=12" target="_blank" rel="noopener">中華民國憲法增修條文第 12 條</a><br>憲法之修改，須經立法院立法委員四分之一之提議，四分之三之出席，及出席委員四分之三之決議，提出憲法修正案，並於公告半年後，經中華民國自由地區選舉人投票複決，有效同意票過選舉人總額之半數，即通過之，不適用憲法第一百七十四條之規定。</p></blockquote><p>我個人私心覺得這是我最在意的修憲案，但也是通過的希望渺茫。</p><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00057" target="_blank" rel="noopener">院總第1607號 委員提案第25369號</a><ul><li>委員林昶佐等32人擬具中華民國憲法增修條文第十二條條文修正草案（修憲門檻-降低修憲門檻）</li><li>提案與連署：<span class="none"><span class="dpp"></span></span></li></ul></li></ul><h1 id="權力分立"><a href="#權力分立" class="headerlink" title="權力分立"></a>權力分立</h1><h2 id="廢止考試院、監察院及其職權移轉"><a href="#廢止考試院、監察院及其職權移轉" class="headerlink" title="廢止考試院、監察院及其職權移轉"></a>廢止考試院、監察院及其職權移轉</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=6" target="_blank" rel="noopener">中華民國憲法增修條文第 6 條</a><br> 考試院為國家最高考試機關….<br><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=7" target="_blank" rel="noopener">中華民國憲法增修條文第 7 條</a><br> 監察院為國家最高監察機關，行使彈劾、糾舉及審計權….</p></blockquote><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100108:LCEWA01_100108_00215" target="_blank" rel="noopener">院總第1607號 委員提案第24329號</a></p><ul><li>委員陳亭妃等29人擬具中華民國憲法增修條文部分條文修正草案(第3、4、6、7條)（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉</li><li>提案與連署：<span class="dpp"><span class="none"></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100115:LCEWA01_100115_00052" target="_blank" rel="noopener">院總第1607號 委員提案第24867號</a></p><ul><li>委員吳思瑤等30人擬具中華民國憲法增修條文第四條之一、第六條及第七條條文修正草案（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:LCEWA01_100203_00005" target="_blank" rel="noopener">院總第1607號 委員提案第25024號</a></p><ul><li>委員王定宇等32人擬具中華民國憲法增修條文部分條文修正草案(第4、6、7、11條)（1.權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉</li><li>提案與連署：<span class="dpp"><span class="none"><span class="sbp"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00182" target="_blank" rel="noopener">院總第1607號 委員提案第25414號</a></p><ul><li>委員鍾佳濱等32人擬具中華民國憲法增修條文第三條及第六條條文修正草案（權力分立-廢止考試院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100207:LCEWA01_100207_00018" target="_blank" rel="noopener">院總第1607號 委員提案第25637號</a></p><ul><li>委員范雲等33人擬具中華民國憲法增修條文部分條文修正草案(第3-1、4-1、4-2、4-3、6、7、7-1、7-2條)（權力分立-廢止考試院及其職權移轉、廢止監察院及其職權移轉）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h1 id="國會職權"><a href="#國會職權" class="headerlink" title="國會職權"></a>國會職權</h1><h2 id="立法院聽證調查權入憲"><a href="#立法院聽證調查權入憲" class="headerlink" title="立法院聽證調查權入憲"></a>立法院聽證調查權入憲</h2><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00133" target="_blank" rel="noopener">院總第1607號 委員提案第25243號</a><ul><li>委員林俊憲等30人擬具中華民國憲法增修條文增訂第四條之一條文草案（國會職權-立法院聽證調查權入憲）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h2 id="提高立法院對司法院、考試院及監察院人事同意權門檻"><a href="#提高立法院對司法院、考試院及監察院人事同意權門檻" class="headerlink" title="提高立法院對司法院、考試院及監察院人事同意權門檻"></a>提高立法院對司法院、考試院及監察院人事同意權門檻</h2><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00045" target="_blank" rel="noopener">院總第1607號 委員提案第24963號</a></p><ul><li>委員曾銘宗等31人擬具中華民國憲法增修條文第五條、第六條及第七條條文修正草案（國會職權-提高立法院對司法院、考試院及監察院人事同意權門檻）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:10350" target="_blank" rel="noopener">院總第1607號 委員提案第25154號</a></p><ul><li>委員吳怡玎等29人擬具中華民國憲法增修條文部分條文修正草案(第5、6、7、10條) （1.國會職權-提高立法院對司法院、考試院及監察院人事同意權門檻。2.基本國策-保障幼兒接受教育之基本權）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h2 id="國情報告常態化"><a href="#國情報告常態化" class="headerlink" title="國情報告常態化"></a>國情報告常態化</h2><blockquote><p><a href="https://law.moj.gov.tw/LawClass/LawSingle.aspx?pcode=A0000002&amp;flno=4" target="_blank" rel="noopener">中華民國憲法增修條文第 4 條</a><br>立法院於每年集會時，得聽取總統國情報告。</p></blockquote><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:10137" target="_blank" rel="noopener">院總第1607號 委員提案第24969號</a><ul><li>委員賴士葆等30人擬具中華民國憲法增修條文第四條條文修正草案（制度改革-國情報告常態化）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="基本國策"><a href="#基本國策" class="headerlink" title="基本國策"></a>基本國策</h1><ul><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100201:LCEWA01_100201_00040" target="_blank" rel="noopener">院總第1607號 委員提案第24950號</a></p><ul><li>委員林德福等29人擬具中華民國憲法增修條文第十條條文修正草案（基本國策-寬列青年發展經費）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10141" target="_blank" rel="noopener">院總第1607號 委員提案第25094號</a></p><ul><li>委員鄭麗文等29人擬具中華民國憲法增修條文增訂第十三條條文草案（基本國策-保障人民數位權）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10142" target="_blank" rel="noopener">院總第1607號 委員提案第25095號</a></p><ul><li>委員鄭麗文等30人擬具中華民國憲法增修條文增訂第十四條條文草案（基本國策-保障人民享有安全、健康與環境永續的氣候環境）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10143" target="_blank" rel="noopener">院總第1607號 委員提案第25096號</a></p><ul><li>委員鄭麗文等29人擬具中華民國憲法增修條文增訂第十五條條文草案（基本國策-保障生物多樣性、重視動物保護等）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100204:LCEWA01_100204_00017" target="_blank" rel="noopener">院總第1607號 委員提案第25307號</a></p><ul><li>委員陳柏惟等32人擬具中華民國憲法增修條文增訂第十條之一條文草案（基本國策-落實轉型正義）</li><li>提案與連署：<span class="sbp"><span class="dpp"><span class="npp"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00219" target="_blank" rel="noopener">院總第1607號 委員提案第25350號</a></p><ul><li>委員曾銘宗等32人擬具中華民國憲法增修條文增訂第十三條條文草案（基本國策-落實財政紀律）</li><li>提案與連署：<span class="kmt"></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100209:LCEWA01_100209_00081" target="_blank" rel="noopener">院總第1607號 委員提案第25851號</a></p><ul><li>委員蔡壁如等33人擬具中華民國憲法增修條文增訂第十條之一條文草案。（基本國策-重視動物保護等）</li><li>提案與連署：<span class="tpp"><span class="dpp"><span class="kmt"></span></span></span></li></ul></li><li><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100301:LCEWA01_100301_00006" target="_blank" rel="noopener">院總第1607號 委員提案第25880號</a></p><ul><li>委員林奕華等31人擬具中華民國憲法增修條文第十條條文修正草案（基本國策-動物保護入憲）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="總統誓詞"><a href="#總統誓詞" class="headerlink" title="總統誓詞"></a>總統誓詞</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100203:10156" target="_blank" rel="noopener">院總第1607號 委員提案第25143號</a><ul><li>委員江啟臣等31人擬具中華民國憲法增修條文增訂第二條之一條文草案（總統誓詞-修正總統就職宣誓誓詞）</li><li>提案與連署：<span class="kmt"></span></li></ul></li></ul><h1 id="人性尊嚴"><a href="#人性尊嚴" class="headerlink" title="人性尊嚴"></a>人性尊嚴</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100111:LCEWA01_100111_00029" target="_blank" rel="noopener">院總第1607號 委員提案第24516號</a><ul><li>委員林昶佐等35人擬具中華民國憲法增修條文增訂第一條之一、第一條之二及第一條之三條文草案（人權保障-人性尊嚴等項）</li><li>提案與連署：<span class="none"><span class="dpp"><span class="npp"><span class="sbp"></span></span></span></span></li></ul></li></ul><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100207:LCEWA01_100207_00019" target="_blank" rel="noopener">院總第1607號 委員提案第25638號</a><ul><li>委員范雲等34人擬具中華民國憲法增修條文增訂部分條文草案(第1-1、1-2、1-3、1-4條)（人權保障-人性尊嚴等項）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><h1 id="制度改革"><a href="#制度改革" class="headerlink" title="制度改革"></a>制度改革</h1><ul><li><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100206:LCEWA01_100206_00078" target="_blank" rel="noopener">院總第1607號 委員提案第25410號</a><ul><li>委員伍麗華等39人擬具中華民國憲法增修條文第四條條文修正草案（制度改革-刪除平地山地原住民分類）</li><li>提案與連署：<span class="dpp"></span></li></ul></li></ul><p>最後讓我多碎嘴幾句。修憲真的很困難，各黨之間要是失去信任，修憲幾乎可以視為破局。不管你的立場站在哪一方，盡量都多忍忍，不要口出惡言或醜化對方陣營。我甚至覺得，只要能夠下修修憲門檻就已經是萬幸，我國的憲法就有再次改造的機會，否則未來也想不到還有什麼類似 18 歲投票權的議題，能夠提供足夠的修憲能量。如果憲政制度不能往前走，現有的政府制度遇到挑戰，只能疊床架屋繞過問題，效率低落的苦果還是全民承擔。</p><p>也希望能看到更多憲法專家的精闢討論與意見</p>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    .kmt:before {
        content:&quot;▉&quot;;
        color: blue;
    }
    .dpp:before {
        content:&quot;▉&quot;;
        color: green;
    }
    .npp:before {
        content:&quot;▉&quot;;
        color: gold;
    }
    .tpp:before {
        content:&quot;▉&quot;;
        color: turquoise;
    }
    .sbp:before {
        content:&quot;▉&quot;;
        color: brown;
    }
    .none:before {
        content:&quot;▉&quot;;
        color: gray;
    }

    article p {
        margin-top: 2.3rem;
        margin-bottom: 0px;
    }

    blockquote &gt; p {
        margin: 0px;
        font-size: 1.1rem;
    }

    .content h1 {
        margin-top: 3rem;
    }

    .content h2 {
        color: black;
    }

&lt;/style&gt;

&lt;p&gt;修憲一直是我很關心的議題，前幾天看到了&lt;a href=&quot;https://www.ly.gov.tw/Pages/Detail.aspx?nodeid=44173&amp;amp;pid=202974&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;立法院第10屆修憲委員會待審議案一覽表&lt;/a&gt;，就找了一下各委員的修憲提案，整理在這裡。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>使用 Mayflash 把舊搖桿接上 Nintendo Switch</title>
    <link href="https://jchu.cc/2021/03/04-mayflash.html"/>
    <id>https://jchu.cc/2021/03/04-mayflash.html</id>
    <published>2021-03-03T17:18:59.000Z</published>
    <updated>2021-03-03T16:36:46.775Z</updated>
    
    <content type="html"><![CDATA[<p>結論：利用 Mayflash Magic S-Pro，可以用 Logitech F310 玩 Nintendo Switch</p><a id="more"></a><div style="margin: auto;"><img src="/2021/03/04-mayflash/f310.jpg"></div><p>Joy Con 的飄移問題讓人詬病已久，在家玩 Switch 的時候早就已經遇到這個問題。雖然還在保固內可以送修，但是未來用久了還是會再次遇到這個問題。突然想到我有專門用來玩 PC game 的 Logitech F710 跟 F310，不是很昂貴的搖桿，用起來還算順手，如果能夠拿來玩 Switch 就太好了。</p><p>稍微搜尋一下，只要買某幾支 USB Dongle 接上去就可以玩，於是選了<a href="https://www.mayflash.com/Products/NINTENDOWiiU/MAGIC-S%20PRO.html" target="_blank" rel="noopener">Mayflasy Magic S-Pro</a>，只比 Magic-NS 多上一點價格，如果哪天有 PS4 也可以用。</p><p>剛拿到 Dongle 接上 Switch 卻怎麼也連不上搖桿，試了一下就知道要認真看看官網上面的說明：要進入 Switch 的設定畫面 / Controller and Sensors / 打開 Pro Controller Wired Communication，接著 Switch 就會把外接的搖桿當成 Nintendo Switch Pro Controller 連接了</p><p>玩一些 FC/SFC 的老遊戲，尤其是動作類的遊戲，還是傳統有線搖桿比較順手</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;結論：利用 Mayflash Magic S-Pro，可以用 Logitech F310 玩 Nintendo Switch&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>離線閱讀 Android Doc</title>
    <link href="https://jchu.cc/2020/12/10-android-doc.html"/>
    <id>https://jchu.cc/2020/12/10-android-doc.html</id>
    <published>2020-12-10T13:53:39.000Z</published>
    <updated>2021-03-03T16:18:26.852Z</updated>
    
    <content type="html"><![CDATA[<p>寫 Android 的程式總是要時時閱讀本草綱目(API documentation)，才會確定應該呼叫哪個 API，就我所知某些人的做法是在 Android Studio 裡面直接看程式碼，不過我還是比較喜歡看精美的 HTML 檔案</p><p>雖然很多人是看 online 的版本，不過我從大學時期養成的習慣，還是比較喜歡下載一份 offline 的版本，自己開瀏覽器閱讀。只是這件事情在 Android 上面愈來愈難做到了…</p><a id="more"></a><p>JAVA JDK 的文件一直都能<a href="https://www.oracle.com/java/technologies/javase-jdk8-doc-downloads.html" target="_blank" rel="noopener">直接下載</a>，但是 Android 我還沒看到這樣的東西，幾年前我還會從 source code 自己 <a href="http://0xwalkingice.blogspot.com/2010/03/javadoc-at-android.html" target="_blank" rel="noopener">make doc</a>，隨著 AOSP 愈來愈癡肥，我也懶得自己生出 javadoc。</p><p>在 Android SDK Manager 裡面，可以直接下載 doc。很遺憾地，最近已經無法下載。在 stackoverflow 上頭有人說 <a href="https://stackoverflow.com/a/49262913" target="_blank" rel="noopener">已經不再提供下載</a>，也只能無奈地接受這個很 Google 的現況。</p><p>還好網路上還找得到一些 for Zeal 的 offline doc 可以直接下載，湊合著用尚且過得去，哪天受不了了再自己生出一份 doc 吧。Zeal/Dash 都很好，但我不是很喜歡再額外開個 app 來讀文件，如果能在瀏覽器裡面就搞定，我會盡量待在瀏覽器裡頭。</p><p>Android doc 雖然很長一段時間可以直接下載，但是有個搜尋的功能在 Android 7 之後在 offline 版本就壞掉了，使得我其實停留在 Android 6 doc 很久，真的需要查詢新的文件我才會開線上版本。</p><p>按下 <code>Command + /</code> 之後就能快速搜尋出某一個類別。</p><div style="max-width: 100%; margin: auto;"><img src="/2020/12/10-android-doc/search_official.gif"></div><p>不過線上版的這個搜尋功能做得很爛，總是先顯示一堆 Guide，殊不知真的來看文件的人，其實要看的是類別的說明，而不是 Guide。</p><p>前兩天突然想通，其實要做個簡易版本也不是很難。就先準備好每個頁面的連結與關鍵字的資料，頁面讀完的時候塞個 dom，輸入文字的時候去資料裡面查一下就好</p><p>就快速地花一個晚上寫了兩個小小的 script</p><ul><li><a href="/2020/12/10-android-doc/parser.pl" title="parser.pl">parser.pl</a> - 很簡單的 perl script，搜尋出目錄底下的 html 檔，parse 之後吐到 stdout。所以把輸出的文字 pipe 到一個 js 檔就好</li><li><a href="/2020/12/10-android-doc/loader.js_" title="loader.js_">loader.js_</a> - 這個 js 檔會在頁面塞進一個 input DOM，並且拿前述的資料來用</li><li>恰好 Android offline doc 的每一頁都會讀進固定的 js 檔，所以把前面兩個 js 檔塞到必讀的 js 檔的最尾端就好了</li></ul><p>跑起來像這樣</p><div style="max-width: 100%; margin: auto;"><img src="/2020/12/10-android-doc/search_mine.gif"></div><p>其實還可以寫成 browser extension。不過仔細想想，也不知道多少人會有類似的需求，搞不好只有我會用這麼彆扭的方式開發，所以現在花一個晚上隨便弄弄會動就好，不要花太多力氣在這上面(聳肩)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫 Android 的程式總是要時時閱讀本草綱目(API documentation)，才會確定應該呼叫哪個 API，就我所知某些人的做法是在 Android Studio 裡面直接看程式碼，不過我還是比較喜歡看精美的 HTML 檔案&lt;/p&gt;
&lt;p&gt;雖然很多人是看 online 的版本，不過我從大學時期養成的習慣，還是比較喜歡下載一份 offline 的版本，自己開瀏覽器閱讀。只是這件事情在 Android 上面愈來愈難做到了…&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>用 Python 轉換 markdown 至 html</title>
    <link href="https://jchu.cc/2020/11/21-markdown.html"/>
    <id>https://jchu.cc/2020/11/21-markdown.html</id>
    <published>2020-11-20T15:02:01.000Z</published>
    <updated>2021-03-03T16:14:54.671Z</updated>
    
    <content type="html"><![CDATA[<p>我經常使用 markdown 格式做紀錄，包括我自己的 local <a href="http://walkingice.blogspot.com/2011/11/gitit-git-based-wiki.html" target="_blank" rel="noopener">gitit</a> 或是這個 Blog。</p><p>除了紀錄之外，有時候需要將 Markdown 格式的文件轉成其他格式的檔案來閱讀。</p><a id="more"></a><p>譬如說寫完了文件，可以轉出簡單的 html 檔案傳給同事，或是公司要求的報告，先用 markdown 寫，轉成 html 之後再印成 pdf 檔。</p><p>除了要轉出 html 之外，總希望能有客制 css style，這樣生出來的 html 檔自己看起來比較爽，用起來也比較開心。稍微試了一下 <code>brew</code> 安裝的 markdown 工具，或是 node 上面的一些套件，總覺得有點不順手，或是一個超簡單的需求卻搞到很複雜。</p><p>最後決定快速地寫個很簡單的 python script 來處理這個問題，反正也不是第一次寫了，就順便貼在這裡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The MIT License (MIT)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Copyright (c) 2020 Julian Chu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Permission is hereby granted, free of charge, to any person obtaining a copy of</span></span><br><span class="line"><span class="string">this software and associated documentation files (the "Software"), to deal in</span></span><br><span class="line"><span class="string">the Software without restriction, including without limitation the rights to</span></span><br><span class="line"><span class="string">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span></span><br><span class="line"><span class="string">the Software, and to permit persons to whom the Software is furnished to do so,</span></span><br><span class="line"><span class="string">subject to the following conditions:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The above copyright notice and this permission notice shall be included in all</span></span><br><span class="line"><span class="string">copies or substantial portions of the Software.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="string">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span></span><br><span class="line"><span class="string">FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span></span><br><span class="line"><span class="string">COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span></span><br><span class="line"><span class="string">IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span></span><br><span class="line"><span class="string">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip3 install markdown</span></span><br><span class="line"><span class="keyword">import</span> markdown</span><br><span class="line"></span><br><span class="line">template = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset="utf-8"/&gt;</span></span><br><span class="line"><span class="string">        &lt;style&gt;</span></span><br><span class="line"><span class="string">            @media screen &#123;</span></span><br><span class="line"><span class="string">                 body &#123;</span></span><br><span class="line"><span class="string">                    color: #EEE;</span></span><br><span class="line"><span class="string">                    background-color: #111;</span></span><br><span class="line"><span class="string">                    line-height: 1.5rem;</span></span><br><span class="line"><span class="string">                    font-family: sans-serif;</span></span><br><span class="line"><span class="string">                    font-weight: 300;</span></span><br><span class="line"><span class="string">                    margin: auto;</span></span><br><span class="line"><span class="string">                    max-width: 80rem;</span></span><br><span class="line"><span class="string">                    line-height: 1.5rem;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                h1, h2, h3, h4, h5 &#123;</span></span><br><span class="line"><span class="string">                    line-height: 1.6rem;</span></span><br><span class="line"><span class="string">                    margin-top: 3rem;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                li &#123;</span></span><br><span class="line"><span class="string">                    line-height: 1.6rem;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                a &#123;</span></span><br><span class="line"><span class="string">                    color: #AAF;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            @media print &#123;</span></span><br><span class="line"><span class="string">                body &#123;</span></span><br><span class="line"><span class="string">                    background-color: white;</span></span><br><span class="line"><span class="string">                    font-size: 12pt;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                a:link, a:visited, a &#123;</span></span><br><span class="line"><span class="string">                    color: grey;</span></span><br><span class="line"><span class="string">                    font-weight: bold;</span></span><br><span class="line"><span class="string">                    text-decoration: underline;</span></span><br><span class="line"><span class="string">                    word-wrap: break-word;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                thead &#123;</span></span><br><span class="line"><span class="string">                    display: table-header-group;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;/style&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    %s</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_html</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> template % content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"Usage: %s file"</span> % os.path.basename(sys.argv[<span class="number">0</span>]))</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">    encoding = <span class="string">'utf-8'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], mode=<span class="string">"r"</span>, encoding=encoding) <span class="keyword">as</span> file:</span><br><span class="line">        file_input = file.read()</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line">    converted = markdown.markdown(file_input)</span><br><span class="line">    sys.stdout.write(as_html(converted))</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>一看就知道是在幹什麼</p><ul><li>讀進指定的 markdown，轉成 html content</li><li>把 content 塞進寫好的 template string</li><li>成果寫到 stdout</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install markdown</span><br><span class="line"><span class="comment"># save python file as md.py, add to $PATH</span></span><br><span class="line">$ md.py INPUT.md &gt; output.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我經常使用 markdown 格式做紀錄，包括我自己的 local &lt;a href=&quot;http://walkingice.blogspot.com/2011/11/gitit-git-based-wiki.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitit&lt;/a&gt; 或是這個 Blog。&lt;/p&gt;
&lt;p&gt;除了紀錄之外，有時候需要將 Markdown 格式的文件轉成其他格式的檔案來閱讀。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="python" scheme="https://jchu.cc/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SS 守護者列傳 Guardian Heros 路線圖</title>
    <link href="https://jchu.cc/2020/11/01-game.html"/>
    <id>https://jchu.cc/2020/11/01-game.html</id>
    <published>2020-10-31T17:50:34.000Z</published>
    <updated>2020-12-16T17:38:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>最近跟兒子一起用模擬器在玩 Sega Saturn 的老遊戲 <a href="https://en.wikipedia.org/wiki/Guardian_Heroes" target="_blank" rel="noopener">守護者列傳</a>，根據路線的選擇有<a href="http://sesesega.blog90.fc2.com/blog-entry-707.html" target="_blank" rel="noopener">五種結局</a>，要五種結局都跑過一次才能解鎖在競技場使用不死英雄</p><p>因為用文字敘述路線有點難懂，我就順便用 plantuml 畫了一下圖]</p><a id="more"></a><ul><li>路線是參考 <a href="http://guardianheroes.wiki.fc2.com/wiki/%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8%E4%B8%80%E8%A6%A7" target="_blank" rel="noopener">fc2.com 的 ガーディアンヒーローズ 攻略 Wiki</a></li><li>puml 檔： <a href="/2020/11/01-game/guardian_heros_routes.puml" title="guardian_heros_routes.puml">guardian_heros_routes.puml</a></li></ul><div style="width: 100%; margin: auto;"><img src="/2020/11/01-game/guardian_heros_routes.svg"></div><p>附註</p><ul><li>如果要解鎖競技場的人物，必須使用 Normal 以上的難度玩 Store mode</li><li>敵兵就算死了，只要在屍體落地消失以前持續攻擊，還是可以少量增加經驗值</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近跟兒子一起用模擬器在玩 Sega Saturn 的老遊戲 &lt;a href=&quot;https://en.wikipedia.org/wiki/Guardian_Heroes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;守護者列傳&lt;/a&gt;，根據路線的選擇有&lt;a href=&quot;http://sesesega.blog90.fc2.com/blog-entry-707.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五種結局&lt;/a&gt;，要五種結局都跑過一次才能解鎖在競技場使用不死英雄&lt;/p&gt;
&lt;p&gt;因為用文字敘述路線有點難懂，我就順便用 plantuml 畫了一下圖]&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Gralde build error</title>
    <link href="https://jchu.cc/2020/10/30-gradle.html"/>
    <id>https://jchu.cc/2020/10/30-gradle.html</id>
    <published>2020-10-30T08:34:37.000Z</published>
    <updated>2020-12-16T17:38:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 的 app moudle 裡面，嘗試把一些獨立的類別搬到新增加的一個 library module 的時候，遇到了類似這樣的錯誤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; The consumer was configured to find an API of a component, as well as attribute &apos;com.android.build.api.attributes.BuildTypeAttr&apos; with value &apos;debug&apos;, attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;. However we cannot choose between the following variants of project :common-libs:</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Library    +-------------+</span><br><span class="line">module     | common-libs |</span><br><span class="line">           +-------------+</span><br><span class="line">               ^</span><br><span class="line">               |</span><br><span class="line">               |</span><br><span class="line"> Base      +-------+</span><br><span class="line"> module    |  App  |</span><br><span class="line">           +-------+</span><br></pre></td></tr></table></figure><p>上圖，一開始只有 app depends on common-libs 這個 library module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           +-------------+</span><br><span class="line">           | common-libs |</span><br><span class="line">           +-------------+</span><br><span class="line">Library        ^</span><br><span class="line">module         |           +--------+</span><br><span class="line">               |           |my-utils|</span><br><span class="line">               |           +--------+</span><br><span class="line">               |              ^</span><br><span class="line">               |              |</span><br><span class="line"> Base      +-------+----------+</span><br><span class="line"> module    |  App  |</span><br><span class="line">           +-------+</span><br></pre></td></tr></table></figure><p>後來把 app 裡面的類別拉出來，放到 my-utils 裡面，這樣也沒問題</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           +-------------+</span><br><span class="line">           | common-libs |&lt;-----+</span><br><span class="line">           +-------------+      |</span><br><span class="line">Library        ^                |</span><br><span class="line">module         |           +--------+</span><br><span class="line">               |           |my-utils|</span><br><span class="line">               |           +--------+</span><br><span class="line">               |              ^</span><br><span class="line">               |              |</span><br><span class="line"> Base      +-------+----------+</span><br><span class="line"> module    |  App  |</span><br><span class="line">           +-------+</span><br></pre></td></tr></table></figure><p>但是 my-utils 開始用到 common-libs 裡面的東西，增加 <code>implementation project(&#39;:common-libs&#39;)</code> 的時候就開始出現類似下方的錯誤訊息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">== BUILD FAILED ==</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Could not determine the dependencies of task &apos;:my-utils:compileDebugKotlin&apos;.</span><br><span class="line">&gt; Could not resolve all task dependencies for configuration &apos;:my-utils:debugCompileClasspath&apos;.</span><br><span class="line">   &gt; Could not resolve project :common-libs.</span><br><span class="line">     Required by:</span><br><span class="line">         project :my-utils</span><br><span class="line">      &gt; The consumer was configured to find an API of a component, as well as attribute &apos;com.android.build.api.attributes.BuildTypeAttr&apos; with value &apos;debug&apos;, attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;. However we cannot choose between the following variants of project :common-libs:</span><br><span class="line">          - betaDebugAndroidTestCompile</span><br><span class="line">          - betaDebugAndroidTestRuntime</span><br><span class="line">          - betaReleaseUnitTestRuntime</span><br><span class="line">          .....(skip).....</span><br><span class="line">          - developDebugAndroidTestCompile</span><br><span class="line">          .....(skip).....</span><br><span class="line">          - productionReleaseRuntime</span><br><span class="line">          .....(skip).....</span><br><span class="line">        All of them match the consumer attributes:</span><br><span class="line">          - Variant &apos;betaDebugAndroidTestCompile&apos; capability My_App:common-libs:unspecified declares a component, as well as attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;:</span><br><span class="line">              - Unmatched attributes:</span><br><span class="line">                  - Doesn&apos;t say anything about com.android.build.api.attributes.BuildTypeAttr (required &apos;debug&apos;)</span><br><span class="line">                  - Doesn&apos;t say anything about its usage (required an API)</span><br><span class="line">                  - Provides attribute &apos;org.jetbrains.kotlin.localToProject&apos; with value &apos;local to :common-libs&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">          - Variant &apos;betaDebugAndroidTestRuntime&apos; capability My_App:common-libs:unspecified declares a component, as well as attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;:</span><br><span class="line">              - Unmatched attributes:</span><br><span class="line">                  - Doesn&apos;t say anything about com.android.build.api.attributes.BuildTypeAttr (required &apos;debug&apos;)</span><br><span class="line">                  - Doesn&apos;t say anything about its usage (required an API)</span><br><span class="line">                  - Provides attribute &apos;org.jetbrains.kotlin.localToProject&apos; with value &apos;local to :common-libs&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">          - Variant &apos;betaDebugApiElements&apos; capability My_App:common-libs:unspecified declares an API of a component, as well as attribute &apos;com.android.build.api.attributes.BuildTypeAttr&apos; with value &apos;debug&apos;, attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;:</span><br><span class="line">              - Unmatched attributes:</span><br><span class="line">                  - Provides attribute &apos;com.android.build.api.attributes.VariantAttr&apos; with value &apos;betaDebug&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">                  - Provides attribute &apos;default&apos; with value &apos;beta&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">          - Variant &apos;betaDebugRuntime&apos; capability My_App:common-libs:unspecified declares a component, as well as attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;:</span><br><span class="line">              - Unmatched attributes:</span><br><span class="line">                  - Doesn&apos;t say anything about com.android.build.api.attributes.BuildTypeAttr (required &apos;debug&apos;)</span><br><span class="line">                  - Doesn&apos;t say anything about its usage (required an API)</span><br><span class="line">                  - Provides attribute &apos;org.jetbrains.kotlin.localToProject&apos; with value &apos;local to :common-libs&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">          - Variant &apos;betaDebugRuntimeElements&apos; capability My_App:common-libs:unspecified declares a runtime of a component, as well as attribute &apos;com.android.build.api.attributes.BuildTypeAttr&apos; with value &apos;debug&apos;, attribute &apos;org.jetbrains.kotlin.platform.type&apos; with value &apos;androidJvm&apos;:</span><br><span class="line">              - Unmatched attributes:</span><br><span class="line">                  - Provides attribute &apos;com.android.build.api.attributes.VariantAttr&apos; with value &apos;betaDebug&apos; but the consumer didn&apos;t ask for it</span><br><span class="line">                  - Provides attribute &apos;default&apos; with value &apos;beta&apos; but the consumer didn&apos;t ask for it</span><br><span class="line"></span><br><span class="line">.....(skip).....</span><br></pre></td></tr></table></figure><p>訊息不是很容易懂，大致上原因為 <code>App</code> base module 裡面定義了一些 <code>productFlavors</code>，但是處理 <code>my-utils</code> module 時找不到對應的 flavor 就爆炸了。因為我有加上 <code>develop</code>, <code>beta</code>, <code>production</code> 等等的 flavor，所以在 <code>my-utils</code> 的 build.gradle 補上這一段就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> android &#123;</span><br><span class="line">     flavorDimensions <span class="string">"default"</span></span><br><span class="line">+</span><br><span class="line">+    productFlavors &#123;</span><br><span class="line">+        register(<span class="string">"develop"</span>)</span><br><span class="line">+        register(<span class="string">"beta"</span>)</span><br><span class="line">+        register(<span class="string">"production"</span>)</span><br><span class="line">+    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android 的 app moudle 裡面，嘗試把一些獨立的類別搬到新增加的一個 library module 的時候，遇到了類似這樣的錯誤&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; The consumer was configured to find an API of a component, as well as attribute &amp;apos;com.android.build.api.attributes.BuildTypeAttr&amp;apos; with value &amp;apos;debug&amp;apos;, attribute &amp;apos;org.jetbrains.kotlin.platform.type&amp;apos; with value &amp;apos;androidJvm&amp;apos;. However we cannot choose between the following variants of project :common-libs:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
    <category term="gradle" scheme="https://jchu.cc/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 觀察 Sqlite Database</title>
    <link href="https://jchu.cc/2020/09/02-sqlscout.html"/>
    <id>https://jchu.cc/2020/09/02-sqlscout.html</id>
    <published>2020-09-02T14:03:07.000Z</published>
    <updated>2020-09-02T13:29:41.558Z</updated>
    
    <content type="html"><![CDATA[<p>最近在改一個 open source 記帳 App，其實也只是隨便亂改一通，讓它的 UI 看得順眼且堪用而已。修改的過程中需要查詢 App 裡面用到的 SQLite db，所以搜尋到一個 SQLScout 的 IDEA IDE Plugin，覺得滿好用，順手紀錄一下用法。</p><a id="more"></a><p>首先在 <a href="https://www.idescout.com/sqlscout/" target="_blank" rel="noopener">SQLScout 的網頁</a>就能看見它強調這個 plugin 沒有 open source，可能有些人比較在意，在此先提醒一下。</p><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><div style="max-width: 100%; margin: auto;"><img src="/2020/09/02-sqlscout/sqlscout.jpg"></div><p>安裝很簡單，打開 Android Studio 的設定，搜尋 Plugin 的關鍵字，安裝完之後重開就行了。</p><h2 id="從手機下載-database-到-host"><a href="#從手機下載-database-到-host" class="headerlink" title="從手機下載 database 到 host"></a>從手機下載 database 到 host</h2><div style="max-width: 100%; margin: auto;"><img src="/2020/09/02-sqlscout/download_db.jpg"></div><ul><li>App 先編譯成 debuggable，這樣才能取出 database 的資料</li><li>Android Studio 右邊會多出一個 SQLite Explorer 的 Tab，點一下就能打開上圖的畫面</li><li>點「+」好，選「Android (Download Database Locally)」就能 dump 一個資料庫檔案，存到自訂的目錄</li></ul><h2 id="Table-Data"><a href="#Table-Data" class="headerlink" title="Table Data"></a>Table Data</h2><div style="max-width: 100%; margin: auto;"><img src="/2020/09/02-sqlscout/table.jpg"></div><p>資料庫下載完之後，馬上就能看見所有的 Table。還能夠直接修改 Table 裡面的數值，再上傳回手機裡面</p><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><div style="max-width: 100%; margin: auto;"><img src="/2020/09/02-sqlscout/console.jpg"></div><p>還有 Console 能夠使用，直接輸入 SQL 指令，附帶 auto complete，指令敲完以後點左邊的綠色執行鈕就好，很方便</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在改一個 open source 記帳 App，其實也只是隨便亂改一通，讓它的 UI 看得順眼且堪用而已。修改的過程中需要查詢 App 裡面用到的 SQLite db，所以搜尋到一個 SQLScout 的 IDEA IDE Plugin，覺得滿好用，順手紀錄一下用法。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>實作 Google Authenticator 的兩階段驗證</title>
    <link href="https://jchu.cc/2020/08/16-twofactor.html"/>
    <id>https://jchu.cc/2020/08/16-twofactor.html</id>
    <published>2020-08-15T18:22:34.000Z</published>
    <updated>2020-08-26T05:29:07.305Z</updated>
    
    <content type="html"><![CDATA[<p>之前聽到 Tim 說 PTT 的現有的登入方式不改的話很沒救，我想到兩階段驗證的方法，所以好奇研究了一下該怎麼做。實際上看了才知道比想像中簡單，PTT 有意願的話，實作難度真的不高。</p><p>Google Authenticator (後面簡稱 GA)是常見的兩階段驗證(2FA)會用到的程式，好比 GitHub 或是 Facebook 的兩階段驗證都能用這隻程式取得驗證碼。如果你的網站服務想要利用 2FA 增加安全性，利用 GA 可以算是非常便宜的方案 - 不需要自己寫 client App，只要自己的網站加上一些簡單的流程與演算法就能取得 2FA 的優點。</p><p>本文簡介如何實作，並且附上驗證的程式。</p><a id="more"></a><p>要實作 GA 的 2FA，核心的部分只要弄好三個東西</p><ul><li>RFC4226：HOTP: An HMAC-Based One-Time Password Algorithm 的實作</li><li>RFC6238：TOTP: Time-Based One-Time Password Algorithm 的實作</li><li>Base32 的編碼演算法</li></ul><p>其中 RFC6238 其實是基於 RFC4226 的實作，只是拿時間當變數而已，所以搞定 RFC4226 就沒什麼大問題，以下拿 Kotlin 語言，依序介紹三者如何實作。<em>(其實我覺得看圖可能就懂了)</em></p><h1 id="準備"><a href="#準備" class="headerlink" title="準備"></a>準備</h1><p>2FA 的概念是，使用者登入的時候除了輸入密碼，還要用私人擁有的裝置(手機)顯示一個隨機變動的數字，登入時提供給 Server 以宣稱「我除了知道密碼，還知道一個只有我手機才會產生的數字」，以此提昇帳號的安全性。要做到後者，Client 跟 Server 之間一定要共享某一個 Key，還有一個不斷變動的 Counter ，由這兩個參數生出隨機亂數。</p><p>因此在起始 2FA 流程的時候，網站首先要給使用者產生隨機的文字當做 Key，以下都拿經典的台詞 <strong>GoAheadMakeMyDay</strong> 當做產生出來的 Key，後面的程式碼會用到的 <strong>key</strong> 都是這個字串。</p><p>把這串 Key 的 ascii 直接轉成 byte 會拿到 <code>[47 6f 41 68 65 61 64 4d 61 6b 65 4d 79 44 61 79]</code></p><h1 id="RFC4226"><a href="#RFC4226" class="headerlink" title="RFC4226"></a>RFC4226</h1><p>以下稍微解釋 RFC 裡面講的東西，沒耐心的可以跳到下一節</p><p>RFC 的標題就是 HOTP: An HMAC-Based One-Time Password Algorithm。MAC, Message Authentication Code 是用來驗證訊息的另外一串比較短的訊息，HMAC 則是基於 hash function 的 MAC。舉例來說 HMAC-MD5 就是我們常用的 md5，對於一個大的檔案，產生一個比較小的 hash code (MAC)，可以用來驗證原來的大檔案有沒有出錯。</p><p>RFC4226 的第五章講演算法，看完就知道怎麼實作了。但是要用在自家服務上的人，至少要把第六章也看完，才會知道 RFC4226 要基於哪些條件才會有安全性。不過我這篇短文，聚焦在演算法就好</p><p>Section 5.1 有些簡單的名詞解釋</p><ul><li><p>C: 8 bytes 的 counter value，又稱 moving factor，HOTP generator (client，也就是使用者手上的手機) 跟 HOTP validator (server) 要同步這個值。譬如說兩邊可以用 1, 3, 5, 7 的奇數遞增，或是 100, 200, 300…，反正兩邊有共識就行了。(如果你很聰明地拿「時間」來當兩邊同步的基準，就是 RFC6238 的 TOTP 囉！)</p></li><li><p>K: shared secret，長度至少要 128 bits，也就是上面假設的 key (GoAheadMakeMyDay)</p></li><li>T: throttling parameter，嘗試 T 次失敗之後會拒絕連線 (總不能讓黑鬼無限制地猜下去吧！)</li></ul><p>K, C 都是 high order byte first，產生出來的都是 big endian，也就符合我們平常的習慣</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</span><br></pre></td></tr></table></figure><ol><li>HS = HMAC-SHA-1(K,C) - HS 就是 HMAC-SHA-1，長度為 20 bytes</li><li>產生一個 4 bytes 長度的值：Sbits = DT(HS) - DT 會回傳一個 31 bits String</li><li>Snum = StToNum(Sbits) - 把 S 轉成一個數字，範圍是 0 ~ 2^31 -1</li><li>回傳 D = Snum mod 10^Digit - D 也是一個數字，範圍是 0 ~ 10^D - 1</li></ol><p>DT 是為了要從 160 bits 之中取出 4 bytes dynamice binary code</p><p>DT: 當 String = String[0] ~ String[19] 時，OffsetBits 就是 lower order 4 “bits”，也就是 String[19] 的最後 4 bits (if String[19] = 0x4A, offset 就是 0xA)<br>Offset = StToNum(OffsetBits) // <code>0 &lt;= Offset &lt;= 15</code><br>接著 P = String[Offset]…String[Offset + 3]<br>最後再回傳 P 的最後 31 bits</p><p>取最後 31 bits 的原因是要避免 signed 與 unsigned 的問題</p><p>實作最後至少要回傳 6 位數，依照情況也可以是 7 或 8 位數</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int offset   =  hmac_result[19] &amp; 0xf ;                // 取出 offset</span><br><span class="line">int bin_code = (hmac_result[offset]  &amp; 0x7f) &lt;&lt; 24     // 從 offset 開始取出 4 bytes</span><br><span class="line">   | (hmac_result[offset+1] &amp; 0xff) &lt;&lt; 16</span><br><span class="line">   | (hmac_result[offset+2] &amp; 0xff) &lt;&lt;  8</span><br><span class="line">   | (hmac_result[offset+3] &amp; 0xff) ;</span><br></pre></td></tr></table></figure><h2 id="RFC4226-演算法"><a href="#RFC4226-演算法" class="headerlink" title="RFC4226 演算法"></a>RFC4226 演算法</h2><p>這節直接演練一次如何計算出 RFC4226 期待的結果</p><ol><li>準備一個 C (Counter value), 8 Byte 在 Kotlin 就是型別 Long 的變數，假設 Counter 為 <code>65535</code></li><li><code>65535</code> 就是 <code>0xFFFF</code>，轉成長度為 16 的 hex String 就是 <code>000000000000FFFF</code></li><li>把這個字串轉成 Byte Array，等下計算 SHA1 會用到。最後轉成 <code>[00 00 00 00 00 00 FF FF]</code> 的 8 Bytes array</li><li>把 <code>GoAheadMakeMyDay</code> 轉成 Ascii 的 byte array，拿到 <code>[47 6f 41 68 65 61 64 4d 61 6b 65 4d 79 44 61 79]</code></li><li>拿 Counter 以及 Key 的兩個 Array 計算出 SHA1 值，SHA1 值是 Digest，也就是 RFC 裡面的 <code>hs</code>。以我們的例子，最後計算出的 <code>hs[] = [16 66 4A 59 58 57 E2 55 22 DC A3 1B 97 A9 C4 B5 7E D7 77 25]</code></li></ol><p>Digest 一定是長度 20 bytes Array。別人弱水三千只取一瓢，這邊 20 bytes 也只需要 4 bytes</p><ol><li>取出 array 的最後一個 byte (hs[19])，進行 <code>AND 0x0F</code> 運算，得到一個絕對在 0 ~ 15 之間的數字，這個數字是 offset - 現在得到 <code>offset = 5</code></li><li>在 hs 裡面以 offset 當位移取出 4 bytes <code>[57 E2 55 22]</code> (hs[5] ~ hs[8])，得到一個 4 bytes 的數字</li><li>拿掉第一個 bit (<code>&amp; 0x7FFFFFFF</code>)，避免正負號的問題 - 最後拿到一個整數 <code>1474450722</code></li><li>開始 truncate，如果只需要 6 位數，最後的結果就是 <code>450722</code></li></ol><div style="max-width: 100%; margin: auto;"><img src="/2020/08/16-twofactor/hotp_flow.svg"></div><h1 id="RFC6238"><a href="#RFC6238" class="headerlink" title="RFC6238"></a>RFC6238</h1><p>聰明的你一定馬上就想到可以拿「當下的時間」當做理應要不斷變動的 Counter Value。是的，這就是 RFC 6238 在做的事情，只是它用的單位叫做 Steps</p><ul><li>以一個 T0 當做起始的秒數</li><li>每 X 秒當做一個 Step (預設是 30 秒)</li><li>現在的時間，減掉 T0 之後，共有多少 Steps？就是現在的 Steps</li></ul><p>我們要實作給 GA，所以</p><ul><li>T0 就是 January 1, 1970 00:00:00.0 UTC.</li><li>X 是 30</li><li>所以就是很簡單地，<code>currentTimeMillis()</code> 取得 Millis 後除以 1000，再除以 30，丟給 RFC4226 就搞定囉</li></ul><p>換句話說，如果 client 的時間不準，或說沒跟 Server 同步，兩邊就會對不起來了，這算是 GA 的限制吧。</p><div style="max-width: 100%; margin: auto;"><img src="/2020/08/16-twofactor/totp_flow.svg"></div><h1 id="Bas32-生出-GA-用的-URI"><a href="#Bas32-生出-GA-用的-URI" class="headerlink" title="Bas32 (生出 GA 用的 URI)"></a>Bas32 (生出 GA 用的 URI)</h1><p>這個反而比較麻煩一點。不能直接拿 Key <code>GoAheadMakeMyDay</code> 餵給 GA，要先轉成 Base32 的字串。因為不是常見的 Base64，所以最後我也是自己實作一份。Base32 的演算法如下</p><ol><li>把字串轉成 byte array</li><li>每 5 個 bits 分成一組，最後不足 5 bits 的餘位，補上 0 成為 5 bits</li><li>2 的 5 次方就是 32， 把每個數字拿去映射長度為 32 的列表 <code>&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, .... &#39;Y&#39;, &#39;Z&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;</code>. (沒有 1，可能是怕跟大寫 I 混淆)</li><li>得到字串之後，最後補上等號 <code>=</code>，直到字串的長度為 8 的倍數，這就是能餵給 GA 的 Secret</li><li><code>GoAheadMakeMyDay</code> 會得到 <code>I5XUC2DFMFSE2YLLMVGXSRDBPE======</code></li></ol><p>如果不想在 GA 裡面手動輸入這串字，就要生出一個 URI，格式為</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otpauth://totp/foobar?digits=6&amp;issuer=TEST&amp;secret=I5XUC2DFMFSE2YLLMVGXSRDBPE======</span><br></pre></td></tr></table></figure><p>拿這個 URI 去轉成 QR code，就能用 GA 掃描的方式輸入</p><div style="max-width: 100%; margin: auto;"><img src="/2020/08/16-twofactor/ga_secret.svg"></div><h1 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h1><p>如果對實作有興趣，可以看看我這很簡單的 Kotlin 版本: <a href="/2020/08/16-twofactor/twofactor.zip" title="twofactor.zip">twofactor.zip</a>，基本上就三個檔案分別是 HOTP, TOTP 與 Base32 的實作，還有 Unit Test 當做使用範例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前聽到 Tim 說 PTT 的現有的登入方式不改的話很沒救，我想到兩階段驗證的方法，所以好奇研究了一下該怎麼做。實際上看了才知道比想像中簡單，PTT 有意願的話，實作難度真的不高。&lt;/p&gt;
&lt;p&gt;Google Authenticator (後面簡稱 GA)是常見的兩階段驗證(2FA)會用到的程式，好比 GitHub 或是 Facebook 的兩階段驗證都能用這隻程式取得驗證碼。如果你的網站服務想要利用 2FA 增加安全性，利用 GA 可以算是非常便宜的方案 - 不需要自己寫 client App，只要自己的網站加上一些簡單的流程與演算法就能取得 2FA 的優點。&lt;/p&gt;
&lt;p&gt;本文簡介如何實作，並且附上驗證的程式。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin coroutine 基礎筆記</title>
    <link href="https://jchu.cc/2020/03/22-coroutine.html"/>
    <id>https://jchu.cc/2020/03/22-coroutine.html</id>
    <published>2020-03-22T13:59:50.000Z</published>
    <updated>2020-08-26T05:29:07.302Z</updated>
    
    <content type="html"><![CDATA[<p>Coroutine 算是 Kotlin 裡面相當引人注目的功能，簡單來說就是可以幫助處理非同步需求的機制。</p><p>舉例來說，我們常常看到這樣的需求：按下一個 Fetch 的按鈕，去抓網路上的某個列表來更新手機內的資料，同時又不希望 UI thread 被卡住。在 Android 上面經常就是祭出 AsyncTask，或是用 Rx 的方式來處理。利用 Coroutine，這些功能都會變得比較簡單實作</p><a id="more"></a><p>Coroutine 用起來很簡單，但是鑽進去實作之後發現裡面錯綜複雜，很多東西看到後面我開始懷疑自己的理解，甚至要懷疑自己人生。這邊只會記錄我的粗淺理解，不寫下來就很容易忘記，未來還會繼續更新這裡。</p><ul><li><a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055" target="_blank" rel="noopener">Coroutine Context and Scope - Roman Elizarov</a> - Kotlin libraries Tech Lead 寫的文章，同樣還有好多篇都值得看一下</li><li><a href="https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad" target="_blank" rel="noopener">Demystifying CoroutineContext</a> - 這篇也有講到一些內部實作的東西，值得看一下</li><li><a href="https://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">协程的历史，现在和未来</a> - 習慣用 thread 的人，很推薦看一下這篇故事，了解 coroutine 的起源</li></ul><blockquote><p>最早提出“协程”概念的 Melvin Conway 的出发点，也是如何写一个只扫描一遍程序 (one-pass) 的 COBOL 编译器….<br>在 Conway 的设计里，词法和语法解析不再是两个独立运行的步骤，而是交织在一起。编译器的控制流在词法和语法解析之间来回切换…<br>简言之，协程的全部精神就在于控制流的主动让出和恢复</p></blockquote><p>我們知道 Process 跟 Thread 的切換由作業系統負責，執行一段時間的程式碼被作業系統中斷，切換到另外一個 Process 或是 Thread。而 Coroutine 的精神則是程式碼執行到一個程度時，向 Scheduler 說：「我 OK，<del>你先領</del>下一位」。這部份的調度發生在 user space 裡面，從作業系統的角度來看，看不見「切換 coroutine」這件事情。</p><p>用比較不精確的想像，就是 Kotlin 利用了 syntax sugar 讓你寫出看似循序執行的程式碼，但是實際上程式碼被切碎，放進一堆 coroutines 裡面。這些 coroutines 依照能夠被預測的順序放進 thread 裡面執行。</p><p>用一開頭的例子，按下 fetch 鈕之後，透過 <code>launch</code> 產生一個 coroutine，繁重的工作放在裡面，所以最後那行 log 能在 coroutine 的工作完成以前就被執行到。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetchButton.onClickListener &#123; view -&gt;</span><br><span class="line">    currentScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> list = fetchListFromServer()</span><br><span class="line">        updateLocal(list)</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>「產生一個 coroutine」這句話困擾了我很久，到底產生了什麼東西？在 <code>Builders.common.kt</code> 裡面可以窺見</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LazyStandaloneCoroutine</code> <code>StandaloneCoroutine</code> 就是生出的 Coroutine，我們包在 launch 裡面的那些程式碼，就是 <code>block</code></p><h3 id="CoroutineScope-CoroutineContext"><a href="#CoroutineScope-CoroutineContext" class="headerlink" title="CoroutineScope / CoroutineContext"></a>CoroutineScope / CoroutineContext</h3><p>追程式碼的時候會不斷看到這幾個詞，追程式碼的時候甚至看到 CoroutineScope 就是超簡單的 interface，直接包著 CoroutineContext</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兩者看起來幾乎等價。Roman 的講法是：「The difference between a context and a scope is in their intended purpose.」，我目前的理解為</p><ul><li>CoroutineContext 用來提供每個 Coroutine 執行的資訊 (Job, CoroutineExceptionHandler…這些實作 CoroutineContext.Element 的類別)</li><li>CoroutineScope 定義了 coroutines 之間的階層關係，透過 CoroutineScope 的 functions 建構 coroutine 的同時，也會把 parent-child 關係安排好</li></ul><div style="max-width: 500px; margin: auto;"><img src="/2020/03/22-coroutine/coroutine_scopes_by_elizavor.png" title="source:https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055"></div><p>借用一下 Roman 的圖。Kotlin Coroutine 的實作用了大量的 extension functions，最常用的 <code>CoroutineScope.launch</code> 也是其一。上圖可以看到 Parent 包著 Child scope，這也是 scope 的重要特性：當 Parent scope 被取消的時候，child scope 也會一併被取消。</p><p>上面還有個重要的訊息，就是從 context <code>A</code> launch 一個新的 coroutine <code>B</code>，但是 <code>B</code> 的 parent context 不一定是 <code>A</code>。因為 launch 能指定 additional context (也就是 function signature 裡面的 <code>context</code>)，這也可能成為 parent-context。這也是為什麼 launch function 的預設 context 是 <code>EmptyCoroutineContext</code>。</p><h3 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h3><p>前面提到了 parent scope 停掉的時候，child scope 也會停掉，所以確認你的 coroutine 掛在正確的 scope 底下很重要。尤其 Android 裡面，經常有 Activity/Fragment 被關掉的機會，如果畫面都被關掉了，有些操作就該被停止。</p><p>所以 Android architecture 就提供了幾個 <a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">coroutine scope</a> 幫你處理瑣事。只要是從正確的 scope 發起的 coroutine，在 Activity / Fragment 關閉的時候，會記得幫你取消 child scope 裡面的 coroutine</p><p>而 <code>GlobalScope</code> 則是一個 singleton class，它的生命週期會長於 activity，沒有很確定自己在做什麼，盡量不要透過它生出 coroutine。</p><h3 id="Suspend-function"><a href="#Suspend-function" class="headerlink" title="Suspend function"></a>Suspend function</h3><p><code>suspend</code> 本身只是一個 modifier，實作放在 Suspend.kt 裡面。會由 compiler <a href="https://stackoverflow.com/questions/47871868/what-does-suspend-function-mean-in-kotlin-coroutine/52925057#52925057" target="_blank" rel="noopener">做真正的工作</a>，把標示 suspend 的 function 轉成另外一個樣子，將 <code>Continuation&lt;T&gt;</code> 塞進 function signature 裡面。</p><p>實作的運作邏輯我還沒摸清楚，只從使用的角度來看，標示了 <code>suspend</code> 的 function，意思就是執行到這個 function 的時候，能夠讓出控制流給其他 coroutine。也就是這些 function 都會說：「我 OK，(有需要的話)你先請」，自己走到後面重新排隊</p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>來看一點簡單的範例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"1"</span>)</span><br><span class="line">launch &#123;</span><br><span class="line">    println(<span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"2"</span>)</span><br><span class="line">launch &#123;</span><br><span class="line">    println(<span class="string">"5"</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"3"</span>)</span><br></pre></td></tr></table></figure><p><code>launch</code> 會產生一個新的 coroutine，整個執行會依序印出數字 1 ~ 5。</p><p>底下是(拔掉 <code>runBlock</code>) 簡化之後的範例。因為 foo 是 suspend function，執行到 <code>delay</code> 會讓出控制權，所以印出來的數字會是 <code>1 2 3 4 foo 5 6</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">suspendTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"1"</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">"4"</span>)</span><br><span class="line">        foo(<span class="string">"foo"</span>)</span><br><span class="line">        println(<span class="string">"6"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"2"</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">"5"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(param: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1</span>)</span><br><span class="line">    println(param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把情況弄得再複雜一點</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">traceSequence</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"1"</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">"5"</span>)</span><br><span class="line">        foo(<span class="string">"a"</span>)</span><br><span class="line">        println(<span class="string">"8"</span>)</span><br><span class="line">        foo(<span class="string">"c"</span>)</span><br><span class="line">        println(<span class="string">"10"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"2"</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">"6"</span>)</span><br><span class="line">        foo(<span class="string">"b"</span>)</span><br><span class="line">        println(<span class="string">"9"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"3"</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        println(<span class="string">"7"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>印出來的結果會是 <code>1 2 3 4 5 6 7 a 8 b 9 c 10</code>，印出 “c” 之前那個 coroutine 會讓出控制權，讓 “b” 先被印出</p><p>前面的結果可以觀察到，coroutine 雖然讓程式碼的執行變成非同步，但是運作的順序還是可以預測，不像 thread 或 process。coroutine 的概念就像是排隊買口罩，某一家的人可能會跑到隊伍後面重新排起。</p><p>這又引入了另外一個問題，如果我產生了兩個 coroutines，它們都很溫馨地跑到隊伍後面重排，但是排在前面的 coroutine 動作很慢的話，會不會卡到後面的？</p><p>我在 local 跑起了一個 server，向它發 GET request 會等五秒才回應，接著寫了一個非 suspend function</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這個 function 會花五秒才 return</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRemoteServer</span><span class="params">(param: <span class="type">String</span> = <span class="string">"?"</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> url = URL(<span class="string">"http://localhost:8000/"</span>)</span><br><span class="line">    <span class="keyword">val</span> urlConnection: HttpURLConnection = url.openConnection() <span class="keyword">as</span> HttpURLConnection</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedInputStream(urlConnection.inputStream).read()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        urlConnection.disconnect()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"done(<span class="variable">$param</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">traceRemoteCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">"1"</span>)</span><br><span class="line">        launch &#123;      <span class="comment">// coroutine a</span></span><br><span class="line">            println(<span class="string">"4"</span>)</span><br><span class="line">            getRemoteServer(<span class="string">"a"</span>)</span><br><span class="line">            println(<span class="string">"5"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"2"</span>)</span><br><span class="line">        launch &#123;      <span class="comment">// coroutine b</span></span><br><span class="line">            println(<span class="string">"6"</span>)</span><br><span class="line">            getRemoteServer(<span class="string">"b"</span>)</span><br><span class="line">            println(<span class="string">"7"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"3"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後印出的結果是 <code>1 2 3 4 done(a) 5 6 done(b) 7</code> 耗時 10 秒。雖然 3 很快地被印出來，但是 a 的動作很慢，一定要跑完 coroutine a 才有機會跑到 6</p><p>如果把 getRemoteServer 換成 suspend function 並且跑在別的 dispatcher 底下，情況就變得更複雜了。以後有空再寫吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Coroutine 算是 Kotlin 裡面相當引人注目的功能，簡單來說就是可以幫助處理非同步需求的機制。&lt;/p&gt;
&lt;p&gt;舉例來說，我們常常看到這樣的需求：按下一個 Fetch 的按鈕，去抓網路上的某個列表來更新手機內的資料，同時又不希望 UI thread 被卡住。在 Android 上面經常就是祭出 AsyncTask，或是用 Rx 的方式來處理。利用 Coroutine，這些功能都會變得比較簡單實作&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Witcher 3 昆特牌基本教學</title>
    <link href="https://jchu.cc/2019/12/19-gwent.html"/>
    <id>https://jchu.cc/2019/12/19-gwent.html</id>
    <published>2019-12-19T13:11:47.000Z</published>
    <updated>2020-08-15T13:10:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>昆特牌是 Witcher 3 裡面的一個小遊戲。雖然非常喜歡 Witcher 3，但我剛開始玩的時候覺得要學很多東西太複雜，所以就跳過了這個部份的教學，任何昆特牌相關的東西都不玩。後來遊戲上手了，回頭玩昆特牌開始上癮，卻因為跳過一些任務無法完整收集昆特牌，只好在二周目重來一次。</p><p><strong>我的昆特牌癮又發作啦～</strong></p><p>拿著雙劍周遊各地的傳奇白狼傑洛特，除了幫助一些可憐的底層人民，偶爾還會拿著強力的牌組欺壓市井小民。我覺得這樣的設定很有趣，也是我特別喜歡在遊戲裡頭找 NPC 打牌的原因。昆特牌的規則很簡單，只是遊戲裡面的說明不好懂，我試著用我覺得清晰的方式再解說一遍。</p><a id="more"></a><h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p>先講一下遊戲進行的方式，有個大致的輪廓之後在慢慢進入規則。</p><p>遊戲的流程就是</p><ol><li>雙方從各自的牌堆抽出十張任意手牌，遊戲開始前可以換三張牌</li><li>雙方輪流出牌</li><li>直到手牌出盡，或是雙方決定不再出牌之後，結束該局，清算桌面上的總點數，點數高者取得該局</li><li>三戰兩勝制，取得兩局者獲勝</li></ol><p>有了輪廓，接著細說一些大項的規則</p><ol><li><strong>三戰兩勝的比大小遊戲</strong>：首先，昆特牌就是一個累積點數比大小的遊戲，每一局結尾的時候，加總桌面上的點數，點數大者取得該局。其次，每一場有三局，只要三戰兩勝就算獲勝，最基礎的規則就是這樣簡單。</li><li><strong>十張(可能更多)牌分配到三局</strong>：每一場開賽的時候，會從自己的牌堆裡面抽十張牌出來，你要用這十張牌完成三局，取得兩局的勝利。根據各種效果的影響，手牌可能總數會超過十張，暫時不討論這點。總之就是十張(或以上)的牌，你要思考怎樣分配到三局之中，取得最大的勝利。</li><li><strong>雙方輪流出牌，每局只能 Pass(跳過回合) 一次</strong>：有時玩家先攻，有時 NPC 先攻，但出牌一定是雙方輪流。某方選擇 Pass 之後，那一局某方就不能再做任何動作。接著另方繼續出牌，直到另方手牌出盡，或是另方也選擇 Pass，該局就結束，清算點數；另外，雙方輪流出牌的過程中，其中一方手牌出盡便成為自動 Pass 的狀態</li></ol><p>這邊就可以小結一下策略。</p><p>在三戰兩勝的比賽中，在第一局就出完十張手牌大殺對手之後，後面兩局進入無牌可出的窘境，必定敗北。也能採取各種戰法，好比在某一局利用點數小的牌，消耗對方的好牌，故意落敗之後，在另外兩局輕易獲勝。甚至利用牌組的特性，讓己方的手牌多於對手，在末局盡情凌虐對方。在點數競爭的基礎上，控制手牌的數量，消耗對方的手牌數量，大概就是昆特牌的重點。</p><div style="max-width: 400px; margin: auto;"><img src="/2019/12/19-gwent/pic_01.jpg"></div><h1 id="點數計算"><a href="#點數計算" class="headerlink" title="點數計算"></a>點數計算</h1><p>每一局都是比大小的遊戲，桌面上敵我雙方的點數總和來決定勝負。同樣由淺入深來講解，每一張牌最基礎的資訊有兩樣 1) 攻擊力，也就是這張牌的點數 2) 位置</p><p>除了特例之外，每張牌都有固定放置的位置。位置總共有近中遠三種射程，近是「近戰」，以一把劍為符號；中是「遠程」，以弓作為符號；遠是「攻城」，以投石車作為符號。打出一張牌之後，便依照該牌的特性，放到對應的位置。局末結算點數的時候，是把遠中近三欄加總作為最後的點數。有些特別的牌，同時能放在兩種位置，出牌時你可以依據當下的情況靈活選擇。</p><div style="max-width: 500px; margin: auto;"><img src="/2019/12/19-gwent/pic_02.jpg"></div><p>以上圖為例，維蘭特雷坦梅斯是點數為 7 的近戰牌，鏡子大師剛特歐迪姆是點數 4 的遠程牌，歐吉爾德點數為 6，可以放在近戰或遠程。</p><p>額外提一下，每張牌除了點數、射程之外，還有一個符號代表特殊能力。上面三張牌由左至右是，骷顱頭代表的「焚燒」，加號代表的「士氣提升」以及兩個人像代表的「呼喚」，特殊能力的正式名稱我忘了。但我們後面再仔細介紹，現在還不用管他</p><div style="max-width: 100%; margin: auto;"><img src="/2019/12/19-gwent/pic_03.jpg"></div><p>上圖是局末的狀況，裡面有很多細節能講，如果只看我們前面提過的東西，就是</p><ol><li>敵方近戰 32 點，遠程 7 點，攻城 74 點，總計 113 點</li><li>我方近戰 53 點，遠程 31 點，攻城 46 點，總計 130 點，此局我方勝</li><li>左側紅色寶石原本該有兩顆，但雙方只剩一顆，代表雙方各輸一局，所以這是一勝一敗之後的第三局</li><li>敵方已經 Pass，雙方各剩一張手牌</li></ol><h1 id="特殊能力"><a href="#特殊能力" class="headerlink" title="特殊能力"></a>特殊能力</h1><p>雙方抽牌比大小，僅僅只是如此便會太單調。於是許多牌都會有不同的特殊能力，各式各樣的特殊能力會讓戰局有所變化，豐富紙牌遊戲的過程。</p><h2 id="地形牌"><a href="#地形牌" class="headerlink" title="地形牌"></a>地形牌</h2><p>有些牌本身沒有攻擊力，只會對某一欄的牌產生效果，使用過後馬上作廢進入墓地。地形牌打出去之後會同時影響敵我雙方，重複打出同樣的地形牌並不會使得效果疊加。</p><ul><li>霜霰 - 所有近戰單位的點數都變成 1，譬如說你有三張拿劍的牌在場上，點數分別是 3, 5, 7。出現這張牌之後，三張都會變成 1, 1, 1</li><li>濃霧 - 類似霜霰，但影響的是拿弓的遠程單位</li><li>地形雨 - 類似霜霰，但影響的是投石車的攻城單位</li><li>晴天 - 打出這張牌之後，取消以上三種地形效果</li></ul><h2 id="特殊效果"><a href="#特殊效果" class="headerlink" title="特殊效果"></a>特殊效果</h2><ul><li>領導號角 - 可以放置在任何一列，每列只能放一張，該列的所有點數乘 2。譬如說該列的攻擊力是 3, 5, 7，配合領導號角之後變成 6, 10, 14。如果同時有地形牌，則是先變一再乘二，結果是 2, 2, 2</li><li>誘餌 - 把桌面上已經打出的一張手牌，重新收起來放回手裡。透過這張牌，可以騙對方打出強力的牌，或是回收使用過的牌再重複使用特殊能力，又或是偷取對方打出的間諜牌</li></ul><div style="max-width: 500px; margin: auto;"><img src="/2019/12/19-gwent/pic_04.jpg"></div><p>打出一張領導號角讓攻擊力加倍</p><h2 id="英雄牌"><a href="#英雄牌" class="headerlink" title="英雄牌"></a>英雄牌</h2><p>英雄牌的人物，往往是在這片大陸上享有盛譽，被當成英雄傳頌者。辨別卡片的方式是，該卡片的攻擊力/點數的圖案為黑色背景，好比底下這三張都是英雄牌</p><div style="max-width: 500px; margin: auto;"><img src="/2019/12/19-gwent/pic_05.jpg"></div><p>英雄牌的能力就是「完全不受戰場上其他效果影響」，不管是正面或負面的效果，所以</p><ul><li>地形牌沒辦法削減點數到一</li><li>領導號角無法讓點數加倍</li><li>士氣提升無法讓點數加一</li><li>燒灼無法摧毀英雄牌</li><li>醫療無法復活英雄牌</li><li>誘餌無法換下英雄牌</li></ul><p>總之就是打出去之後，該局的點數就穩當地加上了該英雄牌的攻擊力，接著任何效果都可以無視這張牌的存在。</p><h2 id="單位特殊能力"><a href="#單位特殊能力" class="headerlink" title="單位特殊能力"></a>單位特殊能力</h2><p>除了特殊效果的牌與天氣牌，最多的就是一般的單位牌，或說普通牌。但是許多單位牌其實也有特殊能力，左右著戰局發展，我只稍微寫幾個效果</p><ul><li>醫療：符號是一個愛心加上一個十字，從廢牌堆裡再抽一張單位牌出來，等於就是復活術。譬如說在上一局用了一張點數為 10 的牌，該局結束之後進了廢牌堆，用這個能力可以拿出來再用一次。而且，如果該單位牌有特殊能力，也還能再重複使用一次特殊能力。</li><li>士氣提升：符號是一個十字，把那一列的其他單位牌的點數加一，代表人物是最會打嘴砲的丹德里恩</li><li>燒灼：符號是長著兩隻角的骷顱頭，滿足條件之後把對象送進廢牌堆。可能是一次做掉一張對方的牌，或是我方的牌 (淚)，或是「一堆牌」</li><li>間諜：符號是一個眼睛，相當強力的牌。打出的間諜牌會跑去對方陣營，但是你可以從牌堆再抽兩張手牌。在這個手牌數目強烈影響勝率的遊戲裡面，滿手的間諜牌往往代表不敗。</li><li>招喚：符號是兩個穿著盔甲人，打出之後，把手牌或是未抽牌堆裡面同名的牌一併打出。運氣不好會快速消耗自己的手牌，運氣好就是賺到好幾張牌堆裡面的牌，通常是怪物牌組在使用</li></ul><p>其他還有很多效果，我只打算寫最簡單的入門，所以不打算完全列出。如果你看懂上述的規則，腦中大概可以演繹出一些基本的戰術</p><p>譬如說，在某一局裡面盡情打出間諜牌，輸掉該局也沒關係，製造雙方手牌數量的巨大差異之後，下一局盡情凌虐無牌可出的 NPC；或是準備一堆稻草人誘餌，不斷地偷對方的間諜牌，雙方來個間諜大戰累積手牌，搞到第三局的時候手牌還有十幾張。又或著面對怪物牌組的對手，雖然在近戰單位塞了十幾張牌拿到了巨大的攻擊力，但打出一張霜霰讓牠們全部變成一點，再出一張燒灼全部送進墳墓，瞬間瓦解怪物牌組的戰力，下一局的時候再利用醫療能力，復活擁有燒灼能力的單位牌，再燒對方一次。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="陣營"><a href="#陣營" class="headerlink" title="陣營"></a>陣營</h2><p>每張牌其實還有陣營之分，目前已知有尼弗伽德帝國、北方領域、松鼠黨、怪物、史凱利傑，還有不屬於任何陣營的中立牌。就像遊戲戰場的縮影，每個陣營會有特色，單位牌也不能隨便跑到其他陣營。不過傑洛特、希里這些屬於中立陣營的角色，就可以參與任何陣營。</p><p>每個陣營也不同的能力，好比北方領域可以在贏得一局之後，在下一局的開場多抽一張牌。尼弗加德則是點數相同的時候，能被判定勝利。</p><h2 id="領導牌"><a href="#領導牌" class="headerlink" title="領導牌"></a>領導牌</h2><p>不同陣營的領導能力也不同，領導能力就像是一張隨時握在手上的特殊牌，每場比賽只能用一次；使用時視為出牌一次。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>昆特牌的基本玩法，只要知道脈絡之後玩個幾次就能上手，很快就能到處欺負 NPC，接著變成打牌比殺怪物還像正職的 witcher。</p><div style="max-width: 500px; margin: auto;"><img src="/2019/12/19-gwent/pic_06.jpg"></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;昆特牌是 Witcher 3 裡面的一個小遊戲。雖然非常喜歡 Witcher 3，但我剛開始玩的時候覺得要學很多東西太複雜，所以就跳過了這個部份的教學，任何昆特牌相關的東西都不玩。後來遊戲上手了，回頭玩昆特牌開始上癮，卻因為跳過一些任務無法完整收集昆特牌，只好在二周目重來一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的昆特牌癮又發作啦～&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿著雙劍周遊各地的傳奇白狼傑洛特，除了幫助一些可憐的底層人民，偶爾還會拿著強力的牌組欺壓市井小民。我覺得這樣的設定很有趣，也是我特別喜歡在遊戲裡頭找 NPC 打牌的原因。昆特牌的規則很簡單，只是遊戲裡面的說明不好懂，我試著用我覺得清晰的方式再解說一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>神奈川縣換駕照</title>
    <link href="https://jchu.cc/2019/05/29-license.html"/>
    <id>https://jchu.cc/2019/05/29-license.html</id>
    <published>2019-05-29T14:27:11.000Z</published>
    <updated>2020-08-15T13:10:31.430Z</updated>
    
    <content type="html"><![CDATA[<p>在日本久居的台灣人，可以直接更換日本駕照。先提醒一下，我們台灣人的駕駛習慣直接搬到日本不大好，還是多忍住踩油門的衝動，不要哪天日本取消了這個美意，是台灣人的損失。</p><p>前一陣子換了日本駕照，在這邊紀錄一下過程。</p><a id="more"></a><p>先簡單講結論</p><ul><li>更換駕照的場所，跟你的居住地有關，像我這樣不住在東京都內的人，不能去鮫洲運転免許試験場。</li><li>就我的經驗，沒有筆試、路考，也完全沒被問到日文問題</li></ul><p>準備的證件</p><ul><li>住民票，上面只有我自己的資料</li><li>在留卡</li><li>3cm * 2.4cm 照片一張，我刻意選了跟在留卡、護照都不同的照片</li><li>台灣駕照日文譯本</li><li>台灣駕照 (上面註明沒有期限)</li><li>出入境證明 - 自然人憑證登入以後下載檔案，自行到便利商店印出</li></ul><h1 id="一開始我就跑錯地方"><a href="#一開始我就跑錯地方" class="headerlink" title="一開始我就跑錯地方"></a>一開始我就跑錯地方</h1><div style="max-width: 300px; margin: auto;"><img src="/2019/05/29-license/pic_01.jpg"></div><p>在網路上搜尋了其他人的經驗之後，某天請假特地跑去鮫洲運転免許試験場。八點以前就抵達了門口，結果已經排了長長的人龍。好不容易進去輪到我了，櫃檯的工作人員看了我的證件之後，告訴我神奈川縣的人應該要去另外一個試驗場。沒辦法，誰叫自己沒搞清楚狀況</p><h1 id="神奈川県警察運転免許センター"><a href="#神奈川県警察運転免許センター" class="headerlink" title="神奈川県警察運転免許センター"></a>神奈川県警察運転免許センター</h1><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/map.jpg"></div><p><strong>先講結論：最好準備兩天的時間來換駕照，一天去登記，一天去更換。</strong></p><p>住神奈川縣的人，要去「神奈川県警察運転免許センター」(<a href="https://goo.gl/maps/QHLymwJubUdfwEEL8" target="_blank" rel="noopener">google map</a>)。，最近的車站是<strong>二俣川駅</strong>，下車後大約走十五分鐘的路程。很容易遇到同行的人，迷路的機會其實很低。</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/route_01.jpg"></div><p>出站之後到北口</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/route_02.jpg"></div><p>往唐吉軻德走到底下樓梯</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/route_03.jpg"></div><p>下樓梯之後進入商店街</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/route_04.jpg"></div><p>商店街走到底左轉</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/route_05.jpg"></div><p>經過上坡之後就到了</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/pic_02.jpg"></div><p>一進去等待的房間就會看到這張，早上跟下午加起來一天只接受 20 個名額。一般來說你根本不可能現場排到，所以我的建議是一早去那邊登記，12 號室的窗口旁有個小本子登記現場的順序，輪到你的時候，大叔先檢查一下我是不是已經備妥需要的文件，確認無誤之後預約一個時段就可以回家了。</p><h1 id="漫長的等待"><a href="#漫長的等待" class="headerlink" title="漫長的等待"></a>漫長的等待</h1><div style="max-width: 400px; margin: auto;"><img src="/2019/05/29-license/pic_03.jpg"></div><p>我預約的是下午一號，即便如此我也是等到了五點快關門前才拿到駕照。12 號室就是查驗證件跟等待的地方。一開始窗口的大叔就會先對文件作基本檢核，接著就請我等待。等了約莫四十分鐘之後，拿到一張紙請我去繳費。</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/pic_04.jpg"></div><br><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/pic_05.jpg"></div><p>到九號窗口繳費。我只有換汽車駕照，所以這部分的費用是 2050。紅色部分的字是窗口大叔先幫我填上，國籍寫台灣，非常上道。</p><div style="max-width: 500px; margin: auto;"><img src="/2019/05/29-license/pic_06.jpg"></div><p>除了繳錢，別忘了到旁邊的機器輸入一下「登録カード発行」，會叫你輸入兩個密碼，接著印出一張帶有條碼的紙。因為駕照內的晶片帶有你的個人資訊，你可以透過密碼做簡單的保護，準備好這張紙，接下來只要把這張紙交給製作駕照的人，就會把你的密碼輸入進去。</p><p>準備好繳費單跟密碼單，回去 12 號室等待。過了一下大叔把要更換駕照的人叫進小房間，例行性地宣導一下駕照的規範。接著檢查視力，叫你看機器裡面的上下左右跟顏色，用英文答覆也可以，確認過你不是瞎子之後就結束了。</p><p>每個地方的情況都不一樣，但我這次的經驗，不但沒被問任何問題，甚至日文都不用講就結束。接著就是等待駕照製作。</p><p>駕照製作前要先到 11 號室拍照，拍照的地方很像戰場。一個批次大概有幾十個日本人在排隊等待拍照，我在旁邊計時數了一下，一分鐘就拍了五個人，從坐下、放下手邊的東西、交出密碼單、面對鏡頭、拍照、拿東西起立、換下一位，算起來每個人大概只有十多秒的時間，不誇張。</p><p>拍完照之後繼續等一下，拿手上的運轉免許證受領書把駕照贖回，回到剛剛輸入密碼的機器，驗證一下駕照上面的資料沒問題就可以回家了。</p><p>我是下午一點開始的一號候補，離開的時候大約是四點四十五分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日本久居的台灣人，可以直接更換日本駕照。先提醒一下，我們台灣人的駕駛習慣直接搬到日本不大好，還是多忍住踩油門的衝動，不要哪天日本取消了這個美意，是台灣人的損失。&lt;/p&gt;
&lt;p&gt;前一陣子換了日本駕照，在這邊紀錄一下過程。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
  </entry>
  
  <entry>
    <title>《民粹時代》閱讀筆記</title>
    <link href="https://jchu.cc/2019/03/11-populism.html"/>
    <id>https://jchu.cc/2019/03/11-populism.html</id>
    <published>2019-03-11T14:26:23.000Z</published>
    <updated>2021-07-01T16:35:07.889Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    .my-comment {        color: #AAA;        font-size: 1.1rem;    }</style><p>前些日子讀完了這本<a href="https://opinion.udn.com/opinion/story/11664/3257589">民粹時代：是邪惡的存在，還是改革的希望？</a> (ISBN 978-986-134-319-8) 覺得收穫很多，對於近期的政治現況有不同於之前的看法。這篇文章嘗試記錄我個人覺得關鍵的部分，希望我簡略的重點畫線能帶給你類似的感受，若能引起你的興趣去看看這本書就更好了。</p><span id="more"></span><p>在我的筆記開始之前，先列出幾篇我之前讀過的好文，推薦花時間看一下。</p><ul><li><a href="http://www.biosmonthly.com/interview_topic/9602">民粹和民主怎麼有點像？專訪黃丞儀，讀《民粹時代》</a></li><li><a href="https://opinion.udn.com/opinion/story/11664/3257589">民粹時代（上）：民主之敵或改革的希望——民粹主義是什麼？</a></li><li><a href="https://whogovernstw.org/2018/04/20/jiromizushima1/">民粹主義是什麼？－－《民粹時代》書介及選讀</a></li><li><a href="https://whogovernstw.org/2015/09/26/fangyuchen12/">台灣充滿民粹嗎？談「民粹主義」做為名詞和形容詞</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>「這樣是在搞民粹」我們有時會在政論節目或是官員質詢裡面聽到這樣的句型，柯文哲也說過：「民粹跟民主那一條界線到底要怎麼劃」，彷彿民粹相對於民主是個糟糕而不理性的東西。我們對於「民主」該有的型式其實頗清晰，透過投票或遊行等各種方式決定或表達我們對於政治生活的期待。但是問到民粹的定義，我們的想像就有點模糊了，甚至跟民主的精神好像有點難畫清楚。</p><p>這本書共有七個章節，第一章就嘗試為民粹下個定義，並解釋民粹的內涵及其跟民主的異同。第二三章梳理了南北美洲及歐洲的民粹歷史，第四章講歐洲先進國家的文化跟伊斯蘭教的矛盾，第五章談公投被民粹政黨拿來當成槓桿，第六章著墨英國脫歐「被遺棄者的逆襲」，第七章把鏡頭拉遠談全球化。</p><p>整本書繞了很大一圈談各地的民粹現象，如果拿第一章的定義來看，相當受年輕人支持的時代力量有很高的民粹屬性，如果把第五第六章拿來台灣類比，會覺得能源議題公投與韓國瑜現象頗為相似。這些可能是我喜歡，或是我討厭的現象，從民粹的框架來看突然都開始合理，這是我讀這本書最大的啟發。</p><p>對於那些讓你我覺得棘手的民粹現象，書本也提了一些可能的解法，但是不一定有效，或是不一定做得到，而且你我很可能不喜歡 (笑)。</p><h1 id="第一章：民粹主義是什麼？"><a href="#第一章：民粹主義是什麼？" class="headerlink" title="第一章：民粹主義是什麼？"></a>第一章：民粹主義是什麼？</h1><p>民粹主義的定義，大致可以分成兩種</p><ol><li><p>將民粹主義視為<strong>突破固定的支持基礎，直接訴諸廣泛國民的政治形態</strong></p><p> 用比較實體的講法就是<strong>政治領袖繞過政黨與議會，直接訴諸選民的政治手法</strong>，也有人說是「操弄訴諸國民的花言巧語，以追求改革的明星式政治形態」</p></li><li><p>將民粹主義視為<strong>站在「人民」的立場，批判就有政治與菁英的政治運動</strong></p><p> 以政治改革為目標，批判舊有的權力結構與菁英階級(以及社會的支配性價值觀)，並訴諸「人民」以實現其主張的運動</p></li></ol><p class="my-comment">第一項定義聽起來比較負面一點，第二點聽起來比較正面些，最顯著的例子就是柯文哲常說的打破藍綠。只是「支配性價值觀」其實就是指自由主義堅持的多元化價值觀、同性婚姻等等，其實也是被批判的目標之一。(有沒有覺得很熟悉？)</p><p class="my-comment">雖然你可能覺得自己是邊緣窮肥宅講話沒人理，怎麼會是菁英階級。不過在文化上面熟悉歐美左翼思想的人能夠閱讀外國報導的人，相較於很多非都會區的中老年人，我覺得仍然算是菁英階級。更別提那些留英留美的政治新星。</p><h2 id="民粹主義的特徵"><a href="#民粹主義的特徵" class="headerlink" title="民粹主義的特徵"></a>民粹主義的特徵</h2><p>民粹主義無法以傳統的左右派區分，應該歸類為「下層」的運動。傳統政黨無論左右派都是「上層」，<strong>民粹主義是「站在下層的立場批判上層菁英」</strong>。民粹主義有四個特徵</p><ol><li><p>民粹主義將「人民」擺在其主張的中心，主張自己是人民的直接代表</p><p> 英國政治學者卡諾凡把民粹主義口中的「人民」分成三類說明</p><ol><li>普通人 - 不是媒體人、政治菁英或高學歷者等「特權階級」，而是一直被「特權階級」忽略的普通人，沈默的大多數</li><li>統合的人民 - 民粹主義政黨主張自己不是代表特定的團體或階級，而是超越黨派以及部分利益的人。(以同婚議題來說，同性戀者就是少數利益團體)，可說是「多元主義」的另一個極端</li><li>「我們人民(Our people)」，有同樣性質特徵的人，和其他人是有區別的。國民或主流民族團體是優先次序比較高的人民，外國人或宗教少數則是「他者」</li></ol></li><li><p>第二項特徵是「批判菁英」的傾向</p><p> 民粹主義對於議會、官僚制度、司法制度有強烈的不信任感，認為政治文化都被把持在一小撮人手上，要批判那些無視人民的腐敗精英統治。</p></li><li><p>「明星型領袖」的存在</p><p> 明星型領袖不是重視程序也不是開口就專有名詞的政治官僚，而是被描繪成能夠推敲人民心聲的人。這人以「民眾的心聲」衝撞傳統政治。</p></li><li><p>最後的特徵：意識形態的「薄弱」</p><p> 民粹主義難以具體政策內容來定義，可能現在批判保護主義，過一段時間又批判全球化。主要是因為民粹主義要批判菁英，所以批判的立場也會隨著菁英而移動。</p></li></ol><h2 id="民粹主義與民主主義的關係"><a href="#民粹主義與民主主義的關係" class="headerlink" title="民粹主義與民主主義的關係"></a>民粹主義與民主主義的關係</h2><p>表列了民粹主義的特徵，但是民粹主義的許多面向跟民主主義有所重疊。甚至有政治學者認為，理論上而言擁護人民主權與多數決制度的民粹主義，本質上是民主的。民粹主義抨擊的目標與其說是民主主義本身，還不如說是<strong>透過代議者實施的民主主義</strong>，也就是代議制民主主義。研究者 Paul Taggart 說民粹主義的根基不是在代議制框架內討論，而是對代議制本身的反彈。</p><p>對於近代民主有兩種解釋方式</p><p>一是立憲主義的解釋。重視法律支配、尊重個人自由。透過議會制度制衡權力。這也是自由主義。</p><p>另一是民粹主義的解釋，重視實現人民意志，將直接民主置於優先地位。這是民主主義。</p><p>採取不同的方式解釋民主，就會改變對民粹主義的評價。擁護自由主義傳統者會懷疑民粹主義，擁護民主主義者反而是從民粹中看見「真正的」民主。</p><p class="my-comment">(註：這邊講到的「民主主義」是「以民為主體的主張」，跟「民主政治」不同)</p><p>學者卡諾凡的民粹主義的劃時代論文《民主主義的兩面性》，把民主主義區分成「實務型」跟「救濟型」。實務型民主主義透過規則跟制度的設定解決紛爭，以程序為中心。救濟型民主重視的是人民突破制度與規則的直接參與。</p><blockquote><p>卡諾凡：「試圖躲進純粹實務型解釋的民主主義終究只是幻想，因為實務型系統底下的民主主義的權力與正統性，部分是基於救濟型的要素才得以成立。這總是為民粹主義帶來發生的餘地，民粹主義就像是附在民主背後的陰影」</p></blockquote><p>基進民主主義指的是追求深化民主的多元運動思想，如參與式民主與審議式民主，多半屬於傳統政治上的左派，跟民粹主義的強烈右傾主張分屬兩個極端。但是在促進人民直接參與，克服傳統政治的極限，在這兩點上卻相當一致，兩者都回歸「民主主義」的傳統。</p><p>民粹主義可說是試圖運用民主手段，一口氣解決現有民主問題的躁進式改革運動。</p><p class="my-comment">從前面的一連串定義可以看見許多柯文哲跟韓國瑜的身影，同時也有被批判的菁英階級的窘困。2014 年的 318 事件，也很難說不是對傳統政黨的不信任。如果認同民主兼具救濟型與實務型兩種，那麼民粹主義終究會發生在代議制度失靈的時候。積極推動公投的時代力量，其實在支持民主主義的面向跟民粹主義是一致的。</p><h2 id="民粹主義的貢獻與威脅"><a href="#民粹主義的貢獻與威脅" class="headerlink" title="民粹主義的貢獻與威脅"></a>民粹主義的貢獻與威脅</h2><p>積極地看可能帶來貢獻</p><ol><li>民粹主義能夠促進一直以來被政治排斥的邊緣團體參與政治，藉此為民主發展帶來貢獻。帶來機會讓那些被菁英忽視的人，為自己的意志做出政治上的表述。</li><li>民粹主義能夠打破現有的社會區分，創造出新的政治或社會群體。這將喚起政黨系統的大幅度變動，使政治上的改革成為可能。</li><li>民粹主義能夠將重要的課題拉回政治場域，而非交由經濟或司法解決。</li></ol><p>同時也有阻礙民主發展的一面</p><ol><li>雖然重視人民意志，但也輕視權力分立與制衡的立憲主義原則，過度重視多數派，無視弱勢與少數人的權利</li><li>嚴格區分敵人與盟友，催化政治對立，難以達成妥協與共識</li><li>過度重視表露人民意志，透過投票一舉定案限制其他機構的權限，存在著「良性統治」的風險</li></ol><p>民粹主義會帶來威脅還是貢獻，學者認為焦點在民粹主義政黨所處的脈絡</p><ol><li>民粹主義政黨出現的國家，民主是否已經發展成熟</li><li>民粹主義政黨是執政黨，還是在野黨</li></ol><p class="my-comment">從最近的例子來看就是 2018 年底的公投各項議題，所幸公投題目有巧門可以避過，但也給執政黨相當大的壓力。在寫這篇的同時，第二次的公投已經在醞釀了。</p><h2 id="對民粹主義的四種對策"><a href="#對民粹主義的四種對策" class="headerlink" title="對民粹主義的四種對策"></a>對民粹主義的四種對策</h2><p>傳統勢力對於民粹主義通常有四種對應方式</p><ol><li><p>孤立化</p><p> 否定民粹主義政黨在民主的角色，避免與之合作。容易落入善惡二元論，反而賦予了民粹主義政黨的主張的強烈說服力</p></li><li><p>非正統化或對決</p><p> 否定民粹主義勢力的正統性，譬如德國將極右派政黨視為非法</p></li><li><p>適應或擁抱</p><p> 一定程度接受民粹主義政黨的正統性，致力自我改革。因此可能加速民粹主義政黨的邊緣化，民粹主義政黨的主張一旦成為執政權的一部分，就會弱化。</p></li><li><p>社會化</p><p> 除了適應之外，還更積極面對民粹主義的作用，將民粹主義吸納進傳統政治的框架中，試圖在自由主義民主的框架底下馴化民粹主義。</p></li></ol><p>面對民粹主義的四種對策，同時還要考慮到自身政治的民主品質為何。</p><h1 id="第二章：民粹主義在南北美的誕生與發展"><a href="#第二章：民粹主義在南北美的誕生與發展" class="headerlink" title="第二章：民粹主義在南北美的誕生與發展"></a>第二章：民粹主義在南北美的誕生與發展</h1><p>南北美的環境與文化跟歐洲相差很大，依然有民粹主義的發生。這個章節主要梳理了美洲的民粹主義發展歷史，我畫線的部分不多，所以也沒什麼好寫的。</p><h1 id="第三章：歐洲極右政黨的變化"><a href="#第三章：歐洲極右政黨的變化" class="headerlink" title="第三章：歐洲極右政黨的變化"></a>第三章：歐洲極右政黨的變化</h1><p>各國原本代表左右派的政黨，在全球化、歐洲整合跟冷戰結束的巨觀變化之下，政策愈來愈接近。以左右政黨的「同質化」為背景，民粹主義政黨將傳統政黨視為一丘之貉，透過批判傳統政治，承接選舉人的不滿，獲得絕佳的表現機會。</p><p>其次，傳統組織與團體的衰退，「中間選民」的基數擴大。工會、農民團體組織明顯衰退，「勞工、的意識隨著生活型態改變。歐洲邁向世俗化，宗教系統的勢力也顯著低落。原本靠這些團體支持的政黨也受到深刻影響，政黨活動衰退。不支持特定政黨的中間選民，以都市為中心逐漸增加。</p><p>傳統政黨與團體的沒落使得領袖不再被視為人民的代表者，而被定位為「他們的利益代言人」，不再是「我們的代表」。民粹主義將傳統政治描繪成一小撮既得利益者的禁臠，將其擺在與「特權」無緣的公民的對立面，並主張自己是為公民發聲的存在。</p><p>「獲得政黨與團體的支援」已經無法贏得選戰，透過批判傳統政治，爭取不屬於任何黨派或團體的中間選民廣泛支持，才是最佳的選舉策略。</p><p>全球化伴隨而來的經濟型態改變，貧富差距擴大，兼職或派遣勞工或是長期失業者，「新的下層階級」於焉誕生。勝利組跟失敗組的分化逐漸浮上表面，<strong>民粹主義政黨代表這些失敗者，對抗菁英推動的全球化與歐洲整合</strong>。</p><p class="my-comment">台灣內的政黨，我個人是比較支持時代力量的。但我坦誠看這一段的時候，不斷浮現時代力量著名人物的臉孔。像我這種軟體工程師，就是全球化的受益者。這章還有講到文化批判的部分我覺得很有意思</p><p>比利時的弗拉芒利益黨(Vlaams Belang, 簡稱 VB)，是激進極右派政黨。批判的對象不限於傳統政治人物，對法蘭德斯劇場的批判更是廣為人知。</p><p>由於法蘭德斯民族主義在二戰支持納粹，因此戰後法蘭德斯系統的劇場就極力避免頌揚法蘭德斯文化，聚集到劇場的文化人有強烈的世界主義意識，與激進的法蘭德斯民族主義保持距離，也對民族主義的排他性做出批判。</p><p>VB 主張，法蘭德斯的劇場，必須把守護法蘭德斯文化與法蘭德斯認同的活動是為第一優先，面對外來文化的侵蝕應該要積極維護荷語及法蘭德斯文化，最前線的法蘭德斯劇場更是被賦予這個重要的使命；現況卻是劇場以法蘭德斯文化為恥，向法語優勢臣服，一昧地接受無意義的「文化多元性」</p><p>VB 也把矛頭指向劇場的菁英性。為了配合一小撮藝術菁英的喜好，變得太過前衛性與實驗性，與<strong>大眾</strong>想看的內容相距甚遠。過於深奧的節目只有部分客群喜愛，最後觀劇的都是同一群人。接受政府補助就應該屬於全體人民，要演出普羅大眾能接受的節目。</p><h1 id="第四章：基於自由主義的反伊斯蘭－福利先進國家的矛盾"><a href="#第四章：基於自由主義的反伊斯蘭－福利先進國家的矛盾" class="headerlink" title="第四章：基於自由主義的反伊斯蘭－福利先進國家的矛盾"></a>第四章：基於自由主義的反伊斯蘭－福利先進國家的矛盾</h1><p>模範國丹麥跟荷蘭的民粹主義政黨，以自由主義價值為前提，訴求政教分離與男女平等，同時也回頭對「不接受近代價值」的移民跟伊斯蘭教徒展開批評。是否支持民粹主義是一回事，但是「批判伊斯蘭教的自由」在重視言論自由的丹麥獲得廣泛支持。</p><p>戰後的丹麥逐漸打造出社會福利國家，結果左右兩派的政黨都一致採取支持福利國家的路線，使得兩黨難以被區分。反對這個路線的進步黨，成功吸引了難以在福利國家受惠的自營業者與舊中產階級。</p><p>荷蘭的右派評論家馮圖恩，斷定伊斯蘭教具有「落後性」，認為這個宗教與西方文明有本質上的差異，兩者不可能共存。指出伊斯蘭教無法接受西方逐漸實踐的政教分離、男女平權等各種價值，西方價值反而將被逐漸湧入歐洲的伊斯蘭移民侵蝕。正因為他立足於人權、自由、男女平權等近代價值觀，才會對伊斯蘭教展開批評。這使得他跟極右派的排外主義明顯拉開差距。他也公開承認自己是同性戀者，才無法認同迫害同志、歧視女性的伊斯蘭教。</p><p>荷蘭自由黨領導人威爾德斯，最突出的是他對伊斯蘭教的徹底批評。他將自由視為無上的價值，並將擁護西洋文明的自由視為第一要務，譴責伊斯蘭教是威脅期「自由」的存在。而這個自由黨從頭到尾只維持著他一人是正式黨員的狀態，支持者能以志工身份助選，但從頭到尾就沒有什麼黨代表大會。而國家存在許多自由黨的候選人、議員甚至黨團，但是黨的權力從頭到尾都掌握在一人手上。有人認為在網路發達的時代，可以跟選民直接溝通，中間的政黨組織反而可能會帶來官僚僵化的危機，這個沒有黨員的虛擬政黨是未來政黨的模範。</p><h1 id="第五章：公投悖論－瑞士是理想國度嗎？"><a href="#第五章：公投悖論－瑞士是理想國度嗎？" class="headerlink" title="第五章：公投悖論－瑞士是理想國度嗎？"></a>第五章：公投悖論－瑞士是理想國度嗎？</h1><p>公投是民主主義的終極體現，而瑞士是將其制度化的國家，同時在瑞士，民粹主義政黨卻以公投為槓桿逐漸成長。公民或國民不願意把決定權交給傳統政治人物，或故態復萌的官僚組織，要求透過公投直接參與決策的主張，與民粹政黨對傳統政治與既得利益者展開批判的立場是相通的。</p><p>瑞士的公投有三種，<strong>強制公投</strong>：影響國家根基的重要決策，如修憲或加入超國家組織。其次是<strong>公民複決</strong>，只要收到五萬人以上連署就可進入是否通過的複決公投，只要有效票半數以上反對，法律或條約就會遭到「否決」。最後是只能用在修憲的<strong>公民提案</strong>，國民可以繞過政府或議會，直接參與修憲。</p><p>到目前為止強制公投有三分之一的表決項目，公民複決有二分之一的項目，最後遭到「否定」。換句話說政府推動的政策如果遭到國民有力的杯葛，有很高的機率被阻擋。這種公投制度的存在，給在野黨很大的唱反調能量，對政府構成極大的威脅。後來政府發現克服公投威脅的方法，就是吸納在野黨的反對勢力，讓公投成案機率一開始就降低。</p><p>但是 1990 年代之後原本穩定的瑞士政治與經濟制度開始出現破綻，隨著都市化、價值多樣化跟遠離宗教，支持組群流動的情況愈加頻繁，傳統政黨的「代表性」逐漸被削弱。原本穩定的僱傭關係在大企業整併之下出現不安感，有人認為在這樣的背景下推動進入歐盟等組織將損及瑞士的獨立性，於是民粹主義政黨就趁勢而起。</p><p>如前述，瑞士之所以出現協商式民主主義就是為了搶先吸納發動妨礙政策公投的在野黨，「公投帶來的威脅」正是執政黨要跟在野黨協商的原因。但在傳統團體都式微的情況下，協商式民主主義反而被視為對人民主權的侵害，成為民粹主義政黨攻擊的箭靶。</p><p>公投是兩面刃，一方面是民意的終極展現，另一方面是在議會無論如何都無法得到多數支持的激進政策，可以假藉民主主義，在國家層級上實現。</p><p class="my-comment">如果常看林濁水的評論，就知道相信協商主義的他對公投非常不以為然。於此同時，台灣最支持公投的，就是脫胎自島國前進的時代力量。以公投為槓桿取得聲量，並且繞過議會直接對政府施壓的例子，當然就是最近一次的能源議題公投。</p><h1 id="第六章：英國脫歐，被遺棄者的逆襲"><a href="#第六章：英國脫歐，被遺棄者的逆襲" class="headerlink" title="第六章：英國脫歐，被遺棄者的逆襲"></a>第六章：英國脫歐，被遺棄者的逆襲</h1><p>英國獨立黨是倫敦大學歷史學者 Alan Sked 創立的歐洲懷疑主義政黨，曾經被視為素人團體的泡沫政黨，直到 1997 年英國大選時都還被當成笑話。現在已經成為在歐洲議會選舉中活躍的政黨。分析把票投給英國獨立黨的人，主要可分成兩個族群</p><ol><li>保守的英國獨立黨支持者，生長在保守地區的中年人，相對富足的中產階級。對歐盟的反彈是他們支持英國獨立黨的最大動機。</li><li>英國獨立黨的「核心」支持者，生長在原本支持工黨的家庭，因為經濟上的不安對工黨幻滅，改為支持英國獨立黨。對於移民或外國人有強烈不安，對傳統政黨都不信任。</li></ol><p>相對於極右色彩濃烈的不列顛民族黨，英國獨立黨被視為「有分寸的替代選項」而實現了飛躍性的成長。在思考傳統政黨凋零以及英國獨立黨成長的過程中，經常有人指出「被遺棄者(left behind)」是一大因素。英國存在著中高年白人勞動階級為核心的「被遺棄者」。</p><p>五十年前的英國由白人佔大多數，從事體力勞動，加入工會，住在公營住宅，亦即低學歷的白人勞工是過去英國社會的核心。現在大學生佔了四成，工會組織率與公營住宅的比例大幅下降，市場多是需要專業能力的大學畢業生，於是英國的經濟、社會、政治制度逐漸由高學歷的專業人士支配，擴大了世代間的鴻溝。尤其產業結構的轉換，高齡的藍領勞工直接被排擠到邊緣。中高年齡的世代多對外國人不信任，對英國有強烈的認同感。而年輕一代則是對歐盟較有好感，對英國的認同感薄弱。</p><p>而傳統政黨都把高學歷的中產階級當成主要爭取目標，勞動階級對於政黨無法為自己發聲，逐漸累積不滿。覺得自己沒有政治發言權的勞動階級人數是中產階級的兩倍。英國獨立黨強化對他們的訴求，激化「被遺棄者」對政治菁英的反感，成功獲取他們的支持。</p><p>Owen Jones 對於被遺棄者提出的論點：現在的英國以嚴苛的眼光看待正在失業危機中掙扎的勞動階級。「現在大家都是中產階級」終究只是幻想，貧富差距正在擴大，找不到工作的勞動階級被貼上懶惰的標籤。這是富裕中產階級對於鄉下窮困潦倒勞動階級的「眼光」。英國社會完全是一個中產階級為中產階級打造的社會，勞動階級被當成邪惡的存在放逐到邊緣。從這層意義來看，中產階級對於勞動階級的「眼光」，也許就註定了英國獨立黨的崛起。</p><p>震驚世界的英國脫歐公投之後，年輕人一片哀嚎：「不要奪走我們的未來」。投票確定之後「歐盟是什麼」的搜尋量大增，普遍散佈一種印象：投下脫歐票的人，多數不具備對歐盟的知識。於是這樣的印象就廣為流傳：「對國際問題不關心的中高年齡族群，基於排外的情感，把枷鎖套在前途無量的年輕人身上」</p><p>這種觀點批判，其實也等同於過去中產階級對於勞動階級鄙視的眼光，「背對全球化時代，封閉在狹小區域、拒絕外國人的心胸狹隘之人」，公投可說提供了一個機會將眼光化為言語。但是贊成脫歐的人，對未來充滿不安，終於透過這次的公投把決定權掌握在自己的手上。</p><p>「多達幾百萬名英國人感受到的情緒是，執社會之牛耳的大都會菁英，根本不了解自己的價值觀與生活。不僅如此，這些菁英還明確地痛恨自己」，Owen 把公投結果定義為：「勞動階級的逆襲」</p><h1 id="第七章：全球化與民粹主義"><a href="#第七章：全球化與民粹主義" class="headerlink" title="第七章：全球化與民粹主義"></a>第七章：全球化與民粹主義</h1><p>在英國公投跟美國選舉，事前民調落後的都是親民粹主義那一方。支持者害怕說出真話會被視為「歧視」或「排外」，而「被遺忘人」卻在選舉中扮演了決定性角色。所以川普在勝選後說了：「被遺忘的美國人民，將不會再被遺忘」</p><p>在貧富不均的拉丁美洲，以貧困家庭為基礎要求社會改革與重新分配的「解放」導向促成了民粹主義，批判政治經濟上的特權階級。而在成熟福利的西歐國家，因為沒有壓倒性的貧富差距，反而是接受生活保護者、公務員等，因為公部門而享受「方便」，接受國家重新分配的「受益階級」被定義為「特權階級」。政治學者島田幸典說，西歐原本就由政黨跟利益團體打造了緊密的網路，建構了牢固的財富與權利分配系統。沒有被組織的人，則覺得自己被這個系統排擠，現有體制從未考量自己的利益與意見。民粹主義政黨就承接了這些人的不滿。</p><p>民粹主義政黨獲得讚揚的原因，與其說是「要求更多的分配」，不如說是「將對『他們』的分配視為不當，並且『果敢深入地批判』傳統政治」</p><p>現代民粹主義都承認「自由主義」「民主主義」等現代民主的基本價值，現代民主主義的內部矛盾，透過了民粹主義的存在而凸顯出來。</p><p>民粹主義具有持續性，並非暫時現象。許多民粹主義催生的政治明星已經不在政壇上，但是民粹主義政黨卻透過各種轉型包裝而存活下來。</p><p>有人說民粹主義就像「晚宴中的爛醉者」，是晚宴中不受歡迎的客人，破壞和樂的氣氛，讓賓客皺起眉頭。但是偶爾會碰觸到出席者絕對不會說出的公開秘密，讓人們心頭一驚。民粹主義，就像出現在民主這場高雅派對裡的爛醉者。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>能看到這邊真是辛苦了。</p><p>這本書很好，我只能很不通順地紀錄我自己用螢光筆劃線的部分，有時間的話很建議去買本來讀，可以看到更多談政黨的細節跟脈絡。我會寫這麼多字，主要是我認為這跟台灣現下的政治環境有很大的關係。</p><p>先說中共好了。在網路上經常可以看見，各種提醒中共統戰的文章，好比爛透的中天中視根本是統戰工具，我們不要被謠言分化。但台灣的政治不理性，只是因為統戰發揮效用嗎？我不這麼認為。並不是說中共沒有在影響台灣。只是中共的媒體戰，究竟是火源？還是搧風的人？就全球的民粹現象來看，我覺得更接近於後者。如果我們錯誤評估了中共的角色，很可能我們的解方一直都不對。</p><p>再講直接一點，就是如果我們只把力氣花在防堵外來的攻擊，忽略了本來的內部矛盾衍生的民粹主義，又怎麼會收到好的成效？</p><p>如果民粹主義的現象舉世皆然，就不應該單純視為「台灣的愚民真是貪財怕死不受教」，如果堅持這樣，那不就是「其實全世界多數人都是不受教的智障？」，就算再退一步把這句話當成真值，那麼認同民主的話，不就本來要想辦法跟智障相處嗎？除非你認同共產黨口中的菁英階級統治愚民百姓，否則相信民主的人，又自詡自己比較聰明，不是更應該想方法扭轉局勢嗎？不是應該更冷靜地觀察現況媽？</p><p>不談國防只看內政，在全球化的浪潮下工作型態的轉變，藍領勞工會愈來愈難過日子。各種食衣住行的國際品牌接管生活的各項細節，即使有少數的在地文創品牌，但是大多數的傳統商號只會沒落。而科技軟體把持在寡頭公司手上，未來的收入風險只會愈來愈高。連高技能的工作者都可能失業了，藍領工作者的不安只會更嚴重。在這種大環境下，一邊在談台灣獨立跟華國遺毒，另外一邊噓寒問暖地說要拼經濟，有多少工作不保的人願意跟英語流利的大學生一起拼台獨？</p><p>其次就是善惡二元論充斥在網路上的菁英論述圈裡面，有些直接嘲弄藍營的支持者，有些是痛批藍營本身，但是你能夠輕易地感受到他們的「眼光」透露著對藍營支持者的不屑。你不用喜愛他們，但是錯誤的對話方式只會加深對立，無助於協商。而民主政治正是需要靠協商才能運作。透過強勢的話語權壓制對方，遲早就會有無聲者的反撲。</p><p>也不是要大家當聖人，用無盡的理智與愛去包容智障。只是想提出，民粹主義可能是民主政治無法避免的一部分，相信民主的話就要及早接受它，用比較冷靜的方式處理它。</p><p>不論喜歡或討厭柯文哲，或是有多討厭韓國瑜、護家盟、擁核團體，我想這些都是台灣民主道路上必定會出現的過程，而台灣同時還受到中共的干擾，情況又比其他國家嚴峻，更需要我們冷靜以對。</p><p>最後再偷渡一句：「我覺得台灣真的很需要修憲啦！」</p>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    .my-comment {
        color: #AAA;
        font-size: 1.1rem;
    }
&lt;/style&gt;

&lt;p&gt;前些日子讀完了這本&lt;a href=&quot;https://opinion.udn.com/opinion/story/11664/3257589&quot;&gt;民粹時代：是邪惡的存在，還是改革的希望？&lt;/a&gt; (ISBN 978-986-134-319-8) 覺得收穫很多，對於近期的政治現況有不同於之前的看法。這篇文章嘗試記錄我個人覺得關鍵的部分，希望我簡略的重點畫線能帶給你類似的感受，若能引起你的興趣去看看這本書就更好了。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>隱私與監控</title>
    <link href="https://jchu.cc/2019/03/04-privacy.html"/>
    <id>https://jchu.cc/2019/03/04-privacy.html</id>
    <published>2019-03-04T14:28:53.000Z</published>
    <updated>2021-07-01T16:34:56.913Z</updated>
    
    <content type="html"><![CDATA[<p>這兩天有白帽 Hacker 公佈了從資料庫撈出來的普通民眾對話紀錄。內容是熱愛資料的中國政府如何傾聽人民的聲音。雖然我常跟朋友說監控在技術上可以做到多麽細膩，總覺得自己會被當成瞎操心。又或著，當我臉上露出些許對隱私的擔憂時，又可能被當成反烏托邦電影看太多的阿宅。</p><p>剛好趁著這件事情，隨意說一下我自己長久以來的想法。</p><span id="more"></span><p>簡單來說就是一位叫做 0xdude 的白帽駭客在 Twitter 上面<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E5%AE%A2#%E9%BB%91%E5%AE%A2%E4%B8%8E%E6%BA%83%E5%AE%A2">公佈了他的發現</a>，中國的監控程式每天都有定時把社交網站上面的訊息備份到好幾個異地的資料庫上。有位用中文<a href="https://twitter.com/fdmove/status/1102238231389564928">大致解說了</a>一些關鍵點，希望你看到這篇文章的時候，這些東西都還沒刪掉。</p><p>有時候跟朋友討論到隱私問題，覺得鮮少「極端例子」可以說明我們為什麼總是在杞人憂天，剛好這件事情可以當個教材。下面我也根據 0xdude 的推文抓圖說明一下，後面再講自己的想法，希望這篇文章可以讓我跟朋友在討論隱私問題的時候，能夠從比較高的共識開始。</p><h2 id="0xdude-的-twitter-內容"><a href="#0xdude-的-twitter-內容" class="headerlink" title="0xdude 的 twitter 內容"></a>0xdude 的 twitter 內容</h2><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/tw_01.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/tw_02.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><p>一開始他問了有誰知道那幾個伺服器，他認為中國的監控軟體硬改過的 <a href="https://zh.wikipedia.org/wiki/%E7%A8%9C%E9%8F%A1%E8%A8%88%E7%95%AB">NSA 稜鏡計畫</a> 復刻。監控軟體從六個社交平台取出姓名、id number(應該是平台上的 id)、照片以及 GPS 位置、網路資訊還有對話以及傳輸的檔案，匯入到一個大的線上資料庫。每天大概處理三億六千四百萬個線上帳號以及他們的傳輸內容。</p><p>因為是實名制，所以這些資訊會依據監控軟體的位置，分派到各省份以及 police station (我想他應該是指執法單位)。執法單位每天會檢查 2600 到 2900 個帳號跟訊息，並且每天建檔追蹤變化。所以他們會「人工」去看受監控者的公開與私密訊息。</p><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/tw_03.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><p>最妙的是這些資料在 18 個地方同步的時候，全部是明文傳送沒有加密。(我覺得這樣才方便政府部門搜尋啊！)，還附上了一個截圖證明他看到的東西。</p><div style="max-width: 400px; margin: auto;"><img src="/2019/03/04-privacy/tw_04.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><p>用 Google 翻譯了其中一則中文內容，大致上就是一對年輕人在聊天的內容，應該是在討論「不是我胸部大，是衣服緊，你是豬嘛？」</p><div style="max-width: 400px; margin: auto;"><img src="/2019/03/04-privacy/tw_05.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><p>有好幾個監控軟體同時會把網咖地點送給執法單位，要去敲門查水表的時候會很方便。</p><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/tw_06.png" class="" title="source:https:&#x2F;&#x2F;twitter.com&#x2F;0xDUDE"></div><p>他覺得系統的這部分應該是專門針對在網咖玩遊戲的人，因為都強制要裝上「网吧管理软件」</p><div style="max-width: 300px; margin: auto;"></div><p>他說在發文的 22 個小時以前已經回報給 ISP，因為他不知道「到底誰擁有這些資料」。從這邊看得出來 0xdude 在此事的態度上為單純地白帽駭客看到公開的未加密資料庫，恰好這個資料庫是中國網民的聊天內容，他進去逛了好一段時間然後遵照白帽駭客的倫理，把資訊回報上去。(當然，應該早就一堆黑帽的人玩到爛掉了吧！)</p><h2 id="關於隱私的想法"><a href="#關於隱私的想法" class="headerlink" title="關於隱私的想法"></a>關於隱私的想法</h2><p>上面是簡單的事情紀錄。如果你相信這位 0xdude 講的話，大概就是證實了中國政府監控人民訊息的細膩程度。</p><p>暫時不討論中國政府是好是壞，我也不是要隱私捍衛者的姿態(我當然不是！)來佈道，只是想透過這件事情讓你我想想，到底你是不是真如自己所想的那麼不在意個人資料。</p><p>先聚焦在「隱私到底重要不重要」，接下來才會是我該暴露多少隱私，進階可以談政府能知道多少隱私，或是能不能相信政府碰觸我們的私人資料，但我應該寫不了那麼多。</p><h3 id="我們到底在意不在意隱私"><a href="#我們到底在意不在意隱私" class="headerlink" title="我們到底在意不在意隱私"></a>我們到底在意不在意隱私</h3><p>我是個 Programmer，身邊的朋友對我應該是還滿信賴的，我想如果我開發了一個智慧型掃地機器人，遭週好友都很樂意試用我做的產品。</p><p>但是，如果我跟他們說，為了提供更好的體驗，我做的掃地機器人會不定時地拍照跟錄音，把資料傳到我的伺服器裡面給我分析資料，請大家相信我不會亂來，朋友的反應一定是這樣。</p><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/meme_01.png" class=""></div><p>天曉得機器拍了什麼錄了什麼，每個人在自己家裡的 <em>-嗶-</em> 行為被我鉅細靡遺地看完了還能見人嗎？這種天殺的事情怎麼能發生？</p><p>我們並非完全不重視隱私，只是當你清楚地意識到自己的隱私會暴露在身邊的朋友眼皮底下，那種不舒服的感覺會被強烈放大。有趣的是，如果接收資料的人不是我，而是素昧平生你根本不知道哪來的人，大家反而會覺得安心。也就是說，如果聽到你跟伴侶嗯嗯啊啊聲音的是陌生人，大家反而比較能接受。我能體會這種感覺，正如前面提到的反應「我只是個小人物，人家又不知道我是誰」</p><p>我想絕大多數的人都同意，<strong>我們其實都重視隱私</strong>，只是我們對隱私暴露的風險以及程度，沒有一致的看法。</p><h2 id="我們會暴露多少隱私給誰"><a href="#我們會暴露多少隱私給誰" class="headerlink" title="我們會暴露多少隱私給誰"></a>我們會暴露多少隱私給誰</h2><p>說真的，在這個資訊技術主導一切的時代，要能夠完全保護自己的隱私實在不可能，只要想進入這個現代社會，勢必要拿自己的隱私去交換方便。</p><p>同時，建構人類社會很重要的基石就是「信任」。我們沒有辦法懷疑所有的事情，那樣的生活成本太高。也因此我們對「品牌」會有信任感，好比某些品牌出的食品我們就是比較信任，另外一些則否。所以當有人忽略品牌價值而直接從形式上面類比的時候，我們無法接受。</p><p>舉例來說，國家就是暴力機器無一倖免。但是我們對美國跟中國的想像還是會不一樣，即便我們知道美國的司法不可能完全獨立，也總是有政治力想要干預司法，但是美國跟中國一比，我們還是比較願意相信，人活在美國會比較受到政府的公平對待。形式上來說你知道國家就是想宰制人民的機器，但你不會因此覺得活在美國跟活在中國沒有差別。</p><p>Google 跟小米都熱愛收集資料，但是兩邊出的資訊產品我會寧願選擇 Google 而非小米。理所當然就是 Google 給我的信賴程度比較高。即便我不懷疑小米，卻也無法相信背後的國家體制。</p><p>以數量來說，我們很難去細數自己到底暴露了多少隱私出去，我自己也搞不懂，反而是不懂技術的人覺得自己很安全、超有信心。但至少在選擇產品上，我會盡量避開一些中國的產品，因為我對中國整個背後體制的不信任。</p><p>也有人覺得用小米的產品沒什麼關係，我也同意。因為這本來就不是技術問題，是個人的信仰問題。</p><h2 id="常見的隱私回應"><a href="#常見的隱私回應" class="headerlink" title="常見的隱私回應"></a>常見的隱私回應</h2><p>跟任何人討論到隱私時候，最常出現的幾項反應是</p><ol><li>反正我只是小人物，沒有人會真正在看我</li><li>我沒什麼重要的資料</li><li>你又沒做什麼壞事，幹嘛怕政府知道</li><li>我相信這些資料交出去，也不會被亂用</li></ol><h3 id="沒有人在看你？"><a href="#沒有人在看你？" class="headerlink" title="沒有人在看你？"></a>沒有人在看你？</h3><p>略懂程式的人對這一點大概都會皺眉頭。因為不懂技術的人可能會以為「看不到」，其實是「當下沒在看」而已。把所有用戶正在交談的資料儲存下來完全不是難事，只要資料的結構優良，要短時間內找出你的相關資料都沒問題。</p><p>以前面的觀察為例，反正就是把所有東西先存下來。哪天想要好好追蹤你，輕鬆地就可以羅列過往紀錄。不是看不到你，只是還不知道什麼時候打算看你而已。</p><h3 id="沒什麼重要的資料？"><a href="#沒什麼重要的資料？" class="headerlink" title="沒什麼重要的資料？"></a>沒什麼重要的資料？</h3><p>這個可能是真的，端看你怎麼定義「重要」。譬如說每天跟情人聊天的內容，跟客戶談的生意，洗澡前的自拍照，個人病歷等等，到底這些重要與否因人而異。也是真的有人覺得自己的露鳥照被公開也毫無所謂，這我沒什麼好說的。</p><p>但是對於身份特殊的人，可能都要多在乎一點。譬如說身居黨政要職、網紅正妹、公司管理階級，要說這些人沒有任何重要的資訊也過度缺乏危機意識。光是一般人的每日交通資訊，就可以拿來好好策劃綁票案了，更別說重要人物的各式資訊。</p><h3 id="沒做壞事就不怕人家知道？"><a href="#沒做壞事就不怕人家知道？" class="headerlink" title="沒做壞事就不怕人家知道？"></a>沒做壞事就不怕人家知道？</h3><p>看似合理的論點，但是換個問法就能夠挑出癥結點：「是不是只要沒做壞事，任何資訊都應該要問心無愧地公開？」當然不是！</p><p>如果政府在你家馬桶前方擺個閉路電視，會把影像備份在遠端機器，並且答應你在沒有經過同意前絕對不會去調閱影片，你的反應一定跟前面一樣。</p><div style="max-width: 300px; margin: auto;"><img src="/2019/03/04-privacy/meme_01.png" class=""></div><p>因為這太誇張了。</p><p>所以話說回來，問題不在於受監控者有沒有做壞事，在於受監控者為什麼要接受這樣的對待，而且這樣的對待是否舒服，因人而異。如果有人覺得廁所裡裝監視器沒什麼不好，不代表你要接受。同樣的，你喜歡在自己家門口裝監視器，不代表其他人應該欣然接受，只因為「反正又沒做壞事」</p><p>這條界線很模糊，在每個國家都不一樣，由人民對隱私的重視程度決定它的前後，沒有一定的正確位置。</p><h3 id="沒有人會亂用資料？"><a href="#沒有人會亂用資料？" class="headerlink" title="沒有人會亂用資料？"></a>沒有人會亂用資料？</h3><p>一般來說我反而比較相信私人企業而非政府。對私人企業而言，搞砸這件事情又被爆出來，通常公司就會完蛋。但是政府呢？政府才不怕你呢，而且在官僚體系之下責任早就分散出去了。當然我工作了這麼多年，深深地明白很多看是強大的私人企業其實裡面充滿混亂，而僵化的政府體制裡面其實也有優秀的公務員。只是兩者的天生使命不同，促使他們內在的力量也不一樣，對私人企業而言保護資料是重要的；對政府而言，保護資料的驅力主要來自….應該是不要被罵吧。</p><p>即便如此，美國還是藉國家安全之名跟私人企業要資料。中國就更不用講了，沒有企業敢跟政府作對。</p><p>人們常常有很矛盾的說法，譬如不相信司法整天在罵恐龍法官，同時又相信司法可以正確地給那些罪該萬死的人制裁。同時不相信政府的效率以及能力，同時又相信自己的資料能夠被政府好好地保護。更別說台灣也不怎麼大，你以為看資料的是陌生人，其實很有可能就是你叔母那個正在公家機關上班的表弟。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>回到前面說的，當我們把資料交給不認識的人，很容易覺得自己隱身在茫茫人海裡很安全，我覺得這是很自然的人性。</p><p>不過落落長寫了一大堆，也沒什麼重點，只是想比較完整地說一遍，那個「覺得自己其實很安全」是錯覺。因為在電腦技術上面，你並沒有躲在茫茫人海裡面，不是夾娃娃機裡面角落那個不起眼的小娃娃；你是雞舍裡面住在精準編號籠子裡面的雞，要不要找你下手只是意願問題而已。</p><p>對於某些身份可能比較重要的人，完全沒有隱私或是資訊安全的概念，我也滿無言的。也許現在你是 nobody，但以後你可能變 the one，到時候你暴露出去的這些資料，很有機會在敵人的手上反咬你一口。</p><p>這年頭我們不可能像 RED超危險特工裡面的 Marvin 那樣獨居在野外，勢必會暴露很多自己的資訊。但至少在選擇產品的時候，可以多想想自己該放什麼東西出去。面對比較在乎隱私的人，可以多點理解對方的動力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;這兩天有白帽 Hacker 公佈了從資料庫撈出來的普通民眾對話紀錄。內容是熱愛資料的中國政府如何傾聽人民的聲音。雖然我常跟朋友說監控在技術上可以做到多麽細膩，總覺得自己會被當成瞎操心。又或著，當我臉上露出些許對隱私的擔憂時，又可能被當成反烏托邦電影看太多的阿宅。&lt;/p&gt;
&lt;p&gt;剛好趁著這件事情，隨意說一下我自己長久以來的想法。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
</feed>
