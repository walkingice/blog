<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>只放拖鞋的鞋櫃</title>
  
  <subtitle>程式中的迷途小書僮</subtitle>
  <link href="https://jchu.cc/atom.xml" rel="self"/>
  
  <link href="https://jchu.cc/"/>
  <updated>2023-09-01T13:58:37.765Z</updated>
  <id>https://jchu.cc/</id>
  
  <author>
    <name>Walkingice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Subtree 簡單介紹</title>
    <link href="https://jchu.cc/2023/09/01-git-subtree.html"/>
    <id>https://jchu.cc/2023/09/01-git-subtree.html</id>
    <published>2023-09-01T14:27:27.000Z</published>
    <updated>2023-09-01T13:58:37.765Z</updated>
    
    <content type="html"><![CDATA[<p>簡單快速地理解 git subtree 是怎樣的東西</p><span id="more"></span><p>如果有一個 git repository 同時會被幾個不同的專案用到，通常有兩個選擇：1) 使用 git submodule 2) 使用 git subtree</p><h2 id="git-submodule-的概念"><a href="#git-submodule-的概念" class="headerlink" title="git submodule 的概念"></a>git submodule 的概念</h2><figure class="img" style="max-width: 100%;"><img src="/2023/09/01-git-subtree/git_submodule.svg" class="" title="git submodule"></figure><ul><li>有兩個 repo: Main Repo 跟 Sub Repo，希望在 MainRepo 底下的 DirSub 放 Sub Repo 的東西</li><li>Main 裡面會有兩個 <code>.git</code> 目錄，一個是 Main 本身的，另外一個是 Sub Repo</li><li>Main 跟 Sub 的 commit history 是分開的<ul><li>在 Main 裡面看不到 Sub 的 commit history</li></ul></li><li>對 Main 而言，它看不見 Sub 底下的 <code>Foo</code> 或是 <code>Bar</code> 目錄</li><li>對 Main 而言，<code>DirSub</code> 是個特殊的檔案，Main 只在乎 <code>DirSub</code> 會用到 sub repo 的哪個 commit</li></ul><h2 id="git-subtree-的概念"><a href="#git-subtree-的概念" class="headerlink" title="git subtree 的概念"></a>git subtree 的概念</h2><figure class="img" style="max-width: 100%;"><img src="/2023/09/01-git-subtree/git_subtree.svg" class="" title="git subtree"></figure><ul><li>同上，有兩個 repo: Main Repo 跟 Sub Repo，希望在 MainRepo 底下的 DirSub 放 Sub Repo 的東西</li><li>Main 裡面只會有一個 <code>.git</code> 目錄<ul><li>Main 可以說是根本不知道 Sub Repo 的存在</li><li>Main 也看得到 <code>DirSub</code> 的 commit history</li></ul></li><li><code>DirSub</code> 對 Main 而言只是個普通的目錄<ul><li>只是這裡面的東西會用某種方式，從其他 repo 拿過來</li></ul></li></ul><h2 id="簡單比較-git-submodule-跟-git-subtree"><a href="#簡單比較-git-submodule-跟-git-subtree" class="headerlink" title="簡單比較 git submodule 跟 git subtree"></a>簡單比較 git submodule 跟 git subtree</h2><p>我是這麼解釋這兩者的差別</p><ul><li>git submodule 是把兩個 git repo 擺進同一個 work directory 裡面，用這個 work directory 來編譯專案</li><li>git subtree 是用一個 git repo 產生一個 work direcotry，用起來就像平常的專案<ul><li>只是其中一個目錄裡面的東西，是從別的 repo 拿過來</li></ul></li></ul><p>拿 cherry-pick 來比喻，cherry-pick 就是從別的 branch 拿幾個 commit 進到正在工作的 branch</p><p>而 subtree，相當於是從別的 repository，拿幾個 commit 進到正在工作的 repo/branch。</p><h2 id="用-git-format-patch-am-理解"><a href="#用-git-format-patch-am-理解" class="headerlink" title="用 git format-patch / am 理解"></a>用 git format-patch / am 理解</h2><p>如果你常用 <code>format-patch</code> 與 <code>am</code> 就能很快理解 <code>subtree</code>。</p><figure class="img" style="max-width: 100%;"><img src="/2023/09/01-git-subtree/git_format.svg" class="" title="git format-patch and am"></figure><p>對於兩個完全沒關聯的 repository，我們可以</p><ol><li>從 sub repo 利用 <code>git format-patch</code> 對幾個 commit 生出 patch 檔案</li><li>把這幾個 patch 檔案拿到 main repo 用 <code>git am</code> 把修改放進去</li></ol><p>從上面的例子可以看到，最後 Main Repository 會多出兩個目錄 <code>Foo</code> 與 <code>Bar</code>，內容跟 Sub Repository 一樣。</p><p>不過常用這招的人，就會知道 Main 跟 Sub 的路徑要吻合，否則 patch 無法順利打上。</p><p>雖然這樣不是很精確，但是可以快速地理解 subtree 是什麼樣的東西</p><p><strong>subtree 就是針對某個子目錄，做類似 format-patch/am，同時也處理好路徑問題的工具</strong></p><p>「我在 Main Repo 開了一個 SubDir，請把 SubRepo 的 commits 都幫我用 <code>git am</code> 的方式放進 SubDir 裡面」，大概是這種感覺吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;簡單快速地理解 git subtree 是怎樣的東西&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="git" scheme="https://jchu.cc/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>隨意減重過程</title>
    <link href="https://jchu.cc/2023/08/15-dieting.html"/>
    <id>https://jchu.cc/2023/08/15-dieting.html</id>
    <published>2023-08-15T12:18:56.000Z</published>
    <updated>2023-08-15T12:38:56.152Z</updated>
    
    <content type="html"><![CDATA[<p>最近剛做完年度體檢，體脂跟體重都有顯著下降。隨手記錄這幾個月做的事情。</p><span id="more"></span><p>比起經常上健身房運動的人，我的飲食控制做得很隨便，因為我根本沒有認真算每天吃進的卡路里有多少，只是憑感覺抓個大概，正餐之外也少吃零食(但還是有吃啦)。</p><p>就結論來說，我覺得自己減重過程算是幾乎沒有負擔，沒什麼「努力」的感覺。</p><p>從健檢報告來看，去年到今年的變化是</p><ul><li>體重：67.1 公斤 =&gt; 60.2 公斤</li><li>BMI：21.8 =&gt; 19.6</li><li>體脂： 24.0 =&gt; 16.6</li></ul><p>從數字上來看似乎有點太瘦了，應該要再努力增加一點肌肉會比較健康。</p><p>會有改變飲食的打算，是因為幾個月前看了一篇文章 <a href="https://www.sydney.edu.au/news-opinion/news/2022/11/08/processed-foods-key-to-rising-obesity-study-finds-.html">Study confirms that processed foods key to rising obesity(研究證實加工食品是肥胖關鍵)</a></p><p>稍微看了一下文章確定不是英國研究，主要是説人體對於蛋白質的需求高於其他營養素，現在加工食品的蛋白質不夠，吃了大量的加工食品才能滿足身體的蛋白質需求。</p><p>我自己的解讀是，如果及早滿足當天的蛋白質需求，或許身體對於其他碳水化合物或脂肪的吸收程度就會下降。換言之，即使攝取的食物相同，攝取的順序不同，可能也會有差別。</p><p>不管怎樣，蛋白質是重要的營養素，不只是骨骼肌，內臟也是由蛋白質組成，修復細胞都要靠蛋白質。每天都要吃進足夠的蛋白質成為我的主要目標。</p><p>我的作法很簡單</p><ol><li>每週末去超市買包一公斤的雞胸肉，去掉我不要的雞皮或是看起來不好吃的部分，至少都還有 900 公克以上</li><li>切好再分裝成六盒，還沒要吃的丟進冷凍庫，要吃的放冷藏</li><li>每天煮飯就是吃掉一盒，午餐多吃一點，晚餐就少一點</li></ol><div style="max-width: 50%; margin: auto;"><img src="/2023/08/15-dieting/pic_mune.jpg" class=""></div><p>我不太有吃早餐的習慣，九點多起床不久就要吃午餐了。就這樣每天吃兩餐，不知不覺數字就掉了。吃早餐不會有太大影響，我偶爾會用雞胸肉做個生菜沙拉配果菜汁也是吃得很開心，但通常懶得花時間準備食物，不吃早餐更多是懶惰的結果。</p><p>這幾個月來真正改變的事情，其實只有<strong>「確保每天有用各種肉把自己塞飽」</strong></p><p>選雞胸肉只是因為最便宜，我偶爾還是會買豬絞肉煮味噌拉麵，買美味的日本冷凍炸雞，或是胡亂煎個牛排來吃，總之就是吃肉吃到爽。澱粉類就隨意了。</p><p>雖然一天只吃兩餐，但這自己煮的兩餐都吃得很飽很爽快。煮麵一定要打個蛋，韓式泡菜口味還要再補個豆腐，也會塞滿自己喜歡的蔬菜。除此之外會吃綜合維他命，避免自己沒吃進必須的維他命或微量元素。澱粉類就隨意吃，反正都快撐死了也吃不了太多。</p><p>說起來有趣，我原本是有吃泡麵當宵夜的習慣。不誇張，之前可能晚上七點才吃飽飯，到了九點多就覺得餓，忍不住吃碗泡麵。自從實行用肉把自己塞飽的方法，晚上都不太會餓，最近竟然發生了特地從台灣帶來日本的泡麵，放到過期這種對不起泡麵之神的事情。</p><p>比起有在認真打理飲食的人，我這樣真的做得很隨便。不過我覺得這種長期抗戰的事情，首先要選一個足夠簡單，幾乎沒有壓力的方式，養成日常的習慣，取得初步的成就感之後，再逐漸精進，朝向更優良的飲食習慣。</p><p>所以我現在都會建議身邊的朋友：「不用痛苦的餓到自己，但是每天先確保自己吃進足夠的肉，甚至多吃點肉而減少一點澱粉」先做最簡單的事情就好，能夠持之以恆什麼都好說。</p><p>不過我這樣做也有副作用</p><p>最近出門外食會覺得很痛苦，譬如一盤義大利麵，我只會看到一堆醬跟煮熟的澱粉麵條；一碗烏龍麵，我只會看見湯頭跟煮熟的澱粉麵條；一盤香噴噴的咖喱飯，我只能看見咖哩醬跟白飯。這些東西我依然覺得很好吃，也知道料理背後的手藝與時間有價，可是餐點裡面沒肉少菜，我就會有種「<del>臣妾做不到啊</del>這筆錢花不下去啊～」的掙扎感 Q_Q</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近剛做完年度體檢，體脂跟體重都有顯著下降。隨手記錄這幾個月做的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Orenz Pentel PP2005 - 目前最滿意的自動鉛筆</title>
    <link href="https://jchu.cc/2023/08/01-pen.html"/>
    <id>https://jchu.cc/2023/08/01-pen.html</id>
    <published>2023-07-31T16:05:50.000Z</published>
    <updated>2023-07-31T15:31:59.966Z</updated>
    
    <content type="html"><![CDATA[<p>日本的各式文具相當出名，不少文具控到日本旅遊都會失心瘋買一大堆。</p><p>我雖然不是文具控，但最近也買了一支不會折斷筆芯的自動筆，Orenz Pental PP2005，可說是我目前用過最滿意的自動筆。</p><span id="more"></span><p>在日本的書局經常可以看到寫著「芯折れをしっかり防ぐ」「芯を守る」或是「芯が折れない」之類的標語的自動筆，不諳日語的人也能從漢字推敲出「守護筆芯」「不折斷筆芯」之類的意思。</p><p>據我所知，原理大概都是盡可能讓露出的筆芯變短，側向的力矩變小自然筆芯就比較不易折斷。或許還有些減壓的技術，但我沒有很清楚</p><p>上週在書局試用了 Orenz Pentel PP2005 的自動筆，當下覺得很驚艷便買回家。用到現在感覺很滿意。</p><p>這支筆主打的特色是「筆芯會自動伸出，因此不需手動按壓推出筆芯，因此不會讓思考中斷」。筆芯只需要露出非常些微的部分就能持續書寫，也因此力矩極小，筆芯自然就不易折斷。</p><div style="max-width: 100%; margin: auto;"><img src="/2023/08/01-pen/pen_a.jpg" class=""></div><p>沒有試用書寫以前，一直覺得金屬的部分會刮到紙張，使得書寫感欠佳。實際使用之後幾乎感受不到任何不適，彷彿金屬筆頭就是筆芯本身，而且持續書寫不需按壓筆芯的暢快感就像在寫自動筆般流暢。</p><p>就算我寫字比較用力，用了這支筆後尚未發生任何折斷筆芯的事情</p><div style="max-width: 100%; margin: auto;"><img src="/2023/08/01-pen/pen_b.jpg" class=""></div><p>若要雞蛋裡挑骨頭，我會希望握柄的部分再粗一點，對男生會有更好的手感，不過目前的握柄是中規中矩，男女性都可以恰好握住。</p><p>我買 0.5mm 的版本，搭配隨便買的筆芯就能順利使用，一支 2000 日圓左右，讓我相當滿意，滿意到想要多買幾支當禮品送人 XD</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日本的各式文具相當出名，不少文具控到日本旅遊都會失心瘋買一大堆。&lt;/p&gt;
&lt;p&gt;我雖然不是文具控，但最近也買了一支不會折斷筆芯的自動筆，Orenz Pental PP2005，可說是我目前用過最滿意的自動筆。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="japan" scheme="https://jchu.cc/tags/japan/"/>
    
    <category term="life" scheme="https://jchu.cc/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>FC FF3 版本修改數值</title>
    <link href="https://jchu.cc/2023/07/24-ff3.html"/>
    <id>https://jchu.cc/2023/07/24-ff3.html</id>
    <published>2023-07-24T08:35:27.000Z</published>
    <updated>2023-07-24T10:17:37.287Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    table {        border-collapse:collapse;        border-spacing:0;        empty-cells:show    }    table, tr, td {        border: 0.5px solid grey;        text-align: center;    }    table.items td {        text-align: left;    }    table.items p {        margin-left: 5px;    }    .ce1 {        font-size:10pt;        border-top-style:solid;        border-top-color:#00000;        width:0.8in;    }    .ce2 {        font-size:10pt;        border-top-style:solid;        border-top-color:#00000;        width:1.2in;    }    col {        text-align: left;    }    .even {        background: rgb(230,230 ,230);    }    .ce3 {        font-size:10pt;        border-top-style:solid;        border-top-color:#00000;    }    table p {        margin-top: 0px;        margin-bottom: 0px;        text-shadow: none;    }    .special {        background: grey;        color: white;    }</style><p>最近重溫了 FC 版本的 FF3，因為懶得老老實實練功，所以直接動手修改數值，順手紀錄如何修改</p><span id="more"></span><p>我是用 FCEUX 來玩，其他模擬器的起始位址可能不同，但是相對位址應該一樣。</p><p>打開模擬器讀進 ROM 之後，在 Debug / Hex Editor 就能直接編輯記憶體位址</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><tr class="ro1"><td class="ce1"> </td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro2"><td class="ce1"><p>0x0000F0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>00 不遇敵</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr></table><table><tr class="ro1"><td class="ce1"> </td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006010</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>轉職點數</p></td><td colspan="3" class="ce1"><p>金錢</p></td><td class="ce1"> </td></tr></table><ul><li>如果想把金錢換成 <code>123456</code>，十六進位就是 <code>01E240</code>，在 Hex Editor 裡面則是輸入 <code>04 E2 01</code></li><li>金錢 <code>9999999</code> 就輸入 <code>7F 96 98</code></li><li>要轉換 16 進位可以用這個 <a href="https://hex.jchu.cc/">Hex Converter</a><ul><li>這是我之前<a href="https://github.com/walkingice/hex_converter">隨手寫</a>的，可以另存網頁完全離線使用</li></ul></li></ul><table><tr class="ro1"><td class="ce1"><p>道具欄</p></td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro2"><td class="ce1"><p>0x0060C0</p></td><td class="ce1 special"><p>第 1 項代碼</p></td><td class="ce1"><p>第 2 項代碼</p></td><td class="ce1"><p>第 3 項代碼</p></td><td class="ce1"><p>…</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>第 16 項代碼</p></td></tr><tr class="ro2"><td class="ce1"><p>0x0060D0</p></td><td class="ce1"><p>第 17 項代碼</p></td><td class="ce1"><p>第 18 項代碼</p></td><td class="ce1"><p>…</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>第 32 項代碼</p></td></tr><tr class="ro2"><td class="ce1"><p>0x0060E0</p></td><td class="ce1 special"><p>第 1 項數量</p></td><td class="ce1"><p>第 2 項數量</p></td><td class="ce1"><p>第 3 項數量</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>第 16 項數量</p></td></tr><tr class="ro2"><td class="ce1"><p>0x0060F0</p></td><td class="ce1"><p>第 17 項數量</p></td><td class="ce1"><p>第 18 項數量</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>第 32 項數量</p></td></tr></table><p>物品代碼參考 <a href="https://www.ptt.cc/bbs/Old-Games/M.1333821037.A.0B0.html">PTT: FF3全物品代碼表 請搭配道具bug使用 by milkteacon (奶茶控)</a>，原 Po 很感人地用華泰的翻譯(跪)，我這邊換成習慣的 16 進位</p><table border="0" cellspacing="0" cellpadding="0" class="ta1 items"><colgroup><col width="5%"><col width="20%"><col width="100"><col width="2%"><col width="5%"><col width="20%"><col width="100"></colgroup><tr class="ro1"><td class="ce3"><p>01</p></td><td class="ce3"><p>カイザーナックル</p></td><td class="ce3"><p>凱撒鐵指環</p></td><td class="ce3"> </td><td class="ce3"><p>81</p></td><td class="ce3"><p>がくしゃのふく</p></td><td class="ce3"><p>學者的衣服</p></td></tr><tr class="ro1"><td class="ce3"><p>02</p></td><td class="ce3"><p>ねこのつめ</p></td><td class="ce3"><p>貓爪</p></td><td class="ce3"> </td><td class="ce3"><p>82</p></td><td class="ce3"><p>だいちのころも</p></td><td class="ce3"><p>大地之衣</p></td></tr><tr class="ro1"><td class="ce3"><p>03</p></td><td class="ce3"><p>ひりゆうのつめ</p></td><td class="ce3"><p>飛龍爪</p></td><td class="ce3"> </td><td class="ce3"><p>83</p></td><td class="ce3"><p>デモンズメイル</p></td><td class="ce3"><p>惡魔鎧甲</p></td></tr><tr class="ro1"><td class="ce3"><p>04</p></td><td class="ce3"><p>ようせいのつめ</p></td><td class="ce3"><p>高性能爪</p></td><td class="ce3"> </td><td class="ce3"><p>84</p></td><td class="ce3"><p>ダイャメイル</p></td><td class="ce3"><p>鑽石頭盔</p></td></tr><tr class="ro1"><td class="ce3"><p>05</p></td><td class="ce3"><p>じごくのつめ</p></td><td class="ce3"><p>地獄爪</p></td><td class="ce3"> </td><td class="ce3"><p>85</p></td><td class="ce3"><p>リフレワトメイル</p></td><td class="ce3"><p>反射鎧甲</p></td></tr><tr class="ro1"><td class="ce3"><p>06</p></td><td class="ce3"><p>ヌンチャク</p></td><td class="ce3"><p>雙節棍</p></td><td class="ce3"> </td><td class="ce3"><p>86</p></td><td class="ce3"><p>しろのローブ</p></td><td class="ce3"><p>白長袍</p></td></tr><tr class="ro1"><td class="ce3"><p>07</p></td><td class="ce3"><p>トンフアー</p></td><td class="ce3"><p>東方棍</p></td><td class="ce3"> </td><td class="ce3"><p>87</p></td><td class="ce3"><p>くろのローブ</p></td><td class="ce3"><p>黑長袍</p></td></tr><tr class="ro1"><td class="ce3"><p>08</p></td><td class="ce3"><p>さんせつこん</p></td><td class="ce3"><p>三節棍</p></td><td class="ce3"> </td><td class="ce3"><p>88</p></td><td class="ce3"><p>げんじのよろい</p></td><td class="ce3"><p>源氏鎧甲</p></td></tr><tr class="ro1"><td class="ce3"><p>09</p></td><td class="ce3"><p>ミスリルロッド</p></td><td class="ce3"><p>米斯理魯棒</p></td><td class="ce3"> </td><td class="ce3"><p>89</p></td><td class="ce3"><p>ワリスタルメイル</p></td><td class="ce3"><p>水晶鎧甲</p></td></tr><tr class="ro1"><td class="ce3"><p>0A</p></td><td class="ce3"><p>ほのおのぼう</p></td><td class="ce3"><p>火焰棒</p></td><td class="ce3"> </td><td class="ce3"><p>8A</p></td><td class="ce3"><p>さびたよろい</p></td><td class="ce3"><p>生鏽鎧甲</p></td></tr><tr class="ro1"><td class="ce3"><p>0B</p></td><td class="ce3"><p>こおりのぼう</p></td><td class="ce3"><p>冰凍棒</p></td><td class="ce3"> </td><td class="ce3"><p>8B</p></td><td class="ce3"><p>どうのうでわ</p></td><td class="ce3"><p>銅製手環</p></td></tr><tr class="ro1"><td class="ce3"><p>0C</p></td><td class="ce3"><p>こおりのぼう</p></td><td class="ce3"><p>光亮棒</p></td><td class="ce3"> </td><td class="ce3"><p>8C</p></td><td class="ce3"><p>オニオンレット</p></td><td class="ce3"><p>洋蔥護手</p></td></tr><tr class="ro1"><td class="ce3"><p>0D</p></td><td class="ce3"><p>すべてのぼう</p></td><td class="ce3"><p>全能棒</p></td><td class="ce3"> </td><td class="ce3"><p>8D</p></td><td class="ce3"><p>ミスリルのこて</p></td><td class="ce3"><p>米斯理魯護手</p></td></tr><tr class="ro1"><td class="ce3"><p>0E</p></td><td class="ce3"><p>つえ</p></td><td class="ce3"><p>枴杖</p></td><td class="ce3"> </td><td class="ce3"><p>8E</p></td><td class="ce3"><p>ミスリルのうでわ</p></td><td class="ce3"><p>米斯理魯手環</p></td></tr><tr class="ro1"><td class="ce3"><p>0F</p></td><td class="ce3"><p>もえゐつえ</p></td><td class="ce3"><p>燃燒之杖</p></td><td class="ce3"> </td><td class="ce3"><p>8F</p></td><td class="ce3"><p>とうぞくのこて</p></td><td class="ce3"><p>盜賊護手</p></td></tr><tr class="ro1"><td class="ce3"><p>10</p></td><td class="ce3"><p>こおゐつえ</p></td><td class="ce3"><p>冰凍之杖</p></td><td class="ce3"> </td><td class="ce3"><p>90</p></td><td class="ce3"><p>ガントレット</p></td><td class="ce3"><p>寬口大手套</p></td></tr><tr class="ro1"><td class="ce3"><p>11</p></td><td class="ce3"><p>ひかゐつえ</p></td><td class="ce3"><p>光亮之杖</p></td><td class="ce3"> </td><td class="ce3"><p>91</p></td><td class="ce3"><p>パワーリスト</p></td><td class="ce3"><p>力護手</p></td></tr><tr class="ro1"><td class="ce3"><p>12</p></td><td class="ce3"><p>ゴーレムのつえ</p></td><td class="ce3"><p>哥倫之杖</p></td><td class="ce3"> </td><td class="ce3"><p>92</p></td><td class="ce3"><p>ルーンのうでわ</p></td><td class="ce3"><p>古文的手環</p></td></tr><tr class="ro1"><td class="ce3"><p>13</p></td><td class="ce3"><p>ルーンのつえ</p></td><td class="ce3"><p>古文之杖</p></td><td class="ce3"> </td><td class="ce3"><p>93</p></td><td class="ce3"><p>ダイャのうでわ</p></td><td class="ce3"><p>鑽石手環</p></td></tr><tr class="ro1"><td class="ce3"><p>14</p></td><td class="ce3"><p>ちょうろうのつえ</p></td><td class="ce3"><p>長老之杖</p></td><td class="ce3"> </td><td class="ce3"><p>94</p></td><td class="ce3"><p>ダイャのこて</p></td><td class="ce3"><p>鑽石護手</p></td></tr><tr class="ro1"><td class="ce3"><p>15</p></td><td class="ce3"><p>ハンマー</p></td><td class="ce3"><p>鎚</p></td><td class="ce3"> </td><td class="ce3"><p>95</p></td><td class="ce3"><p>まもりのゆびわ</p></td><td class="ce3"><p>護身戒指</p></td></tr><tr class="ro1"><td class="ce3"><p>16</p></td><td class="ce3"><p>トールハンマー</p></td><td class="ce3"><p>雷神鎚</p></td><td class="ce3"> </td><td class="ce3"><p>96</p></td><td class="ce3"><p>げんじのこて</p></td><td class="ce3"><p>源氏護手</p></td></tr><tr class="ro1"><td class="ce3"><p>17</p></td><td class="ce3"><p>バトルアクス</p></td><td class="ce3"><p>戰斧</p></td><td class="ce3"> </td><td class="ce3"><p>97</p></td><td class="ce3"><p>ワリスタルのこて</p></td><td class="ce3"><p>水晶護手</p></td></tr><tr class="ro1"><td class="ce3"><p>18</p></td><td class="ce3"><p>ダブルハークン</p></td><td class="ce3"><p>雙面鉤</p></td><td class="ce3"> </td><td class="ce3"><p>98</p></td><td class="ce3"><p>まほうのカギ</p></td><td class="ce3"><p>魔法鑰匙</p></td></tr><tr class="ro1"><td class="ce3"><p>19</p></td><td class="ce3"><p>モーニングスター</p></td><td class="ce3"><p>流星鎚</p></td><td class="ce3"> </td><td class="ce3"><p>99</p></td><td class="ce3"><p>ギサールのやさい</p></td><td class="ce3"><p>基莎爾蔬菜</p></td></tr><tr class="ro1"><td class="ce3"><p>1A</p></td><td class="ce3"><p>サンダースビア</p></td><td class="ce3"><p>雷鳴矛</p></td><td class="ce3"> </td><td class="ce3"><p>9A</p></td><td class="ce3"><p>ドワーフのつの</p></td><td class="ce3"><p>杜瓦夫的角</p></td></tr><tr class="ro1"><td class="ce3"><p>1B</p></td><td class="ce3"><p>ウインドスビア</p></td><td class="ce3"><p>風翼矛</p></td><td class="ce3"> </td><td class="ce3"><p>9B</p></td><td class="ce3"><p>ネプトのめ</p></td><td class="ce3"><p>尼布特之眼</p></td></tr><tr class="ro1"><td class="ce3"><p>1C</p></td><td class="ce3"><p>ブラッドランス</p></td><td class="ce3"><p>吸魂矛</p></td><td class="ce3"> </td><td class="ce3"><p>9C</p></td><td class="ce3"><p>ときのはぐるま</p></td><td class="ce3"><p>時間齒輪</p></td></tr><tr class="ro1"><td class="ce3"><p>1D</p></td><td class="ce3"><p>ホーリーランス</p></td><td class="ce3"><p>神聖矛</p></td><td class="ce3"> </td><td class="ce3"><p>9D</p></td><td class="ce3"><p>エウレカのかぎ</p></td><td class="ce3"><p>尤列卡的鑰匙</p></td></tr><tr class="ro1"><td class="ce3"><p>1E</p></td><td class="ce3"><p>ナイフ</p></td><td class="ce3"><p>小刀</p></td><td class="ce3"> </td><td class="ce3"><p>9E</p></td><td class="ce3"><p>かぜのきば</p></td><td class="ce3"><p>風之牙</p></td></tr><tr class="ro1"><td class="ce3"><p>1F</p></td><td class="ce3"><p>ダガー</p></td><td class="ce3"><p>寬刃小刀</p></td><td class="ce3"> </td><td class="ce3"><p>9F</p></td><td class="ce3"><p>ひのきば</p></td><td class="ce3"><p>火之牙</p></td></tr><tr class="ro1"><td class="ce3"><p>20</p></td><td class="ce3"><p>ミスリルナイフ</p></td><td class="ce3"><p>米斯理魯小刀</p></td><td class="ce3"> </td><td class="ce3"><p>A0</p></td><td class="ce3"><p>みずのきば</p></td><td class="ce3"><p>水之牙</p></td></tr><tr class="ro1"><td class="ce3"><p>21</p></td><td class="ce3"><p>マインゴーシュ</p></td><td class="ce3"><p>左手用短劍</p></td><td class="ce3"> </td><td class="ce3"><p>A1</p></td><td class="ce3"><p>つちのきば</p></td><td class="ce3"><p>土之牙</p></td></tr><tr class="ro1"><td class="ce3"><p>22</p></td><td class="ce3"><p>オリハルコン</p></td><td class="ce3"><p>奧里哈康</p></td><td class="ce3"> </td><td class="ce3"><p>A2</p></td><td class="ce3"><p>ノアのリュート</p></td><td class="ce3"><p>諾亞的琵琶琴</p></td></tr><tr class="ro1"><td class="ce3"><p>23</p></td><td class="ce3"><p>エアーナイフ</p></td><td class="ce3"><p>氣動刀</p></td><td class="ce3"> </td><td class="ce3"><p>A3</p></td><td class="ce3"><p>シルクスのかぎ</p></td><td class="ce3"><p>希魯克斯的鑰匙</p></td></tr><tr class="ro1"><td class="ce3"><p>24</p></td><td class="ce3"><p>ロングソード</p></td><td class="ce3"><p>長劍</p></td><td class="ce3"> </td><td class="ce3"><p>A4</p></td><td class="ce3"><p>こびとのパン</p></td><td class="ce3"><p>小人麵包</p></td></tr><tr class="ro1"><td class="ce3"><p>25</p></td><td class="ce3"><p>ワイトスレィャー</p></td><td class="ce3"><p>責殺劍</p></td><td class="ce3"> </td><td class="ce3"><p>A5</p></td><td class="ce3"><p>?????????</p></td><td class="ce3"><p>?????????</p></td></tr><tr class="ro1"><td class="ce3"><p>26</p></td><td class="ce3"><p>きんきらのつゐぎ</p></td><td class="ce3"><p>光亮之劍</p></td><td class="ce3"> </td><td class="ce3"><p>A6</p></td><td class="ce3"><p>ポーション</p></td><td class="ce3"><p>恢復劑</p></td></tr><tr class="ro1"><td class="ce3"><p>27</p></td><td class="ce3"><p>ミスリルソード</p></td><td class="ce3"><p>米斯理魯劍</p></td><td class="ce3"> </td><td class="ce3"><p>A7</p></td><td class="ce3"><p>ハイポーション</p></td><td class="ce3"><p>強力恢復劑</p></td></tr><tr class="ro1"><td class="ce3"><p>28</p></td><td class="ce3"><p>サーベントソード</p></td><td class="ce3"><p>蛇劍</p></td><td class="ce3"> </td><td class="ce3"><p>A8</p></td><td class="ce3"><p>エリワサー</p></td><td class="ce3"><p>聖靈藥</p></td></tr><tr class="ro1"><td class="ce3"><p>29</p></td><td class="ce3"><p>フリーズブレイド</p></td><td class="ce3"><p>冰凍劍</p></td><td class="ce3"> </td><td class="ce3"><p>A9</p></td><td class="ce3"><p>フニッワスのぉ</p></td><td class="ce3"><p>不死鳥的尾巴</p></td></tr><tr class="ro1"><td class="ce3"><p>2A</p></td><td class="ce3"><p>ティルヴィング</p></td><td class="ce3"><p>迪魯威古劍</p></td><td class="ce3"> </td><td class="ce3"><p>AA</p></td><td class="ce3"><p>きんのはり</p></td><td class="ce3"><p>金針</p></td></tr><tr class="ro1"><td class="ce3"><p>2B</p></td><td class="ce3"><p>サラマンドソード</p></td><td class="ce3"><p>火蛇劍</p></td><td class="ce3"> </td><td class="ce3"><p>AB</p></td><td class="ce3"><p>ぉとめのキッス</p></td><td class="ce3"><p>少女之吻</p></td></tr><tr class="ro1"><td class="ce3"><p>2C</p></td><td class="ce3"><p>キングスソード</p></td><td class="ce3"><p>國王劍</p></td><td class="ce3"> </td><td class="ce3"><p>AC</p></td><td class="ce3"><p>やまびこそう</p></td><td class="ce3"><p>回聲草</p></td></tr><tr class="ro1"><td class="ce3"><p>2D</p></td><td class="ce3"><p>ダブルマホーワ</p></td><td class="ce3"><p>雙刃戰斧</p></td><td class="ce3"> </td><td class="ce3"><p>AD</p></td><td class="ce3"><p>うちでのこづち</p></td><td class="ce3"><p>萬寶槌</p></td></tr><tr class="ro1"><td class="ce3"><p>2E</p></td><td class="ce3"><p>こだいのつゐぎ</p></td><td class="ce3"><p>古代之劍</p></td><td class="ce3"> </td><td class="ce3"><p>AE</p></td><td class="ce3"><p>めぐすり</p></td><td class="ce3"><p>眼藥水</p></td></tr><tr class="ro1"><td class="ce3"><p>2F</p></td><td class="ce3"><p>ぁしゆら</p></td><td class="ce3"><p>阿修羅劍</p></td><td class="ce3"> </td><td class="ce3"><p>AF</p></td><td class="ce3"><p>どくけし</p></td><td class="ce3"><p>解毒藥</p></td></tr><tr class="ro1"><td class="ce3"><p>30</p></td><td class="ce3"><p>ブラッドソード</p></td><td class="ce3"><p>吸魂劍</p></td><td class="ce3"> </td><td class="ce3"><p>B0</p></td><td class="ce3"><p>ラッコのあたま</p></td><td class="ce3"><p>海龍頭</p></td></tr><tr class="ro1"><td class="ce3"><p>31</p></td><td class="ce3"><p>ディフェンダー</p></td><td class="ce3"><p>防禦劍</p></td><td class="ce3"> </td><td class="ce3"><p>B1</p></td><td class="ce3"><p>ホムのかけら</p></td><td class="ce3"><p>炸彈的碎片</p></td></tr><tr class="ro1"><td class="ce3"><p>32</p></td><td class="ce3"><p>トリトンハンマー</p></td><td class="ce3"><p>托利通槌</p></td><td class="ce3"> </td><td class="ce3"><p>B2</p></td><td class="ce3"><p>なんきょくのかぜ</p></td><td class="ce3"><p>南極風</p></td></tr><tr class="ro1"><td class="ce3"><p>33</p></td><td class="ce3"><p>こてつ</p></td><td class="ce3"><p>虎徹劍</p></td><td class="ce3"> </td><td class="ce3"><p>B3</p></td><td class="ce3"><p>ゼウスのいかり</p></td><td class="ce3"><p>宙斯之怒</p></td></tr><tr class="ro1"><td class="ce3"><p>34</p></td><td class="ce3"><p>きくいちもんじ</p></td><td class="ce3"><p>菊一文字劍</p></td><td class="ce3"> </td><td class="ce3"><p>B4</p></td><td class="ce3"><p>ボムのみぎうで</p></td><td class="ce3"><p>波姆的右手</p></td></tr><tr class="ro1"><td class="ce3"><p>35</p></td><td class="ce3"><p>ブレィクブレイド</p></td><td class="ce3"><p>破裂劍</p></td><td class="ce3"> </td><td class="ce3"><p>B5</p></td><td class="ce3"><p>ほつきょくのかぜ</p></td><td class="ce3"><p>北極風</p></td></tr><tr class="ro1"><td class="ce3"><p>36</p></td><td class="ce3"><p>エワスカリバー</p></td><td class="ce3"><p>石中劍</p></td><td class="ce3"> </td><td class="ce3"><p>B6</p></td><td class="ce3"><p>かみがみのいかり</p></td><td class="ce3"><p>眾神之怒</p></td></tr><tr class="ro1"><td class="ce3"><p>37</p></td><td class="ce3"><p>マサムネ</p></td><td class="ce3"><p>正宗劍</p></td><td class="ce3"> </td><td class="ce3"><p>B7</p></td><td class="ce3"><p>だいちのドラム</p></td><td class="ce3"><p>大地之鼓</p></td></tr><tr class="ro1"><td class="ce3"><p>38</p></td><td class="ce3"><p>ラグナロク</p></td><td class="ce3"><p>拉格納洛克</p></td><td class="ce3"> </td><td class="ce3"><p>B8</p></td><td class="ce3"><p>ラミアのうろこ</p></td><td class="ce3"><p>拉米亞之鱗</p></td></tr><tr class="ro1"><td class="ce3"><p>39</p></td><td class="ce3"><p>オニオンソード</p></td><td class="ce3"><p>洋蔥劍</p></td><td class="ce3"> </td><td class="ce3"><p>B9</p></td><td class="ce3"><p>バッカスのさけ</p></td><td class="ce3"><p>巴加斯酒</p></td></tr><tr class="ro1"><td class="ce3"><p>3A</p></td><td class="ce3"><p>ほのおのほん</p></td><td class="ce3"><p>火焰之書</p></td><td class="ce3"> </td><td class="ce3"><p>BA</p></td><td class="ce3"><p>かめのこうら</p></td><td class="ce3"><p>龜甲</p></td></tr><tr class="ro1"><td class="ce3"><p>3B</p></td><td class="ce3"><p>こおりのほん</p></td><td class="ce3"><p>冰凍之書</p></td><td class="ce3"> </td><td class="ce3"><p>BB</p></td><td class="ce3"><p>あくまのためいき</p></td><td class="ce3"><p>惡魔的嘆息</p></td></tr><tr class="ro1"><td class="ce3"><p>3C</p></td><td class="ce3"><p>ほのおのじてん</p></td><td class="ce3"><p>火焰字典</p></td><td class="ce3"> </td><td class="ce3"><p>BC</p></td><td class="ce3"><p>ブラッワホール</p></td><td class="ce3"><p>黑洞</p></td></tr><tr class="ro1"><td class="ce3"><p>3D</p></td><td class="ce3"><p>ひかリのほん</p></td><td class="ce3"><p>光亮之書</p></td><td class="ce3"> </td><td class="ce3"><p>BD</p></td><td class="ce3"><p>くろのかぉり</p></td><td class="ce3"><p>黑色的氣味</p></td></tr><tr class="ro1"><td class="ce3"><p>3E</p></td><td class="ce3"><p>ひかりのじてん</p></td><td class="ce3"><p>光亮字典</p></td><td class="ce3"> </td><td class="ce3"><p>BE</p></td><td class="ce3"><p>リリスのくちづけ</p></td><td class="ce3"><p>莉莉絲之吻</p></td></tr><tr class="ro1"><td class="ce3"><p>3F</p></td><td class="ce3"><p>ブーメラン</p></td><td class="ce3"><p>回力鏢</p></td><td class="ce3"> </td><td class="ce3"><p>BF</p></td><td class="ce3"><p>てんぐのあくび</p></td><td class="ce3"><p>天狗的哈欠</p></td></tr><tr class="ro1"><td class="ce3"><p>40</p></td><td class="ce3"><p>えんげつりん</p></td><td class="ce3"><p>圓月輪</p></td><td class="ce3"> </td><td class="ce3"><p>C0</p></td><td class="ce3"><p>かめのこうらゎり</p></td><td class="ce3"><p>打破龜甲的斧頭</p></td></tr><tr class="ro1"><td class="ce3"><p>41</p></td><td class="ce3"><p>しゆうけん</p></td><td class="ce3"><p>飛鏢</p></td><td class="ce3"> </td><td class="ce3"><p>C1</p></td><td class="ce3"><p>ますいばり</p></td><td class="ce3"><p>麻醉針</p></td></tr><tr class="ro1"><td class="ce3"><p>42</p></td><td class="ce3"><p>こおりのじてん</p></td><td class="ce3"><p>冰凍字典</p></td><td class="ce3"> </td><td class="ce3"><p>C2</p></td><td class="ce3"><p>ちんもくのおふだ</p></td><td class="ce3"><p>沉默之牌</p></td></tr><tr class="ro1"><td class="ce3"><p>43</p></td><td class="ce3"><p>ギャマンのベル</p></td><td class="ce3"><p>玻璃鈴</p></td><td class="ce3"> </td><td class="ce3"><p>C3</p></td><td class="ce3"><p>ひつじのまくら</p></td><td class="ce3"><p>山羊的枕頭</p></td></tr><tr class="ro1"><td class="ce3"><p>44</p></td><td class="ce3"><p>だいちのべル</p></td><td class="ce3"><p>大地之鈴</p></td><td class="ce3"> </td><td class="ce3"><p>C4</p></td><td class="ce3"><p>ボムのあたま</p></td><td class="ce3"><p>炸彈之頭</p></td></tr><tr class="ro1"><td class="ce3"><p>45</p></td><td class="ce3"><p>ルーンのベル</p></td><td class="ce3"><p>古文之鈴</p></td><td class="ce3"> </td><td class="ce3"><p>C5</p></td><td class="ce3"><p>ひかりのカーテン</p></td><td class="ce3"><p>光的窗簾</p></td></tr><tr class="ro1"><td class="ce3"><p>46</p></td><td class="ce3"><p>マドラのたてごと</p></td><td class="ce3"><p>馬多拉豎琴</p></td><td class="ce3"> </td><td class="ce3"><p>C6</p></td><td class="ce3"><p>チョコボのいかり</p></td><td class="ce3"><p>陸行鳥之怒</p></td></tr><tr class="ro1"><td class="ce3"><p>47</p></td><td class="ce3"><p>ゆめのたてごと</p></td><td class="ce3"><p>夢豎琴</p></td><td class="ce3"> </td><td class="ce3"><p>C7</p></td><td class="ce3"><p>しろのかぉり</p></td><td class="ce3"><p>白色的氣味</p></td></tr><tr class="ro1"><td class="ce3"><p>48</p></td><td class="ce3"><p>ラミのたてごと</p></td><td class="ce3"><p>拉米亞豎琴</p></td><td class="ce3"> </td><td class="ce3 even"><p>C8</p></td><td class="ce3 even"><p>フレア</p></td><td class="ce3 even"><p>核融術</p></td></tr><tr class="ro1"><td class="ce3"><p>49</p></td><td class="ce3"><p>ロキのたてごと</p></td><td class="ce3"><p>洛基豎琴</p></td><td class="ce3"> </td><td class="ce3 even"><p>C9</p></td><td class="ce3 even"><p>デス</p></td><td class="ce3 even"><p>即死術</p></td></tr><tr class="ro1"><td class="ce3"><p>4A</p></td><td class="ce3"><p>ゆみ</p></td><td class="ce3"><p>弓</p></td><td class="ce3"> </td><td class="ce3 even"><p>CA</p></td><td class="ce3 even"><p>メテォ</p></td><td class="ce3 even"><p>變異術</p></td></tr><tr class="ro1"><td class="ce3"><p>4B</p></td><td class="ce3"><p>ゲレートボウ</p></td><td class="ce3"><p>巨弓</p></td><td class="ce3"> </td><td class="ce3 even"><p>CB</p></td><td class="ce3 even"><p>トルネド</p></td><td class="ce3 even"><p>集能術</p></td></tr><tr class="ro1"><td class="ce3"><p>4C</p></td><td class="ce3"><p>キラーボウ</p></td><td class="ce3"><p>殺人弓</p></td><td class="ce3"> </td><td class="ce3 even"><p>CC</p></td><td class="ce3 even"><p>アレイズ</p></td><td class="ce3 even"><p>新復活術</p></td></tr><tr class="ro1"><td class="ce3"><p>4D</p></td><td class="ce3"><p>ルーンのゆみ</p></td><td class="ce3"><p>古文之弓</p></td><td class="ce3"> </td><td class="ce3 even"><p>CD</p></td><td class="ce3 even"><p>ホーリー</p></td><td class="ce3 even"><p>毀滅術</p></td></tr><tr class="ro1"><td class="ce3"><p>4E</p></td><td class="ce3"><p>よいちのゆみ</p></td><td class="ce3"><p>高性能弓</p></td><td class="ce3"> </td><td class="ce3 even"><p>CE</p></td><td class="ce3 even"><p>バハムル</p></td><td class="ce3 even"><p>巴哈姆特</p></td></tr><tr class="ro1"><td class="ce3"><p>4F</p></td><td class="ce3"><p>きのや</p></td><td class="ce3"><p>木箭</p></td><td class="ce3"> </td><td class="ce3"><p>CF</p></td><td class="ce3"><p>クュイク</p></td><td class="ce3"><p>震裂術</p></td></tr><tr class="ro1"><td class="ce3"><p>50</p></td><td class="ce3"><p>せいなゐや</p></td><td class="ce3"><p>聖箭</p></td><td class="ce3"> </td><td class="ce3"><p>D0</p></td><td class="ce3"><p>ブレクガ</p></td><td class="ce3"><p>超石化術</p></td></tr><tr class="ro1"><td class="ce3"><p>51</p></td><td class="ce3"><p>てつのや</p></td><td class="ce3"><p>鐵箭</p></td><td class="ce3"> </td><td class="ce3"><p>D1</p></td><td class="ce3"><p>ドレイン</p></td><td class="ce3"><p>奪魂術</p></td></tr><tr class="ro1"><td class="ce3"><p>52</p></td><td class="ce3"><p>いかづちのや</p></td><td class="ce3"><p>雷電箭</p></td><td class="ce3"> </td><td class="ce3"><p>D2</p></td><td class="ce3"><p>クアルガ</p></td><td class="ce3"><p>超回力術</p></td></tr><tr class="ro1"><td class="ce3"><p>53</p></td><td class="ce3"><p>ほのおのや</p></td><td class="ce3"><p>火焰箭</p></td><td class="ce3"> </td><td class="ce3"><p>D3</p></td><td class="ce3"><p>エスナ</p></td><td class="ce3"><p>驅魔術</p></td></tr><tr class="ro1"><td class="ce3"><p>54</p></td><td class="ce3"><p>こおりのや</p></td><td class="ce3"><p>冰凍箭</p></td><td class="ce3"> </td><td class="ce3"><p>D4</p></td><td class="ce3"><p>リフレク</p></td><td class="ce3"><p>攻防術</p></td></tr><tr class="ro1"><td class="ce3"><p>55</p></td><td class="ce3"><p>メデューサのや</p></td><td class="ce3"><p>蛇髮女妖的箭</p></td><td class="ce3"> </td><td class="ce3"><p>D5</p></td><td class="ce3"><p>リバイア</p></td><td class="ce3"><p>利貝亞</p></td></tr><tr class="ro1"><td class="ce3"><p>56</p></td><td class="ce3"><p>よいちのや</p></td><td class="ce3"><p>高性能箭</p></td><td class="ce3"> </td><td class="ce3 even"><p>D6</p></td><td class="ce3 even"><p>ファイガ</p></td><td class="ce3 even"><p>超火球術</p></td></tr><tr class="ro1"><td class="ce3"><p>57</p></td><td class="ce3"><p>???</p></td><td class="ce3"><p>拳套飛鏢</p></td><td class="ce3"> </td><td class="ce3 even"><p>D7</p></td><td class="ce3 even"><p>バアォ</p></td><td class="ce3 even"><p>生物術</p></td></tr><tr class="ro1"><td class="ce3"><p>58</p></td><td class="ce3"><p>かわのたて</p></td><td class="ce3"><p>皮革盾牌</p></td><td class="ce3"> </td><td class="ce3 even"><p>D8</p></td><td class="ce3 even"><p>デジョン</p></td><td class="ce3 even"><p>異次元術</p></td></tr><tr class="ro1"><td class="ce3"><p>59</p></td><td class="ce3"><p>オニオンシールド</p></td><td class="ce3"><p>洋蔥盾牌</p></td><td class="ce3"> </td><td class="ce3 even"><p>D9</p></td><td class="ce3 even"><p>エアロガ</p></td><td class="ce3 even"><p>超動氣術</p></td></tr><tr class="ro1"><td class="ce3"><p>5A</p></td><td class="ce3"><p>ミスリルのたて</p></td><td class="ce3"><p>米斯理魯盾牌</p></td><td class="ce3"> </td><td class="ce3 even"><p>DA</p></td><td class="ce3 even"><p>ストナ</p></td><td class="ce3 even"><p>溶石術</p></td></tr><tr class="ro1"><td class="ce3"><p>5B</p></td><td class="ce3"><p>アイスシールド</p></td><td class="ce3"><p>冰凍盾牌</p></td><td class="ce3"> </td><td class="ce3 even"><p>DB</p></td><td class="ce3 even"><p>ヘイスト</p></td><td class="ce3 even"><p>快速術</p></td></tr><tr class="ro1"><td class="ce3"><p>5C</p></td><td class="ce3"><p>ゆうしやのたて</p></td><td class="ce3"><p>勇者的盾牌</p></td><td class="ce3"> </td><td class="ce3 even"><p>DC</p></td><td class="ce3 even"><p>カタスト</p></td><td class="ce3 even"><p>奧丁</p></td></tr><tr class="ro1"><td class="ce3"><p>5D</p></td><td class="ce3"><p>デモンズシールド</p></td><td class="ce3"><p>惡魔盾牌</p></td><td class="ce3"> </td><td class="ce3"><p>DD</p></td><td class="ce3"><p>サンダガ</p></td><td class="ce3"><p>超閃電術</p></td></tr><tr class="ro1"><td class="ce3"><p>5E</p></td><td class="ce3"><p>ダィヤシールド</p></td><td class="ce3"><p>鑽石盾牌</p></td><td class="ce3"> </td><td class="ce3"><p>DE</p></td><td class="ce3"><p>キル</p></td><td class="ce3"><p>殺戮術</p></td></tr><tr class="ro1"><td class="ce3"><p>5F</p></td><td class="ce3"><p>イージスのたて</p></td><td class="ce3"><p>傳說之盾牌</p></td><td class="ce3"> </td><td class="ce3"><p>DF</p></td><td class="ce3"><p>イレース</p></td><td class="ce3"><p>破咒術</p></td></tr><tr class="ro1"><td class="ce3"><p>60</p></td><td class="ce3"><p>げんじのたて</p></td><td class="ce3"><p>源氏盾牌</p></td><td class="ce3"> </td><td class="ce3"><p>E0</p></td><td class="ce3"><p>クアルダ</p></td><td class="ce3"><p>強回力術</p></td></tr><tr class="ro1"><td class="ce3"><p>61</p></td><td class="ce3"><p>ワリスタルのたて</p></td><td class="ce3"><p>水晶盾牌</p></td><td class="ce3"> </td><td class="ce3"><p>E1</p></td><td class="ce3"><p>レトズ</p></td><td class="ce3"><p>復活術</p></td></tr><tr class="ro1"><td class="ce3"><p>62</p></td><td class="ce3"><p>かわのぼうし</p></td><td class="ce3"><p>皮革帽子</p></td><td class="ce3"> </td><td class="ce3"><p>E2</p></td><td class="ce3"><p>プロテス</p></td><td class="ce3"><p>護壁層</p></td></tr><tr class="ro1"><td class="ce3"><p>63</p></td><td class="ce3"><p>オニオンヘルム</p></td><td class="ce3"><p>洋蔥頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>E3</p></td><td class="ce3"><p>ハイパ</p></td><td class="ce3"><p>泰坦</p></td></tr><tr class="ro1"><td class="ce3"><p>64</p></td><td class="ce3"><p>ミスリルかぶと</p></td><td class="ce3"><p>米斯理魯頭盔</p></td><td class="ce3"> </td><td class="ce3 even"><p>E4</p></td><td class="ce3 even"><p>ブレイク</p></td><td class="ce3 even"><p>石化術</p></td></tr><tr class="ro1"><td class="ce3"><p>65</p></td><td class="ce3"><p>ツノガイのかぶと</p></td><td class="ce3"><p>角貝頭盔</p></td><td class="ce3"> </td><td class="ce3 even"><p>E5</p></td><td class="ce3 even"><p>ブリサガ</p></td><td class="ce3 even"><p>超冷風術</p></td></tr><tr class="ro1"><td class="ce3"><p>66</p></td><td class="ce3"><p>アイスヘルム</p></td><td class="ce3"><p>冰凍頭盔</p></td><td class="ce3"> </td><td class="ce3 even"><p>E6</p></td><td class="ce3 even"><p>シェイト</p></td><td class="ce3 even"><p>遮光術</p></td></tr><tr class="ro1"><td class="ce3"><p>67</p></td><td class="ce3"><p>はちまき</p></td><td class="ce3"><p>纏頭帶</p></td><td class="ce3"> </td><td class="ce3 even"><p>E7</p></td><td class="ce3 even"><p>ライブラ</p></td><td class="ce3 even"><p>診斷術</p></td></tr><tr class="ro1"><td class="ce3"><p>68</p></td><td class="ce3"><p>がくしゃのぼうし</p></td><td class="ce3"><p>學者的帽子</p></td><td class="ce3"> </td><td class="ce3 even"><p>E8</p></td><td class="ce3 even"><p>コンフエ</p></td><td class="ce3 even"><p>混亂術</p></td></tr><tr class="ro1"><td class="ce3"><p>69</p></td><td class="ce3"><p>くろずきん</p></td><td class="ce3"><p>黑領巾</p></td><td class="ce3"> </td><td class="ce3 even"><p>E9</p></td><td class="ce3 even"><p>サイレス</p></td><td class="ce3 even"><p>沉默術</p></td></tr><tr class="ro1"><td class="ce3"><p>6A</p></td><td class="ce3"><p>チャヮラバンド</p></td><td class="ce3"><p>斬飛頭帶</p></td><td class="ce3"> </td><td class="ce3 even"><p>EA</p></td><td class="ce3 even"><p>ヒートラ</p></td><td class="ce3 even"><p>伊弗利特</p></td></tr><tr class="ro1"><td class="ce3"><p>6B</p></td><td class="ce3"><p>バイキングヘルム</p></td><td class="ce3"><p>維京頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>EB</p></td><td class="ce3"><p>ファイラ</p></td><td class="ce3"><p>強火球術</p></td></tr><tr class="ro1"><td class="ce3"><p>6C</p></td><td class="ce3"><p>ドラゴンヘルム</p></td><td class="ce3"><p>龍之頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>EC</p></td><td class="ce3"><p>ブリザラ</p></td><td class="ce3"><p>強冷風術</p></td></tr><tr class="ro1"><td class="ce3"><p>6D</p></td><td class="ce3"><p>はねつきぼうし</p></td><td class="ce3"><p>羽毛帽子</p></td><td class="ce3"> </td><td class="ce3"><p>ED</p></td><td class="ce3"><p>サンダラ</p></td><td class="ce3"><p>強閃電術</p></td></tr><tr class="ro1"><td class="ce3"><p>6E</p></td><td class="ce3"><p>ダイャのかぶと</p></td><td class="ce3"><p>鑽石頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>EE</p></td><td class="ce3"><p>クアルラ</p></td><td class="ce3"><p>中回力</p></td></tr><tr class="ro1"><td class="ce3"><p>6F</p></td><td class="ce3"><p>げんじのかぶと</p></td><td class="ce3"><p>源氏頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>EF</p></td><td class="ce3"><p>テレポ</p></td><td class="ce3"><p>跳躍術</p></td></tr><tr class="ro1"><td class="ce3"><p>70</p></td><td class="ce3"><p>ワリスタルヘルム</p></td><td class="ce3"><p>水晶頭盔</p></td><td class="ce3"> </td><td class="ce3"><p>F0</p></td><td class="ce3"><p>ブライナ</p></td><td class="ce3"><p>復明術</p></td></tr><tr class="ro1"><td class="ce3"><p>71</p></td><td class="ce3"><p>リボン</p></td><td class="ce3"><p>緞帶</p></td><td class="ce3"> </td><td class="ce3"><p>F1</p></td><td class="ce3"><p>スパルク</p></td><td class="ce3"><p>雷神拉默</p></td></tr><tr class="ro1"><td class="ce3"><p>72</p></td><td class="ce3"><p>ふく</p></td><td class="ce3"><p>衣服</p></td><td class="ce3"> </td><td class="ce3 even"><p>F2</p></td><td class="ce3 even"><p>サンダー</p></td><td class="ce3 even"><p>閃電術</p></td></tr><tr class="ro1"><td class="ce3"><p>73</p></td><td class="ce3"><p>かわよろい</p></td><td class="ce3"><p>皮革鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F3</p></td><td class="ce3 even"><p>ポイズン</p></td><td class="ce3 even"><p>落毒術</p></td></tr><tr class="ro1"><td class="ce3"><p>74</p></td><td class="ce3"><p>オニオンアーマー</p></td><td class="ce3"><p>洋蔥鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F4</p></td><td class="ce3 even"><p>ブライラ</p></td><td class="ce3 even"><p>黑暗術</p></td></tr><tr class="ro1"><td class="ce3"><p>75</p></td><td class="ce3"><p>ミスリルアーマー</p></td><td class="ce3"><p>米斯理魯鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F5</p></td><td class="ce3 even"><p>エアロ</p></td><td class="ce3 even"><p>動氣術</p></td></tr><tr class="ro1"><td class="ce3"><p>76</p></td><td class="ce3"><p>ツイガイのよろい</p></td><td class="ce3"><p>角貝鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F6</p></td><td class="ce3 even"><p>トード</p></td><td class="ce3 even"><p>青蛙術</p></td></tr><tr class="ro1"><td class="ce3"><p>77</p></td><td class="ce3"><p>アィスアーマー</p></td><td class="ce3"><p>冰凍鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F7</p></td><td class="ce3 even"><p>ミニマム</p></td><td class="ce3 even"><p>縮小術</p></td></tr><tr class="ro1"><td class="ce3"><p>78</p></td><td class="ce3"><p>フレイムメイル</p></td><td class="ce3"><p>火焰鎧甲</p></td><td class="ce3"> </td><td class="ce3 even"><p>F8</p></td><td class="ce3 even"><p>アイスン</p></td><td class="ce3 even"><p>冰精靈希娃</p></td></tr><tr class="ro1"><td class="ce3"><p>79</p></td><td class="ce3"><p>けんぼうぎ</p></td><td class="ce3"><p>拳術衣</p></td><td class="ce3"> </td><td class="ce3"><p>F9</p></td><td class="ce3"><p>ファイア</p></td><td class="ce3"><p>火球術</p></td></tr><tr class="ro1"><td class="ce3"><p>7A</p></td><td class="ce3"><p>くろしょぞく</p></td><td class="ce3"><p>黑裝束</p></td><td class="ce3"> </td><td class="ce3"><p>FA</p></td><td class="ce3"><p>ブリザド</p></td><td class="ce3"><p>冷風術</p></td></tr><tr class="ro1"><td class="ce3"><p>7B</p></td><td class="ce3"><p>まどうしのふく</p></td><td class="ce3"><p>魔導衣服</p></td><td class="ce3"> </td><td class="ce3"><p>FB</p></td><td class="ce3"><p>スリプル</p></td><td class="ce3"><p>昏睡術</p></td></tr><tr class="ro1"><td class="ce3"><p>7C</p></td><td class="ce3"><p>バイキンゲメイル</p></td><td class="ce3"><p>維京鎧甲</p></td><td class="ce3"> </td><td class="ce3"><p>FC</p></td><td class="ce3"><p>クアル</p></td><td class="ce3"><p>回力術</p></td></tr><tr class="ro1"><td class="ce3"><p>7D</p></td><td class="ce3"><p>くろおびとうき</p></td><td class="ce3"><p>黑帶小襖</p></td><td class="ce3"> </td><td class="ce3"><p>FD</p></td><td class="ce3"><p>ポイゾナ</p></td><td class="ce3"><p>解毒術</p></td></tr><tr class="ro1"><td class="ce3"><p>7E</p></td><td class="ce3"><p>ナイトのよろい</p></td><td class="ce3"><p>騎士鎧甲</p></td><td class="ce3"> </td><td class="ce3"><p>FE</p></td><td class="ce3"><p>サイトロ</p></td><td class="ce3"><p>映像術</p></td></tr><tr class="ro1"><td class="ce3"><p>7F</p></td><td class="ce3"><p>ドラゴンメイル</p></td><td class="ce3"><p>龍鎧甲</p></td><td class="ce3"> </td><td class="ce3"><p>FF</p></td><td class="ce3"><p>エスクプ</p></td><td class="ce3"><p>陸行鳥</p></td></tr><tr class="ro1"><td class="ce3"><p>80</p></td><td class="ce3"><p>しじんのふく</p></td><td class="ce3"><p>詩人之衣</p></td><td class="ce3"> </td><td class="ce3"> </td><td class="ce3"> </td><td class="ce3"> </td></tr></table><h2 id="角色能力"><a href="#角色能力" class="headerlink" title="角色能力"></a>角色能力</h2><table border="0" cellspacing="0" cellpadding="0" class="ta1"><tr class="ro1"><td class="ce1"><p>角色一</p></td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro2"><td class="ce1"><p>0x006100</p></td><td class="ce1"><p>職業</p></td><td class="ce1"><p>等級</p></td><td class="ce1"><p>狀態</p></td><td colspan="3" class="ce1"><p>經驗值</p></td><td colspan="6" class="ce1"><p>姓名</p></td><td colspan="2" class="ce1"><p>HP 現在值</p></td><td colspan="2" class="ce1"><p>HP 最大值</p></td></tr><tr class="ro3"><td class="ce1"><p>0x006110</p></td><td class="ce1"><p>熟練度</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>ちから</p><p>力</p></td><td class="ce1"><p>すばやさ</p><p>素早さ</p></td><td class="ce1"><p>たいりょく</p><p>体力</p></td><td class="ce1"><p>ちせい</p><p>知性</p></td><td class="ce1"><p>せいしん</p><p>精神</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>まほうかいひりつ</p><p>魔法回避率</p></td><td class="ce1"><p>まほう</p><p>ぼうぎょ</p><p>魔法防御</p></td></tr><tr class="ro3"><td class="ce1"><p>0x006120</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>めいちゅうりつ</p><p>命中率</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"><p>かいひりつ</p><p>回避率</p></td><td class="ce1"><p>ぼうぎょ0かい</p><p>防御0回</p></td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro2"><td class="ce1"><p>0x006130</p></td><td class="ce1"><p>MP1 現在值</p></td><td class="ce1"><p>MP1 最大值</p></td><td class="ce1"><p>MP2</p></td><td class="ce1"><p>MP2</p><p>Max</p></td><td class="ce1"><p>MP3</p></td><td class="ce1"><p>MP3</p><p>Max</p></td><td class="ce1"><p>MP4</p></td><td class="ce1"><p>MP4</p><p>Max</p></td><td class="ce1"><p>MP5</p></td><td class="ce1"><p>MP5</p><p>Max</p></td><td class="ce1"><p>MP6</p></td><td class="ce1"><p>MP6</p><p>Max</p></td><td class="ce1"><p>MP7</p></td><td class="ce1"><p>MP7</p><p>Max</p></td><td class="ce1"><p>MP8</p></td><td class="ce1"><p>MP8</p><p>Max</p></td></tr><tr class="ro1"><td class="ce1"><p>角色二</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006140</p></td><td class="ce1"><p>同上</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006150</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006160</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006170</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>角色三</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006180</p></td><td class="ce1"><p>同上</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x006190</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061A0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061B0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>角色四</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061C0</p></td><td class="ce1"><p>同上</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061D0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061E0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr><tr class="ro1"><td class="ce1"><p>0x0061F0</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr></table><p>若直接修改職業，角色的能力值不會因此而變動。需要透過轉職動作才會觸發重新計算，推薦的作法是</p><ul><li>修改到想要的等級</li><li>把水晶提供的職業打開</li><li>轉到想要的職業，讓系統重新計算能力值</li><li>把水晶職業再次關閉</li></ul><p>我自己是一開始就轉成可愛的魔人跟導師，避開使用原本的黑魔與白魔，從低等開始慢慢玩起。不然每次都沒用到土之水晶的職業，很可惜</p><h2 id="水晶提供的職業"><a href="#水晶提供的職業" class="headerlink" title="水晶提供的職業"></a>水晶提供的職業</h2><ul><li><code>0x27</code> 就是拿到土之水晶以前的所有職業<ul><li>但是土之水晶的職業需要 LV40+</li></ul></li><li><code>0xFF</code> 會拿到忍者與賢者<ul><li>但是最終職業需要 LV50+</li></ul></li></ul><p>遊戲有些邏輯會靠這個判斷，譬如說改太高的話，剛出浮游大陸就會發現外面的陸地已經浮出水面，這樣會有 bug。</p><table><tr class="ro1"><td class="ce1"> </td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006020</p></td><td class="ce1"> </td><td class="ce1"><p>可轉職業</p></td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td><td class="ce1"> </td></tr></table><p>職業熟練度</p><ul><li><code>0x00</code> 的熟練度就是 <code>1</code></li><li><code>0x62</code> 的熟練度就是 <code>99</code></li></ul><table><tr class="ro1"><td class="ce1">角色一</td><td class="ce1"><p>00</p></td><td class="ce1"><p>01</p></td><td class="ce1"><p>02</p></td><td class="ce1"><p>03</p></td><td class="ce1"><p>04</p></td><td class="ce1"><p>05</p></td><td class="ce1"><p>06</p></td><td class="ce1"><p>07</p></td><td class="ce1"><p>08</p></td><td class="ce1"><p>09</p></td><td class="ce1"><p>0A</p></td><td class="ce1"><p>0B</p></td><td class="ce1"><p>0C</p></td><td class="ce1"><p>0D</p></td><td class="ce1"><p>0E</p></td><td class="ce1"><p>0F</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006210</p></td><td class="ce1"><p>洋蔥劍士</p></td><td class="ce1"></td><td class="ce1"><p>戰士</p></td><td class="ce1"></td><td class="ce1"><p>武僧</p></td><td class="ce1"></td><td class="ce1"><p>白魔</p></td><td class="ce1"></td><td class="ce1"><p>黑魔</p></td><td class="ce1"></td><td class="ce1"><p>紅魔</p></td><td class="ce1"></td><td class="ce1"><p>獵人</p></td><td class="ce1"></td><td class="ce1"><p>騎士</p></td><td class="ce1"></td></tr></tr><tr class="ro1"><td class="ce1"><p>0x006220</p></td><td class="ce1"><p>小偷</p></td><td class="ce1"></td><td class="ce1"><p>學者</p></td><td class="ce1"></td><td class="ce1"><p>風水師</p></td><td class="ce1"></td><td class="ce1"><p>龍騎士</p></td><td class="ce1"></td><td class="ce1"><p>維京人</p></td><td class="ce1"></td><td class="ce1"><p>空手道家</p></td><td class="ce1"></td><td class="ce1"><p>魔劍士</p></td><td class="ce1"></td><td class="ce1"><p>咒術師</p></td><td class="ce1"></td></tr></tr><tr class="ro1"><td class="ce1"><p>0x006230</p></td><td class="ce1"><p>吟遊詩人</p></td><td class="ce1"></td><td class="ce1"><p>魔人</p></td><td class="ce1"></td><td class="ce1"><p>導師</p></td><td class="ce1"></td><td class="ce1"><p>魔界幻士</p></td><td class="ce1"></td><td class="ce1"><p>賢者</p></td><td class="ce1"></td><td class="ce1"><p>忍者</p></td><td class="ce1"></td><td class="ce1"><p></p></td><td class="ce1"></td><td class="ce1"><p></p></td><td class="ce1"></td></tr><tr class="ro1"><td class="ce1"><p>0x006240</p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td><td class="ce1"><p></p></td></tr><tr class="ro1"><td class="ce1"><p>角色二</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006250</p></td><td class="ce1"><p>同上</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006260</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006270</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006280</p></td></tr><tr class="ro1"><td class="ce1"><p>角色三</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006290</p></td><td class="ce1"><p>同上</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062A0</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062B0</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062C0</p></td></tr><tr class="ro1"><td class="ce1"><p>角色四</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062D0</p></td><td class="ce1"><p>同上</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062E0</p></td></tr><tr class="ro1"><td class="ce1"><p>0x0062F0</p></td></tr><tr class="ro1"><td class="ce1"><p>0x006300</p></td></tr></table>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    table {
        border-collapse:collapse;
        border-spacing:0;
        empty-cells:show
    }

    table, tr, td {
        border: 0.5px solid grey;
        text-align: center;
    }

    table.items td {
        text-align: left;
    }

    table.items p {
        margin-left: 5px;
    }

    .ce1 {
        font-size:10pt;
        border-top-style:solid;
        border-top-color:#00000;
        width:0.8in;
    }

    .ce2 {
        font-size:10pt;
        border-top-style:solid;
        border-top-color:#00000;
        width:1.2in;
    }

    col {
        text-align: left;
    }

    .even {
        background: rgb(230,230 ,230);
    }

    .ce3 {
        font-size:10pt;
        border-top-style:solid;
        border-top-color:#00000;
    }

    table p {
        margin-top: 0px;
        margin-bottom: 0px;
        text-shadow: none;
    }

    .special {
        background: grey;
        color: white;
    }

&lt;/style&gt;


&lt;p&gt;最近重溫了 FC 版本的 FF3，因為懶得老老實實練功，所以直接動手修改數值，順手紀錄如何修改&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot OAuth 如何使用 Mock Server</title>
    <link href="https://jchu.cc/2023/02/23-oauth.html"/>
    <id>https://jchu.cc/2023/02/23-oauth.html</id>
    <published>2023-02-23T10:25:11.000Z</published>
    <updated>2023-02-23T10:13:10.971Z</updated>
    
    <content type="html"><![CDATA[<style>    .roast {        font-size: 0.9rem;        color: #888;    }</style><p>開發 Web 服務時，使用者的登入與驗證一直都是重要的課題，其中 OAuth 也是常被討論的部分。雖然 OAuth 已經相當成熟，但是 Spring Boot 的文件裡，使用 OAuth 的相關資訊通常都比較零散。</p><p>本文紀錄我學習 Spring Boot / Spring Security + OAuth 過程中的理解與心得</p><span id="more"></span><h1 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h1><p><strong>希望用 OAuth Code Grant Flow 登入 Google 帳號，並且在開發過程中能夠使用 Mock OAuth Authorization Server，分辨登入不同的登入者，給予有差異的權限</strong></p><p>保存 User 的密碼一直都是服務端的麻煩事，對使用者來說，重新創建新帳號也同樣麻煩。我打算要架給自己用的簡單服務，最直覺的想法就是把管帳號這件事情委託給既有的大公司，只需確認登入者的 email 是否在白名單以內就好。於是 OAuth/OpenID 就是可接受的方法。</p><p>其次，在開發週期我希望能夠用假的 OAuth Authorization Server 提供登入功能，而非使用 Google/Github 之類的真實服務。</p><p>這樣的好處在於有個可預測結果的開發環境，寫測試會比較簡單<span class="roast">(雖然我還想不到該有哪些測試)</span>。開發環境也可輕易重製，任何新進成員都能快速進入狀況<span class="roast">(哪來的新進成員)</span>。自己學新東西，反正也沒有時程壓力，倒不如按照老派的實踐，一步步慢慢做下去。</p><p>話說回來，使用真實的 Google/Github 會有其他好處：既然開發都是拿 prodcution 來運作，照理最容易早期發現早期治療<span class="roast">(I don’t always test my code. But when I do, I do it in production)</span>。何況 OAuth 已經相當穩定，不使用 Mock Server 也有道理。但是站在學習的出發點，仔細地區分開發與產品的環境並且使用 Mock Server，的確讓我在這個課題學到不少原本沒想到的東西。</p><p>以下從最簡單的地方開始，每次改變一個小的變因，逐步地過渡到最終目標。</p><ul><li>使用 OAuth 之前的準備動作，了解相關知識</li><li>先跑起官方的範例，連上 Github Server<ul><li>接著換掉 Github 改用 Google Server</li><li>透過手動設定 ClientRegistration，理解該如何新增一個客製的 OAuth Authorization Server</li></ul></li><li>在自己的 Spring App 裡面實作官方範例做過的事情</li><li>在自己的 Spring App 接上 MockServer</li><li>探討登入後的下一步</li></ul><p>用圖片來表示就是這樣</p><figure class="img"><img src="/2023/02/23-oauth/learning_flow.svg" class=""></figure><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>OAuth 有四種授權流程，我只聚焦在最常見的 Authorization Code Grant Flow</li><li>本篇盡可能講解最小限度的實作，釐清核心概念</li><li>Spring Boot 的版本<ul><li>Spring Boot 的 API 可能會改變，所以內文講的東西可能會跟你所用的版本稍有出入</li><li>原本使用 2022/10/20 釋出的 <a href="https://github.com/spring-projects/spring-boot/releases/tag/v2.7.5">Spring Boot 2.7.5</a></li><li>後來改成了 2023/01/20 釋出的 <a href="https://github.com/spring-projects/spring-boot/releases/tag/v3.0.2">Spring boot 3.0.2</a></li><li>版本升級之後只有幾個地方有 Migration，核心程式碼的邏輯原則上不變</li></ul></li><li>使用 <a href="https://github.com/spring-projects/spring-security-samples/commit/9f6b38bf33c9519e3a0ce974fbc934a0c634135f">5.8.x(9f6b38bf33c) 的 Spring Security Samples</a></li></ul><h1 id="前期準備"><a href="#前期準備" class="headerlink" title="前期準備"></a>前期準備</h1><h2 id="準備工作：理解-OAuth-規格"><a href="#準備工作：理解-OAuth-規格" class="headerlink" title="準備工作：理解 OAuth 規格"></a>準備工作：理解 OAuth 規格</h2><p>要使用 OAuth，當然要先有基本的理解。網路上已經有許多完整的解說，譬如鴨七已經詳細地提供了 <a href="https://blog.yorkxin.org/posts/oauth2-1-introduction/">OAuth 2.0 筆記</a>。這邊只說明最基礎的部分</p><figure class="img"><img src="/2023/02/23-oauth/oauth_roles.svg" class=""></figure><p>舉例來說，我們會把檔案存在 Google Drive，接著希望讓自己寫的 Web App 去取用這個檔案，此時</p><ul><li>放的檔案就叫 Resource</li><li>存放檔案的地方就是 <code>Resource Server</code></li><li>擁有 Resource 的人，就是 Resource Owner，又稱 <code>User</code></li><li>驗證有沒有資格存取檔案的伺服器，就是 <code>Authorization Server</code></li><li>我們要實作的 Web App 就是 <code>Client</code></li></ul><p>常常會發現 Authorization Server 跟 Resource Server 是同一個(好比接下來會用到的 Mock OAuth Server)，但是在 OAuth 的規範裡，這兩者可以是完全不同的 Server</p><p>每個角色之間比較詳細的互動流程如下</p><figure class="img" style="max-width: 100%;"><img src="/2023/02/23-oauth/oauth_sequence.svg" class="" title="互動流程圖">    <figcaption>        <b>角色互動流程圖</b>，後文只要提到流程圖就是這一張    </figcaption></figure><p>流程圖的 2, 6, 8, 10 步驟的註解，代表的是我們需要提供給 Spring Security 的資訊，內容會因實作使用的伺服器而有差異</p><ul><li>在 Client 填入 <strong>authorizationUri</strong><ul><li>讓 Client 知道要打開哪個頁面開始進行 OAuth</li></ul></li><li>在 Authorization Server 填入 <strong>Authorization callback Uri</strong><ul><li>User 同意之後，Authorization Sever 要開啟我們的 Spring Web App</li><li>資訊會夾在 uri 裡面</li></ul></li><li>在 Client 填入 <strong>tokenUri</strong><ul><li>Spring Web App 從這個 Token uri 用 authorization code 換回 Access token</li></ul></li><li>在 Client 填入 <strong>userInfoUri</strong><ul><li>Spring Web App 用 access token 取得 Resource，在我們的使用情境該 Resource 就是 User Info</li></ul></li></ul><p>只要填完正確的資訊(當然除了這些 Uri，另外還有 Secrect key 之類的字串)，Spring Security 的 OAuth 實作就能跑完 2 ~ 11 步驟，我們不用操心太多。</p><p>在詳細解說該怎麼填充之前，先來設定 Authorization Server。假設 Client (我們的 local spring app) 會跑在 <code>https://localhost:8080</code>， 以 Github 跟 Google 為例，設定的方法如下</p><h2 id="準備工作：設定-Github-OAuth"><a href="#準備工作：設定-Github-OAuth" class="headerlink" title="準備工作：設定 Github OAuth"></a>準備工作：設定 Github OAuth</h2><p>管理你的 Github OAuth apps，請到 <a href="https://github.com/settings/developers">https://github.com/settings/developers</a></p><figure class="img" style="max-width: 500px;"><img src="/2023/02/23-oauth/github_oauth_01.jpg" class="">    <figcaption>        登入 Github 之後打開 Settings / 左側的 Sidebar 選 Developer Settings / OAuth Apps / 選 New OAuth Apps，創建一個新的 OAuth Apps    </figcaption></figure><figure class="img">    <img src="/2023/02/23-oauth/github_oauth_02.jpg" class="">    <figcaption>        Authorization callback URL 填入 http://localhost:8080/login/oauth2/code/client-id，這就是流程圖第六步會用到的 Callback Uri    </figcaption></figure><figure class="img"><img src="/2023/02/23-oauth/github_oauth_03.jpg" class=""></figure><p>點下 Generate a new client secret，並且記下這兩個字串 (ps. 這些是經過我亂改的假字串，請勿照用)</p><ul><li>Client ID: <code>95279527abcdefg</code></li><li>Client secrets: <code>314159265358979323846aabbccdd</code></li></ul><h2 id="準備工作：設定-Google-OAuth"><a href="#準備工作：設定-Google-OAuth" class="headerlink" title="準備工作：設定 Google OAuth"></a>準備工作：設定 Google OAuth</h2><ul><li>要設定 Google OAuth，請到 <a href="https://console.cloud.google.com/apis/credentials">https://console.cloud.google.com/apis/credentials</a></li></ul><figure class="img" style="max-width:500px"><img src="/2023/02/23-oauth/google_oauth_01.jpg" class="">    <figcaption>點上方的 CREATE CREDENTIALS / OAuth client ID    </figcaption></figure><figure class="img" style="max-width:500px"><img src="/2023/02/23-oauth/google_oauth_02.jpg" class=""></figure><ul><li>Appliecation type 是 <code>Web application</code></li><li>Authorized Javascript origins 填入 <code>http://localhost:8080</code>，Google 會判斷 Request 是不是來自這個 Origin</li><li>Authorized redirect URIs 填入 <code>http://localhost:8080/login/oauth2/code/client-id</code>，這就是流程圖第六步會用到的 Callback Uri</li></ul><br><figure class="img" style="max-width:500px"><img src="/2023/02/23-oauth/google_oauth_03.jpg" class=""></figure><p>同樣地記下這兩個字串 (ps. 這些是經過我亂改的假字串，請勿照用)</p><ul><li>Client ID: <code>1234567890-abcdefghijk123456789mh97mm8vuq3u.apps.googleusercontent.com</code></li><li>Client secret: <code>ABCDEF-1234567890e-abcdefgeFJOpMVz9</code></li></ul><h1 id="使用-Spring-Boot-官方-sample"><a href="#使用-Spring-Boot-官方-sample" class="headerlink" title="使用 Spring Boot 官方 sample"></a>使用 Spring Boot 官方 sample</h1><p>前期的準備工作都已經完成，接著從<a href="https://github.com/spring-projects/spring-security-samples">官方範例</a> 開始練習。</p><p>之所以選用官方範例，是我假設官方範例會用一個最簡潔且符合原始框架設計的實作，套用 OAuth。畢竟框架的存在就是要減少鄉親重複造輪子的可能性。</p><p>反正我也不清楚怎樣才算比較好的 Practice，與其從網路上東抄西抄，不如抱緊官方大腿，跟著長官的指揮走。</p><h2 id="用官方範例連接-Github-OAuth"><a href="#用官方範例連接-Github-OAuth" class="headerlink" title="用官方範例連接 Github OAuth"></a>用官方範例連接 Github OAuth</h2><figure class="img"><img src="/2023/02/23-oauth/learning_section_1.svg" class=""></figure><p>首先抓下官方範例包山包海的源碼，現在只需要專注看 <a href="https://github.com/spring-projects/spring-security-samples/tree/5.8.x/servlet/spring-boot/java/oauth2/webclient">/servlet/spring-boot/java/oauth2/webclient</a> 即可</p><p>在這個目錄執行 <code>./gradlew bootRun</code> 接著打開 <code>http://localhost:8080/</code> 就能看見範例頁面 – Hello World 完成了！</p><p>點入任何一個頁面就會被導至登入頁面，登入頁面能看到一個 Login with OAuth 2.0 / Github 的連結 – 當然它還動不了。<span class="roast">只是一張皺了的 ACE，因為我們還沒發功啊</span></p><p>現在打開 <code>servlet/spring-boot/java/oauth2/webclient/src/main/resources/application.yml</code>，把先前準備的 github client-id 跟 client secrect 填進去</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@@</span> <span class="number">-13</span><span class="string">,8</span> <span class="string">+13,8</span> <span class="string">@@</span> <span class="attr">spring:</span></span><br><span class="line">       <span class="attr">client:</span></span><br><span class="line">         <span class="attr">registration:</span></span><br><span class="line">           <span class="attr">client-id:</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">client-id:</span> <span class="string">replace-with-client-id</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">client-secret:</span> <span class="string">replace-with-client-secret</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">client-id:</span> <span class="string">95279527abcdefg</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">client-secret:</span> <span class="string">314159265358979323846aabbccdd</span></span><br><span class="line">             <span class="attr">provider:</span> <span class="string">github</span></span><br><span class="line">             <span class="attr">scope:</span> <span class="string">read:user,public_repo</span></span><br></pre></td></tr></table></figure><p>重跑一次 bootRun，這次就能順利地使用 Github 登入，並且看到自己的一些 Github repo 資訊了</p><h3 id="理解官方-Sample-提供的資訊"><a href="#理解官方-Sample-提供的資訊" class="headerlink" title="理解官方 Sample 提供的資訊"></a>理解官方 Sample 提供的資訊</h3><p>從 application.yml 得知，預設情況下 Sample 就是使用 Github 當作 OAuth provider。那麼 Sample 能夠提供我們什麼資訊？ – Spring Boot App 啟動 OAuth 的最小實作，這又包括了</p><ul><li>如何 Configure Spring Boot App，開啟 OAuth 功能</li><li>如何開始 OAuth 流程</li><li>如何使用 OAuth 登入後的成果</li></ul><br/><h4 id="如何-Configure-to-enable-OAuth"><a href="#如何-Configure-to-enable-OAuth" class="headerlink" title="如何 Configure to enable OAuth"></a>如何 Configure to enable OAuth</h4><p>打開 SecurityConfiguration.java 就能看到這段</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .mvcMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/public/**&quot;</span>).permitAll()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br><span class="line">    .formLogin(withDefaults())</span><br><span class="line">    .oauth2Login(withDefaults())</span><br><span class="line">    .oauth2Client(withDefaults());</span><br></pre></td></tr></table></figure><p>內容相當直覺，除了 <code>public</code> 之外的 Request 都會要求登入，導向自動產生的登入頁面。利用 <code>oauth2Login</code> 跟 <code>oauth2Client</code> 啟動 OAuth 功能，傳遞進去的全部是預設值。</p><h4 id="如何開始-OAuth-流程"><a href="#如何開始-OAuth-流程" class="headerlink" title="如何開始 OAuth 流程"></a>如何開始 OAuth 流程</h4><p>簡而言之：一切開始於預設登入頁面的 Github 連結開始。</p><p>預設登入頁面的實作在 <code>DefaultLoginPageGeneratingFilter.generateLoginPageHtml</code> 裡面。如果 OAuth 已經啟動而且有了足夠的 Client 資訊，便會插入連結 <code>/oauth2/authorization/&#123;registration-id&#125;</code>，以我們的例子就是 <code>http://localhost:8080/oauth2/authorization/client-id</code>。</p><p>只要點下這個連結，該 Request 最後會被 <code>OAuth2AuthorizationRequestRedirectFilter.doFilterInternal</code> 捕捉，透過 redirect 開始進行 OAuth</p><p>換句話說，如果要 customize 登入頁面，只要在該頁面放上 <code>/oauth2/authorization/&#123;registration-id&#125;</code>，就是 OAuth 的起始點。</p><h4 id="如何使用-OAuth-登入後的成果"><a href="#如何使用-OAuth-登入後的成果" class="headerlink" title="如何使用 OAuth 登入後的成果"></a>如何使用 OAuth 登入後的成果</h4><p>打開 <code>OAuth2WebClientController.java</code> 裡面有這麼一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/explicit&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">explicit</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @formatter:off</span></span><br><span class="line">    String body = <span class="keyword">this</span>.webClient</span><br><span class="line">            .get()</span><br><span class="line">            .attributes(clientRegistrationId(<span class="string">&quot;client-id&quot;</span>))</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(String.class)</span><br><span class="line">            .block();</span><br><span class="line">    <span class="comment">// @formatter:on</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;body&quot;</span>, body);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;response&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方範例演示如何從登入後返回的 attributes 裡面拿到必要的資訊，接著呼叫 <code>retrieve</code> 取得 JSON response(屬於你的 Github repo 資訊)，然後轉成字串印到網頁上，換句話說，<code>http://localhost:8080/annotation/explicit</code> 頁面的內容是從這邊產生的。</p><p>但我們要的其實沒那麼多，我們真正想知道的是拿到了什麼 <code>Authentication</code> 資料結構，從這邊判斷登入的人是誰。這部分比較複雜，最後再解釋。先聚焦在如何一步步抽換實作，等這些都做完了再來考慮如何完成我們最開始的目的：確定登入者是不是我們預期的 User</p><h2 id="官方範例連接-Google-OAuth-Server"><a href="#官方範例連接-Google-OAuth-Server" class="headerlink" title="官方範例連接 Google OAuth Server"></a>官方範例連接 Google OAuth Server</h2><figure class="img"><img src="/2023/02/23-oauth/learning_section_2.svg" class=""></figure><p>從 Github 換成 Google 相當簡單，只要修改 application.yml，把這幾行資訊換掉即可完成。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">---</span> <span class="string">a/servlet/spring-boot/java/oauth2/webclient/src/main/resources/application.yml</span></span><br><span class="line"><span class="string">+++</span> <span class="string">b/servlet/spring-boot/java/oauth2/webclient/src/main/resources/application.yml</span></span><br><span class="line"><span class="string">@@</span> <span class="number">-13</span><span class="string">,9</span> <span class="string">+13,9</span> <span class="string">@@</span> <span class="attr">spring:</span></span><br><span class="line">       <span class="attr">client:</span></span><br><span class="line">         <span class="attr">registration:</span></span><br><span class="line">           <span class="attr">client-id:</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">client-id:</span> <span class="string">be1c55ddbf56d27c6262</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">client-secret:</span>  <span class="string">1bb778fd86f8806dcdf5f64c43a9a07e2c64b87a</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">provider:</span> <span class="string">github</span></span><br><span class="line"><span class="bullet">-</span>            <span class="attr">scope:</span> <span class="string">read:user,public_repo</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">client-id:</span> <span class="number">1234567890</span><span class="string">-abcdefghijk123456789mh97mm8vuq3u.apps.googleusercontent.com</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">client-secret:</span> <span class="string">ABCDEF-1234567890e-abcdefgeFJOpMVz9</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">provider:</span> <span class="string">google</span></span><br><span class="line"><span class="string">+</span>            <span class="attr">scope:</span> <span class="string">profile,</span> <span class="string">email</span></span><br><span class="line"></span><br><span class="line"><span class="string">-resource-uri:</span> <span class="string">https://api.github.com/user/repos</span></span><br><span class="line"><span class="string">+resource-uri:</span> <span class="string">https://www.googleapis.com/oauth2/v3/userinfo</span></span><br></pre></td></tr></table></figure><p>重啟 bootRun 便能用 Google OAuth 登入。</p><p>你可能會覺得奇怪，怎麼 yml 檔案裡面有重複的 <code>client-id</code>？</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">registration:</span></span><br><span class="line">    <span class="attr">client-id:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">...</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">....</span></span><br></pre></td></tr></table></figure><p>這是官方範例檔寫得不夠好。較上層的 client-id，應該取作 <code>registration-id</code> 會比較好。提供「某個 OAuth Authorization Sever 的資訊」的資料結構在 Spring Security 裏面叫 <code>ClientRegistration</code>。如果我們希望同時提供 Google, Github 兩種登入方式，就要提供兩組 ClientRegistration，並且指定不同的 Registration Id，執行 OAuth 的流程，才能透過 Registration Id 知道現在正在用哪一組</p><p>所以 yml 檔可以寫成這樣，同時用兩個區塊來比較會比較清楚</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">registration:</span></span><br><span class="line">    <span class="attr">my-registration-id-1:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">...</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">....</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">google</span></span><br><span class="line">      <span class="string">.....</span></span><br><span class="line">    <span class="attr">my-registration-id-2:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">...</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">....</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">github</span></span><br><span class="line">      <span class="string">.....</span></span><br></pre></td></tr></table></figure><p>進入下個章節以前，就讓我們來動手改改看，把那個取名不好的 <code>client-id</code> 改成 <code>my-registration</code>，透過這個過程理解 Registration Id 的影響</p><p>首先先改 yml 檔</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">registration:</span></span><br><span class="line">    <span class="attr">my-registration:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">...</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">....</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">google</span></span><br><span class="line">      <span class="string">.....</span></span><br></pre></td></tr></table></figure><p>如同前述，OAuth Login 開始的進入點是 <code>/oauth2/authorization/&#123;registration-id&#125;</code>，如果你有自訂 Login 頁面，這時候就要改用 <code>/oauth2/authorization/my-registration</code>。不過 Sample 是用預設的 Login 頁面，它會自動幫我們生出正確的連結。</p><p>回想一下在 Google / Github 的 OAuth 頁面設定的 Authorization callback uri：<code>http://localhost:8080/login/oauth2/code/client-id</code></p><p>最後面的那個 <code>client-id</code> 其實就是 registration id。在流程圖的 Step 6，從 Authorization Server 返回 Client，Client 會從 <code>/login/oauth2/code/&#123;registration-id&#125;</code> 的格式取出 ID，用來判斷接著該用哪組 ClientRegistration 繼續下去</p><p>於是現在要再次進入 Google/Github 的 OAuth 設定頁面，把 callback uri 改成 <code>http://localhost:8080/login/oauth2/code/my-registration</code></p><p>此外，Sample 的 Controller 也有部分寫死 Registration Id，也必須要一併改變才能讓 Sample 正常運作。(如果是自己的 Web app，大可忽略這部分)</p><p>修改 OAuth2WebClientController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--- a/servlet/spring-boot/java/oauth2/webclient/src/main/java/example/OAuth2WebClientController.java</span><br><span class="line">+++ b/servlet/spring-boot/java/oauth2/webclient/src/main/java/example/OAuth2WebClientController.java</span><br><span class="line">@@ -<span class="number">44</span>,<span class="number">7</span> +<span class="number">44</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2WebClientController</span> </span>&#123;</span><br><span class="line">                <span class="comment">// @formatter:off</span></span><br><span class="line">                String body = <span class="keyword">this</span>.webClient</span><br><span class="line">                                .get()</span><br><span class="line">-                               .attributes(clientRegistrationId(<span class="string">&quot;client-id&quot;</span>))</span><br><span class="line">+                               .attributes(clientRegistrationId(<span class="string">&quot;my-registration&quot;</span>))</span><br><span class="line">                                .retrieve()</span><br><span class="line">                                .bodyToMono(String.class)</span><br><span class="line">                                .block();</span><br></pre></td></tr></table></figure><p>以及 RegisteredOAuth2AuthorizedClientController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- a/servlet/spring-boot/java/oauth2/webclient/src/main/java/example/RegisteredOAuth2AuthorizedClientController.java</span><br><span class="line">+++ b/servlet/spring-boot/java/oauth2/webclient/src/main/java/example/RegisteredOAuth2AuthorizedClientController.java</span><br><span class="line">@@ -<span class="number">43</span>,<span class="number">7</span> +<span class="number">43</span>,<span class="number">7</span> @@ <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisteredOAuth2AuthorizedClientController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@GetMapping(&quot;/explicit&quot;)</span></span><br><span class="line">        <span class="function">String <span class="title">explicit</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="params"><span class="function">-                       <span class="meta">@RegisteredOAuth2AuthorizedClient(&quot;client-id&quot;)</span> OAuth2AuthorizedClient authorizedClient)</span> </span>&#123;</span><br><span class="line">+                       <span class="meta">@RegisteredOAuth2AuthorizedClient(&quot;my-registration&quot;)</span> OAuth2AuthorizedClient authorizedClient) &#123;</span><br><span class="line">                <span class="comment">// @formatter:off</span></span><br><span class="line">                String body = <span class="keyword">this</span>.webClient</span><br></pre></td></tr></table></figure><p>接著重啟 bootRun 即可</p><h2 id="手動設定-Google-Registration"><a href="#手動設定-Google-Registration" class="headerlink" title="手動設定 Google Registration"></a>手動設定 Google Registration</h2><figure class="img"><img src="/2023/02/23-oauth/learning_section_3.svg" class=""></figure><p>在前面的實作，只要在 application.yml 填入從 Google/Github Server 拿到的 client id 跟 secret 就能運作，是因為 Spring Security 已經針對常用的服務，準備好必要的資訊。也就是說，Spring Security 已經備妥好幾組的 ClientRegistration。</p><p>這些東西都放在 <code>CommonOAuth2Provider</code> 裡面，譬如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CommonOAuth2Provider</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    GOOGLE &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">getBuilder</span><span class="params">(String registrationId)</span> </span>&#123;</span><br><span class="line">                ClientRegistration.Builder builder = getBuilder(registrationId,</span><br><span class="line">                    ClientAuthenticationMethod.CLIENT_SECRET_BASIC, DEFAULT_REDIRECT_URL);</span><br><span class="line">            builder.scope(<span class="string">&quot;openid&quot;</span>, <span class="string">&quot;profile&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">            builder.authorizationUri(<span class="string">&quot;https://accounts.google.com/o/oauth2/v2/auth&quot;</span>);</span><br><span class="line">            builder.tokenUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v4/token&quot;</span>);</span><br><span class="line">            builder.jwkSetUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/certs&quot;</span>);</span><br><span class="line">            builder.issuerUri(<span class="string">&quot;https://accounts.google.com&quot;</span>);</span><br><span class="line">            builder.userInfoUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;</span>);</span><br><span class="line">            builder.userNameAttributeName(IdTokenClaimNames.SUB);</span><br><span class="line">            builder.clientName(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> builder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    GITHUB &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">getBuilder</span><span class="params">(String registrationId)</span> </span>&#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">return</span> builder;</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個 Provider 會產生 ClientRegistration 給 Spring Security 使用，在 application.yml 指定的 provider <code>google</code>，就會採用上面那組 Google Builder 產生的 Registration。</p><p>它預設提供了 Google, Github, Facebook 跟 OKTA。然而，根據業務需求，隨時可能要新增一個 ClientRegistration，我們原來的目的「使用自己的 Mock Server」便是一例。現在就來假裝 Google 的欄位不存在，而我們要支援這個新服務</p><p>「透過 application.yml 從 CommonOAuth2Provider 找出可用的 ClientRegistration」這是 Spring Security 的實作，官方範例利用這部分，簡化需要撰寫的程式碼。由於我們打算新增自己的 OAuth Provider，現在開始屏棄 application.yml，全部自己手動來做</p><p>首先要注入自己的 ClientRegistrationRepository，現在打開 <code>servlet/spring-boot/java/oauth2/webclient/src/main/java/example/SecurityConfiguration.java</code>，透過 <code>@Bean</code> 來手動生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientRegistrationRepository <span class="title">createRegistrationRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String myRegistrationId = <span class="string">&quot;my-registration&quot;</span>;</span><br><span class="line">    ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(myRegistrationId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重點！</span></span><br><span class="line">    builder.redirectUri(<span class="string">&quot;http://localhost:8080/login/oauth2/code/&quot;</span> + myRegistrationId);</span><br><span class="line">    builder.clientId(<span class="string">&quot;1234567890-abcdefghijk123456789mh97mm8vuq3u.apps.googleusercontent.com&quot;</span>);</span><br><span class="line">    builder.clientSecret(<span class="string">&quot;ABCDEF-1234567890e-abcdefgeFJOpMVz9&quot;</span>);</span><br><span class="line"></span><br><span class="line">    builder.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_POST);</span><br><span class="line">    builder.scope(<span class="string">&quot;https://www.googleapis.com/auth/userinfo.email&quot;</span>);</span><br><span class="line">    builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE);</span><br><span class="line">    builder.authorizationUri(<span class="string">&quot;https://accounts.google.com/o/oauth2/auth&quot;</span>);</span><br><span class="line">    builder.tokenUri(<span class="string">&quot;https://oauth2.googleapis.com/token&quot;</span>);</span><br><span class="line">    builder.jwkSetUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/certs&quot;</span>);</span><br><span class="line">    builder.issuerUri(<span class="string">&quot;https://accounts.google.com&quot;</span>);</span><br><span class="line">    builder.userInfoUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;</span>);</span><br><span class="line">    builder.userNameAttributeName(IdTokenClaimNames.SUB);</span><br><span class="line">    builder.clientName(<span class="string">&quot;MyGoogleSample&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ClientRegistration registration = builder.build();</span><br><span class="line">    List&lt;ClientRegistration&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(registration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InMemoryClientRegistrationRepository(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>內容大多抄自 CommonOAuth2Provider，除了 <code>redirectUri</code> <code>clientId</code> <code>clientSecret</code> 這三樣東西，原本該從 application.yml 載入，現在改成寫死在程式碼裡。這是為了解說方便，實際上的 production code，當然改回從設定檔決定內容會是比較合理的做法</p><p>跟前一小節相同，別忘了改 <code>OAuth2WebClientController</code> 與 <code>RegisteredOAuth2AuthorizedClientController</code> 裡面的 <code>client-id</code> 為 <code>my-registration</code></p><p>同樣地重啟 bootRun，就能用手動注入的 Google ClientRegistration 進行 OAuth 登入</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>官方範例至此給了許多幫助，透過保證會動的範例，逐步修改的過程中我們理解到了</p><ul><li>如何設定 Google/Github 上面的 callback uri</li><li>如何產生自己的 ClientRegistration 增加新的 OAuth Authorization Server</li><li>如何設定自己的 Spring web app，使其支援 OAuth</li><li>該透過怎樣的連結，啟動 OAuth 登入</li></ul><p>有了這些基礎的知識，可以回到自己的 Spring web app 開始實作 OAuth 了</p><h2 id="用自己的-Web-App-連接-Google-OAuth"><a href="#用自己的-Web-App-連接-Google-OAuth" class="headerlink" title="用自己的 Web App 連接 Google OAuth"></a>用自己的 Web App 連接 Google OAuth</h2><figure class="img"><img src="/2023/02/23-oauth/learning_section_4.svg" class=""></figure><p>這邊就不囉唆怎麼創建一個基本的 Spring Boot Web App，會嘗試用 OAuth 的人應該都已經很熟悉這部分。</p><p>第一步要產生 ClientRegistration。雖然可以在 SecurityConfig 那邊透過 method <code>clientRegistrationRepository</code> 指定 repository，但我還是比較偏好用 <code>@Bean</code> 的方式注入，這樣我可以在 Production Build 排除掉下一個章節會加入的 Mock OAuth Server。</p><p>以下程式以 Kotlin 為例，先來寫個 class <code>MyOAuth2ClientRegistrations </code> 提供 ClientRegistration</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MyOAuth2ClientRegistrations &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(type: <span class="type">RegistrationType</span>)</span></span>: ClientRegistration &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = <span class="keyword">when</span> (type) &#123;</span><br><span class="line">            RegistrationType.GooglePlayground -&gt; createBuilderForGooglePlayground()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBuilderForGooglePlayground</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ClientRegistration.Builder &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = ClientRegistration.withRegistrationId(RegistrationType.GooglePlayground.id)</span><br><span class="line">        builder.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_POST)</span><br><span class="line">        <span class="comment">// https://console.cloud.google.com/apis/credentials</span></span><br><span class="line">        builder.redirectUri(<span class="string">&quot;http://localhost:8000/login/oauth2/code/<span class="subst">$&#123;RegistrationType.GooglePlayground.id&#125;</span>&quot;</span>)</span><br><span class="line">        builder.clientId(<span class="string">&quot;1234567890-abcdefghijk123456789mh97mm8vuq3u.apps.googleusercontent.com&quot;</span>)</span><br><span class="line">        builder.clientSecret(<span class="string">&quot;ABCDEF-1234567890e-abcdefgeFJOpMVz9&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fixed for Google OAuth</span></span><br><span class="line">        <span class="comment">//builder.scope(&quot;https://www.googleapis.com/auth/userinfo.profile&quot;)</span></span><br><span class="line">        builder.scope(<span class="string">&quot;https://www.googleapis.com/auth/userinfo.email&quot;</span>)</span><br><span class="line">        builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE);</span><br><span class="line">        builder.authorizationUri(<span class="string">&quot;https://accounts.google.com/o/oauth2/auth&quot;</span>)</span><br><span class="line">        builder.tokenUri(<span class="string">&quot;https://oauth2.googleapis.com/token&quot;</span>)</span><br><span class="line">        builder.jwkSetUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/certs&quot;</span>);</span><br><span class="line">        builder.issuerUri(<span class="string">&quot;https://accounts.google.com&quot;</span>);</span><br><span class="line">        builder.userInfoUri(<span class="string">&quot;https://www.googleapis.com/oauth2/v3/userinfo&quot;</span>);</span><br><span class="line">        builder.userNameAttributeName(IdTokenClaimNames.SUB)</span><br><span class="line">        builder.clientName(<span class="string">&quot;Google&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistrationType</span></span>(<span class="keyword">val</span> id: String) &#123;</span><br><span class="line">        GooglePlayground(<span class="string">&quot;google_playground&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著找個地方注入 ClientRegistration</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOAuth2Provider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createClientRegistrationRepository</span><span class="params">()</span></span>: ClientRegistrationRepository &#123;</span><br><span class="line">        <span class="keyword">val</span> list = listOf(</span><br><span class="line">            MyOAuth2ClientRegistrations.create(RegistrationType.GooglePlayground),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> InMemoryClientRegistrationRepository(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這些完成後，最後一步就是設定 SecurityConfig，啟動 OAuth</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">createFilterChain</span><span class="params">(http: <span class="type">HttpSecurity</span>)</span></span>: SecurityFilterChain &#123;</span><br><span class="line">        <span class="comment">// 你之前設定的其他東西</span></span><br><span class="line">        http.</span><br><span class="line">            ........</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加 OAuth</span></span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/oauth_login_success&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/login_fail&quot;</span>).permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .oauth2Login()</span><br><span class="line">            .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            .failureUrl(<span class="string">&quot;/login_fail&quot;</span>)</span><br><span class="line">            .defaultSuccessUrl(<span class="string">&quot;/oauth_login_success&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>oauth_login_success</code> 跟 <code>login_fail</code> 是登入成功/失敗的預設頁面，非必須。現階段寫個簡單的 Controller，然後直接 render 成功或失敗的字串就好。</p><p>因為我想要有自訂的登入頁面，所以放進了 <code>loginPage(&quot;/login&quot;)</code>，我們可以這麼實作它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">&quot;/login&quot;</span>)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> repository: ClientRegistrationRepository</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLogin</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        csrfToken: <span class="type">CsrfToken</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        session: <span class="type">HttpSession</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        map: <span class="type">ModelMap</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: String &#123;</span><br><span class="line">        session.writeAttributes()</span><br><span class="line">        println(csrfToken.token)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> oauthPaths: Map&lt;String, String&gt; = listOf(</span><br><span class="line">            RegistrationType.GooglePlayground.id,</span><br><span class="line">        )</span><br><span class="line">            .map &#123; repository.findByRegistrationId(it) &#125;</span><br><span class="line">            .mapNotNull &#123; <span class="string">&quot;<span class="subst">$&#123;it.clientName&#125;</span>&quot;</span> to <span class="string">&quot;oauth2/authorization/<span class="subst">$&#123;it.registrationId&#125;</span>&quot;</span> &#125;</span><br><span class="line">            .toMap()</span><br><span class="line">        map.addAttribute(<span class="string">&quot;oauthPaths&quot;</span>, oauthPaths)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>編輯 template 的 login.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;img&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;oauthPath: $&#123;oauthPaths&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">th:href</span>=<span class="string">&quot;$&#123;oauthPath.value&#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">th:text</span>=<span class="string">&quot;$&#123;oauthPath.key&#125;&quot;</span>&gt;</span>Registration Name<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>未來只要新增 RegistrationType，就可以輕易地增加不同的登入按鈕</p><h2 id="讓自己的-Web-App-連接-Mock-OAuth"><a href="#讓自己的-Web-App-連接-Mock-OAuth" class="headerlink" title="讓自己的 Web App 連接 Mock OAuth"></a>讓自己的 Web App 連接 Mock OAuth</h2><figure class="img"><img src="/2023/02/23-oauth/learning_section_5.svg" class=""></figure><p>經過千山萬水終於走到最後一步，具備足夠的基礎知識之後可以開始接 Mock Server。</p><h3 id="準備-Mock-Auth-Server"><a href="#準備-Mock-Auth-Server" class="headerlink" title="準備 Mock Auth Server"></a>準備 Mock Auth Server</h3><p>首先要選擇合適的 Mock Server，我最後選擇的是 <a href="https://github.com/navikt/mock-oauth2-server">navikt/mock-oauth2-server</a></p><ul><li>看起來功能滿完整，也有提供 docker 等等許多不同的啟動方式，相當溫馨</li><li>它也是個 Sprint Boot App，可以輕易地整合進現有的專案<ul><li>只要從 mvn 下載相依性 jar，隨時可以輕易寫個簡單的 App 啟動 Mock OAuth Server</li><li>可以在自己的 Spring Web App 裡面開一個開發用的子目錄跑 Mock OAuth Server，每次的 git pull 也連同 Mock Server 的開發環境一起準備妥當</li></ul></li></ul><p>先開一個 project，接著把 mock server 加入 dependency。Gradle 的設定檔如下 (有些東西我也忘了當時怎麼找出來的，就如實記下，供讀者參考)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.gradle.tasks.KotlinCompile</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;org.springframework.boot&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">&quot;my.spring.dev.oauth&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.0.1-SNAPSHOT&quot;</span></span><br><span class="line">java.<span class="keyword">sourceCompatibility</span> = JavaVersion.VERSION_11</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation(<span class="string">&quot;no.nav.security:mock-oauth2-server:0.5.7&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        freeCompilerArgs = listOf(<span class="string">&quot;-Xjsr305=strict&quot;</span>)</span><br><span class="line">        jvmTarget = <span class="string">&quot;11&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;Test&gt; &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著寫個簡單的啟動器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.spring.dev.oauth</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> no.nav.security.mock.oauth2.MockOAuth2Server</span><br><span class="line"><span class="keyword">import</span> no.nav.security.mock.oauth2.OAuth2Config</span><br><span class="line"><span class="keyword">import</span> no.nav.security.mock.oauth2.token.DefaultOAuth2TokenCallback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> mockServerPort = <span class="number">4040</span></span><br><span class="line">    <span class="comment">// Add custom response to default issuer</span></span><br><span class="line">    <span class="keyword">val</span> callback = DefaultOAuth2TokenCallback(</span><br><span class="line">        issuerId = <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        claims = mapOf(</span><br><span class="line">            <span class="string">&quot;username&quot;</span> to <span class="string">&quot;MockUser&quot;</span>,</span><br><span class="line">            <span class="string">&quot;email&quot;</span> to <span class="string">&quot;user@mock.server&quot;</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> config = OAuth2Config(</span><br><span class="line">        tokenCallbacks = setOf(callback)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> server = MockOAuth2Server(config)</span><br><span class="line">    server.start(mockServerPort)</span><br><span class="line">    println(<span class="string">&quot;well known url : <span class="subst">$&#123;server.wellKnownUrl(<span class="string">&quot;default&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行這個 spring app 之後，它會在 4040 port 跑起 Mock Auth Server。我設定了一個 Callback，在流程圖的 Step 23 回傳的 JSON 檔案裏面，額外增加 <code>username</code> 跟 <code>email</code> 兩個欄位。用途就留到最後一個章節再解釋</p><p>跑起 mock server 之後，可以打開 <code>http://localhost:4040/default/.well-known/openid-configuration</code>，貼心地列出了你需要填進 ClientRegistration 的資訊。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;issuer&quot;</span> : <span class="string">&quot;http://localhost:4040/default&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authorization_endpoint&quot;</span> : <span class="string">&quot;http://localhost:4040/default/authorize&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;end_session_endpoint&quot;</span> : <span class="string">&quot;http://localhost:4040/default/endsession&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;token_endpoint&quot;</span> : <span class="string">&quot;http://localhost:4040/default/token&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;userinfo_endpoint&quot;</span> : <span class="string">&quot;http://localhost:4040/default/userinfo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;jwks_uri&quot;</span> : <span class="string">&quot;http://localhost:4040/default/jwks&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;introspection_endpoint&quot;</span> : <span class="string">&quot;http://localhost:4040/default/introspect&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;response_types_supported&quot;</span> : [ <span class="string">&quot;query&quot;</span>, <span class="string">&quot;fragment&quot;</span>, <span class="string">&quot;form_post&quot;</span> ],</span><br><span class="line">  <span class="attr">&quot;subject_types_supported&quot;</span> : [ <span class="string">&quot;public&quot;</span> ],</span><br><span class="line">  <span class="attr">&quot;id_token_signing_alg_values_supported&quot;</span> : [ <span class="string">&quot;ES256&quot;</span>, <span class="string">&quot;ES384&quot;</span>, <span class="string">&quot;RS256&quot;</span>, <span class="string">&quot;RS384&quot;</span>, <span class="string">&quot;RS512&quot;</span>, <span class="string">&quot;PS256&quot;</span>, <span class="string">&quot;PS384&quot;</span>, <span class="string">&quot;PS512&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="自己的-Web-App-增加-Mock-的-ClientRegistration"><a href="#自己的-Web-App-增加-Mock-的-ClientRegistration" class="headerlink" title="自己的 Web App 增加 Mock 的 ClientRegistration"></a>自己的 Web App 增加 Mock 的 ClientRegistration</h3><p>基於前面已有的實作，我們只要增加一個 ClientRegistration 就能輕易支援 Mock Server</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MyOAuth2ClientRegistrations &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(type: <span class="type">RegistrationType</span>)</span></span>: ClientRegistration &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = <span class="keyword">when</span> (type) &#123;</span><br><span class="line">            RegistrationType.GooglePlayground -&gt; createBuilderForGooglePlayground()</span><br><span class="line">            RegistrationType.Mock -&gt; createBuilderForMock()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBuilderForMock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ClientRegistration.Builder &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = ClientRegistration.withRegistrationId(RegistrationType.Mock.id)</span><br><span class="line">        <span class="keyword">val</span> issuer = <span class="string">&quot;default&quot;</span></span><br><span class="line">        <span class="keyword">val</span> baseUri = <span class="string">&quot;http://localhost:4040/<span class="variable">$issuer</span>&quot;</span></span><br><span class="line">        builder.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_POST)</span><br><span class="line">        builder.redirectUri(<span class="string">&quot;http://localhost:8000/login/oauth2/code/<span class="subst">$&#123;RegistrationType.Mock.id&#125;</span>&quot;</span>)</span><br><span class="line">        builder.clientId(<span class="string">&quot;debugger&quot;</span>) <span class="comment">// 隨便填</span></span><br><span class="line">        builder.clientSecret(<span class="string">&quot;debuggerSecret&quot;</span>) <span class="comment">// 隨便填</span></span><br><span class="line">        builder.scope(<span class="string">&quot;openid&quot;</span>, <span class="string">&quot;profile&quot;</span>)</span><br><span class="line"></span><br><span class="line">        builder.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE);</span><br><span class="line">        builder.authorizationUri(<span class="string">&quot;<span class="variable">$baseUri</span>/authorize&quot;</span>)</span><br><span class="line">        builder.tokenUri(<span class="string">&quot;<span class="variable">$baseUri</span>/token&quot;</span>)</span><br><span class="line">        builder.userInfoUri(<span class="string">&quot;<span class="variable">$baseUri</span>/userinfo&quot;</span>)</span><br><span class="line">        builder.jwkSetUri(<span class="string">&quot;<span class="variable">$baseUri</span>/jwks&quot;</span>) <span class="comment">// mock server 需要這個</span></span><br><span class="line">        builder.userNameAttributeName(<span class="string">&quot;sub&quot;</span>)</span><br><span class="line">        builder.clientName(<span class="string">&quot;Mock&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistrationType</span></span>(<span class="keyword">val</span> id: String) &#123;</span><br><span class="line">        Mock(<span class="string">&quot;my_mock&quot;</span>),</span><br><span class="line">        GooglePlayground(<span class="string">&quot;google_playground&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>記得還要在 <code>LoginController</code> 裡面的 oauthPath 補上 <code>RegistrationType.Mock.id</code>，就能補上 Mock server 的登入連結。</p><p>到這邊就算完成了</p><h2 id="小結-1"><a href="#小結-1" class="headerlink" title="小結"></a>小結</h2><p>從官方範例開始，逐步做到這裡，很清楚地理解應該要新增哪些東西，有哪些必填資訊，於是要接 Mock Server 就變成小菜一碟。</p><p>然而，前面的文件都漏掉一個非常重要的環節沒提，其實也是我卡關思索最久的地方，而且是最要緊的最後一步</p><p><strong>「該怎麼使用 OAuth 的結果？」</strong></p><p>官方範例直接用 access token 去 Resource Server 撈東西回來，但這不是我原始目的。我想要的是「知道登入的人是誰，給予相對應的權限」。</p><p>前面講的東西大多是逐步的實作過程，下一個章節再專心解釋，該怎麼使用 Google/Mock 回傳的東西，來完成最初的目標。</p><h1 id="OAuth-登入後產生可用的-User"><a href="#OAuth-登入後產生可用的-User" class="headerlink" title="OAuth 登入後產生可用的 User"></a>OAuth 登入後產生可用的 User</h1><p>在開始之前先說結論：「<strong>OAuth/OpenID 登入之後，應該要產生不同於 Form Login 的 User，而是要針對 OAuth/OpenId 的 User，每個 Controller 給予符合權限的操作</strong>」</p><p>這句看不懂沒關係，知道這個大方向，把下面幾節看完就可以了。</p><h2 id="Form-Login-的情況"><a href="#Form-Login-的情況" class="headerlink" title="Form Login 的情況"></a>Form Login 的情況</h2><p>談 OAuth 之前，先回到最基本的表單登入，也就是最常見的輸入帳號、密碼登入。討論這個過程，很常可以看見以下的流程</p><figure class="img"><img src="/2023/02/23-oauth/basic_authentication_flow.svg" class=""></figure><p>User 嘗試打開某個需要權限的頁面，Spring Security 會捕捉到該 Request，交給 AuthenticationManager 做後續的處理。存密碼的事情交給 PasswordEncoder，又透過 UserDetailsService 找出登入的 UserD 資料結構，放進 <code>Authentication.principal</code> 裏面成為 Authentication 的一個欄位，接著把 Authentication 存進 SecurityContext。於是在 Controller 我們很常透過存取 SecurityContext 來判斷權限</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSomePage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">val</span> auth = SecurityContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .authentication</span><br><span class="line">        println(auth.principal)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如前述，<code>auth.principal</code> 就是 UserDetailsService 回傳的 UserDetails。</p><p>換句話說，完成 Form Login 之後，我們就能拿到 <code>Authentication</code> 以及能提供 User 詳細資料(包括權限) 的 <code>Authenticon.getPrincipal()</code></p><h2 id="OAuth-Login-的情況"><a href="#OAuth-Login-的情況" class="headerlink" title="OAuth Login 的情況"></a>OAuth Login 的情況</h2><p>OAuth 也有一個實作 AuthenticationProvider 的類別，叫做 <code>OAuth2LoginAuthenticationProvider</code>。附帶一提，前面的<strong>互動流程圖</strong>，正好被 <code>OAuth2LoginAuthenticationProvider.authenticate</code> 實作了一遍，只要看該 method 就能看完高階的 OAuth flow。當然，Spring Security 在底層塞入各種情況的實作，有興趣的人可以慢慢追。</p><p>該 Provider 的底層會用到的其他 Class 來完成工作，包括一個 <code>DefaultOAuth2UserService</code>，Service 的 method <code>loadUser</code> 就是流程圖 Step 11，會回傳資料結構 <code>OAuth2User</code>。DefaultOAuth2UserService 之於 OAuth2User，就相當於 Form Login 的 UserDetailsService 跟 User。</p><p>要做的事情就變得清晰許多：我們需要實作一個類似 UserDetailsService 的東西，針對 Google OAuth 登入的結果，回傳一個 GoogleUser 的資料結構。</p><p>翻閱網路上的文件可以看見不同做法，但是用到的不少 Class 都已經被 Spring Security 標註為 deprecated，撰寫此文的當下，文件的建議是採用 <a href="https://docs.spring.io/spring-security/site/docs/5.2.15.RELEASE/reference/html/oauth2.html#oauth2login-advanced-map-authorities-oauth2userservice">Delegation</a> 的做法</p><p>於是我們要做的事情有兩個，一個是產生要放進 Authentication.principal 的資料結構，另一個是能產生該資料結構的 Service</p><p>先來客製化一個 OAuth2User 當成放進 Authentication.principal 的東西</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGoogleUser</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> oauth2User: OAuth2User) : OAuth2User <span class="keyword">by</span> oauth2User &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> authorities: MutableCollection&lt;<span class="keyword">out</span> GrantedAuthority&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> email: String? = oauth2User.getAttribute&lt;String&gt;(<span class="string">&quot;email&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 針對不同的 email 帳號，賦予不同的權限</span></span><br><span class="line">        <span class="keyword">val</span> authority: MyGrantedAuthority = <span class="keyword">when</span> &#123;</span><br><span class="line">            email.contains(<span class="string">&quot;walkingice.*@gmail.com&quot;</span>) -&gt; MyGrantedAuthority.ADMIN</span><br><span class="line">            email.contains(<span class="string">&quot;foobar@gmail.com&quot;</span>) -&gt; MyGrantedAuthority.DEBUG</span><br><span class="line">            <span class="keyword">else</span> -&gt; MyGrantedAuthority.USER</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        name = <span class="keyword">when</span> (authority) &#123;</span><br><span class="line">            MyGrantedAuthority.ADMIN -&gt; <span class="string">&quot;GoogleUserAdmin&quot;</span></span><br><span class="line">            MyGrantedAuthority.USER -&gt; <span class="string">&quot;GoogleUserNormal&quot;</span></span><br><span class="line">            MyGrantedAuthority.DEBUG -&gt; <span class="string">&quot;GoogleUserDebug&quot;</span></span><br><span class="line">            MyGrantedAuthority.UNKNOWN -&gt; <span class="string">&quot;GoogleUserUnknown&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        authorities = mutableSetOf(authority)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAuthorities</span><span class="params">()</span></span>: MutableCollection&lt;<span class="keyword">out</span> GrantedAuthority&gt; = authorities</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著注入一個 OAuth2UserService</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createOAuth2UserService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> delegate = DefaultOAuth2UserService()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; &#123; userRequest: OAuth2UserRequest? -&gt;</span><br><span class="line">        <span class="keyword">val</span> user = delegate.loadUser(userRequest)</span><br><span class="line">        MyGoogleUser(user)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一來，在 Controller 裡面拿到的 <code>auth.getPrincipal()</code> 就是 <code>MyGoogleUser</code></p><h2 id="OpenID-Login-的情況"><a href="#OpenID-Login-的情況" class="headerlink" title="OpenID Login 的情況"></a>OpenID Login 的情況</h2><p>需要特別說明 OpenID Login。OAuth 的登入過程中，ClientRegistration 會指定 scope，如果 scope 裡面包含 <code>openid</code> 這個字串，Spring Security 在 loadUser 的部分會走另外一個實作，採用 <code>OidcUserService</code> (Oidc, for OpenID Connect 1.0) 而非 OAuth2UserService，詳情我沒有深入研究，應該跟 OpenID 的規格有關。</p><p>而且我選的 Mock Auth Server 正好就會回傳這個 scope，也因此上一節所注入的 OAuth2UserService 並不會對 Mock Server 起作用。我們必須要針對 OpenID 提供另一份類似的實作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 這次我選擇在 Service 那邊決定該用哪種 Authority</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMockUser</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> oidcUser: OidcUser,</span><br><span class="line">    grantedAuthority: MyGrantedAuthority,</span><br><span class="line">) : OidcUser <span class="keyword">by</span> oidcUser &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> authority: MutableCollection&lt;<span class="keyword">out</span> GrantedAuthority&gt; = mutableSetOf(grantedAuthority)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String = <span class="string">&quot;DebugMockUser&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAuthorities</span><span class="params">()</span></span>: MutableCollection&lt;<span class="keyword">out</span> GrantedAuthority&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> authority</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外也要注入 OidcUserService</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createOidcUserService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> delegate = OidcUserService()</span><br><span class="line">    <span class="keyword">return</span> OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; &#123; userRequest: OidcUserRequest? -&gt;</span><br><span class="line">        <span class="keyword">val</span> user = delegate.loadUser(userRequest)</span><br><span class="line">        <span class="comment">// 這邊應該要做些判斷，但我直接假設此時都是來自 Mock Server</span></span><br><span class="line">        MyMockUser(user, MyGrantedAuthority.DEBUG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一來，在 Controller 裡面拿到的 <code>auth.getPrincipal()</code> 就是 <code>MyMockUser</code></p><h2 id="Controller-裡面使用-User"><a href="#Controller-裡面使用-User" class="headerlink" title="Controller 裡面使用 User"></a>Controller 裡面使用 User</h2><p>還記得前面說過的結論？「<strong>OAuth/OpenID 登入之後，應該要產生不同於 Form Login 的 User，而是要針對 OAuth/OpenId 的 User，每個 Controller 給予符合權限的操作</strong>」</p><ul><li>FormLogin 會拿到 UserDetails</li><li>Google OAuth Login 會拿到 MyGoogleUser</li><li>Mock OAuth Login 會拿到 MyMockUser</li></ul><p>所以 Controller 裡面要這麼做</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomePageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getSomePage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">val</span> auth = SecurityContextHolder</span><br><span class="line">            .getContext()</span><br><span class="line">            .authentication</span><br><span class="line">        <span class="keyword">val</span> principal = auth.principal</span><br><span class="line">        <span class="keyword">val</span> name = <span class="keyword">when</span>(principal) &#123;</span><br><span class="line">            <span class="keyword">is</span> User -&gt; principal.username</span><br><span class="line">            <span class="keyword">is</span> MyGoogleUser -&gt; <span class="string">&quot;From Google: <span class="subst">$&#123;principal.name&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">is</span> MyMockUser -&gt; <span class="string">&quot;From Mock: <span class="subst">$&#123;principal.name&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(name)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>簡單來說，就是針對不同的 Principal 的 Class type 做出不同的處理</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>我之前一直陷入錯誤的思考方向，總認為我要注入某個轉換器給 DefaultOAuth2UserService，讓它可以產生一致的 UserDetail 資料結構，這樣 Controller 就不用處理各種情況。糾結在此，卻怎麼也找不到 Spring Security 是否提供的類似注入點。</p><p>後來念頭一轉：Form Login 跟 OAuth Login 本來就是不同的事情，不應該要生出相同的 UserDetails。有些資訊本來就不會出現在 Google 登入後的帳號，硬是要變成同樣的資料結構也滿怪的。想通了這點就豁然開朗，安心地新增 MyGoogleUser。</p><p>我想有些網站在 OAuth 登入之後，還要你產生一個新帳號，大概就是希望你再產生一個類似 FormLogin 的 UserDetail，解決 Controller 那邊邏輯分散的問題。雖然這樣的實作方法也有它的道理，但我就是不想要存太多敏感資訊，才沒選這個做法。</p><p>在 Kotlin 裡面，要避開 Controller 處理各種不同 User 的麻煩之處，其實也滿簡單的，針對 Principal 寫幾個 extension function 來用，就能維持 Controller 的邏輯清晰。</p><p>又或著，設計更抽象泛用的 User 資料結構，讓它處理不同的登入來源，也是一種可行的做法。</p><p>總結整篇文章的心得</p><ul><li>要增加新的 OAuth Server，就要想辦法提供額外的 ClientRegistration 給 Spring Security</li><li>在 Login 頁面增加符合格式的連結，使用者就可以開始用 OAuth Login</li><li>注入 OAuth2UserService/OidcUserService，並且回傳客製化的 User 資料結構 – 這就是完成 OAuth login 會拿到的成果</li><li>Controller 針對不同的 User 做不同的處理 (ie: 權限)</li><li>剩下，就是 Spring Security 的事了</li></ul><p>最後 User 的那塊卡關最久，是我個人的理解心得。不過我是 Spring Boot 新手，或許有理解錯誤的地方，歡迎各方前輩給予指教。</p><p>一開始只是想著要用 Mock Auth Server 滿足阿宅的微薄尊嚴，沒想到在看文件的過程中產生愈來愈多疑問，甚至買了本 Spring Security 的書來看。也大致 trace 了一遍 Spring Security 關於 OAuth 登入的程式碼，反覆設下 debug break point 觀察流程，最後還是倚靠讀源碼的老狗把戲。</p><p>Spring Boot / Security 是好東西，它也不斷地在演進，可惜官方文件總是缺了些完成度或是跟不上新版本，網路上的教學文章多著重單一細節而少提宏觀架構，也可能因為版本不同而跑不起來。於是剛入門的階段會覺得黑魔法一大堆，雖然網站會運作，但是自己有點不心安。然而反覆閱讀源碼，過了一個階段之後就會突然懂官方文件講的是哪些東西。</p><p>話說回來，文件不就是要減少看源碼的時間嗎？寫文件真是不容易的事情啊</p>]]></content>
    
    
    <summary type="html">&lt;style&gt;
    .roast {
        font-size: 0.9rem;
        color: #888;
    }
&lt;/style&gt;


&lt;p&gt;開發 Web 服務時，使用者的登入與驗證一直都是重要的課題，其中 OAuth 也是常被討論的部分。雖然 OAuth 已經相當成熟，但是 Spring Boot 的文件裡，使用 OAuth 的相關資訊通常都比較零散。&lt;/p&gt;
&lt;p&gt;本文紀錄我學習 Spring Boot / Spring Security + OAuth 過程中的理解與心得&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="java" scheme="https://jchu.cc/tags/java/"/>
    
    <category term="spring" scheme="https://jchu.cc/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.5.6 to 3.0.2 migration 筆記</title>
    <link href="https://jchu.cc/2023/02/22-post.html"/>
    <id>https://jchu.cc/2023/02/22-post.html</id>
    <published>2023-02-21T15:56:50.000Z</published>
    <updated>2023-03-08T13:36:55.549Z</updated>
    
    <content type="html"><![CDATA[<p>正在練習把玩的 Spring Boot 用的是 2.5.6，剛剛升級到 3.0.2，這邊隨手記錄必須的改動</p><span id="more"></span><h1 id="升級-Java"><a href="#升級-Java" class="headerlink" title="升級 Java"></a>升級 Java</h1><p>換上 3.0.2 之後，Java 必須要升級到 17 以上，我原本是用 Java 11，所以 IDE 跟 Console 的 JDK 都換成了 19</p><h1 id="升級-Gradle"><a href="#升級-Gradle" class="headerlink" title="升級 Gradle"></a>升級 Gradle</h1><p>JDK 換成 19 之後跑 gradle 會遇到莫名的 <code>PermittedSubclasses requires ASM9</code></p><p>我把原本的 <code>gradle-7.2</code> 換成 <code>gradle-7.6</code> 就沒事了</p><h1 id="更換-jakarta-的-package-name"><a href="#更換-jakarta-的-package-name" class="headerlink" title="更換 jakarta 的 package name"></a>更換 jakarta 的 package name</h1><p><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Spring Boot 3.0 Release Note</a> 有說 Jakarta Persistence 為 3.1</p><p><a href="https://en.wikipedia.org/wiki/Jakarta_Persistence">Wiki</a> 說明 Jakarta Persistence 3.0 之後把 package name 從 <code>javax.persistence</code> 換成 <code>jakarta.persistence</code>，因此要做類似的修改</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+import jakarta.persistence.Column</span></span><br><span class="line"><span class="addition">+import jakarta.persistence.Entity</span></span><br><span class="line"><span class="addition">+import jakarta.persistence.Id</span></span><br><span class="line"><span class="addition">+import jakarta.persistence.Table</span></span><br><span class="line"><span class="deletion">-import javax.persistence.Column</span></span><br><span class="line"><span class="deletion">-import javax.persistence.Entity</span></span><br><span class="line"><span class="deletion">-import javax.persistence.Id</span></span><br><span class="line"><span class="deletion">-import javax.persistence.Table</span></span><br></pre></td></tr></table></figure><h1 id="更新-Spring-Security-的語法"><a href="#更新-Spring-Security-的語法" class="headerlink" title="更新 Spring Security 的語法"></a>更新 Spring Security 的語法</h1><ul><li>authorizeRequest 已經 deprecated</li><li>antMatchers 要換成 requestMatchers</li></ul><p>另外有個比較雷的地方，原本我只要用 <code>@EnableWebSecurity</code> 就能注入 Security 相關的 Bean，更新之後要再加上 <code>@Configuration</code> 否則不會有效果</p><p>前後差異如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableWebSecurity</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AppSecurityConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">createFilterChain</span><span class="params">(http: <span class="type">HttpSecurity</span>)</span></span>: SecurityFilterChain &#123;</span><br><span class="line">         <span class="comment">// public</span></span><br><span class="line">         http</span><br><span class="line">-            .authorizeRequests()</span><br><span class="line">-            .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">+            .authorizeHttpRequests()</span><br><span class="line">+            .requestMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">         ....</span><br></pre></td></tr></table></figure><h2 id="開發期略過-h2-console"><a href="#開發期略過-h2-console" class="headerlink" title="開發期略過 h2-console"></a>開發期略過 h2-console</h2><p>如果你有用 h2-console，而且在開發期想要避開 spring security，可以利用 <code>toH2Console</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.security.servlet.PathRequest.toH2Console</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createFilterChain</span><span class="params">(http: <span class="type">HttpSecurity</span>)</span></span>: SecurityFilterChain &#123;</span><br><span class="line">    http.headers().frameOptions().sameOrigin()</span><br><span class="line"></span><br><span class="line">    http.csrf().ignoringRequestMatchers(toH2Console())</span><br><span class="line"></span><br><span class="line">    http.authorizeHttpRequests()</span><br><span class="line">        .requestMatchers(toH2Console())</span><br><span class="line">        <span class="comment">// .requestMatchers(antMatcher(&quot;/h2-console/**&quot;)) // either this one is fine</span></span><br><span class="line">        .permitAll()</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> http.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;正在練習把玩的 Spring Boot 用的是 2.5.6，剛剛升級到 3.0.2，這邊隨手記錄必須的改動&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="java" scheme="https://jchu.cc/tags/java/"/>
    
    <category term="spring" scheme="https://jchu.cc/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>本站已拿掉 Google Analytics 換成 Matomo</title>
    <link href="https://jchu.cc/2023/02/18-analytics.html"/>
    <id>https://jchu.cc/2023/02/18-analytics.html</id>
    <published>2023-02-18T07:42:50.000Z</published>
    <updated>2023-02-21T14:49:04.689Z</updated>
    
    <content type="html"><![CDATA[<p>長久以來都有放 Google Analytics 的程式，拿來計算來站人數，不過剛剛把所有相關的程式都拔掉了。</p><span id="more"></span><p>這習慣是從剛開始用 Wordpress 架 Blog 就開始，好像總要計算人數才算完整。自從改成靜態網頁的 Blog 之後，就是透過 Google Analytics 完成計算。</p><p>Google Analytics 也會有改版更新，一直看著那通知覺得有點煩。後來想想，這不過是幾個月才更新一次的小網站，統計人數也沒什麼意思，我自己都不怎麼在乎，那就乾脆整個拔掉。</p><p>Update: 朋友架設了 Matomo 並且開了帳號給我，我也很想試試看，於是剛剛加上了 Matomo 的 tracking code</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;長久以來都有放 Google Analytics 的程式，拿來計算來站人數，不過剛剛把所有相關的程式都拔掉了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>關於台灣交通的雜感</title>
    <link href="https://jchu.cc/2023/01/09-transportation.html"/>
    <id>https://jchu.cc/2023/01/09-transportation.html</id>
    <published>2023-01-08T15:16:58.000Z</published>
    <updated>2023-07-03T01:43:14.862Z</updated>
    
    <content type="html"><![CDATA[<p>這應該算是資質駑鈍：長到三十多歲的年紀，我才理解到交通之於生活的重要性。</p><p>除了現在旅居日本，我還有幾次到國外出差的經驗，短時間內在不同國家的街道步行而明顯感受到衝擊，對於台灣的交通環境更有感觸。在此整理我對台灣交通的看法與期待，以後跟朋友討論到交通問題就能以此篇文章出發，不需要什麼事都從頭講。</p><p>更希望拋磚引玉，看到這篇文章的鄉親，也抒發自己對台灣交通的看法，促進公共討論，推動交通意識改變，進而改善生活環境。我不天真地認為幾十年的沈痾會在短時間內被革除，但是先把問題講清楚，講久了，眾人才有病識感。</p><p>先有病識感，才知道有病要治，接著各種處方建議才會被接受。</p><span id="more"></span><p style="color: #AAA">免責聲明：我的經驗告訴我，有些事情進入政策細節或是科學判斷的時候，常會出現與直覺不符的答案。所以並非交通專業的我理所當然會出錯，也期待有人指正我，順勢推廣更多交通知識。</p><h2 id="出差看見的美國交通瞥見台灣的影子"><a href="#出差看見的美國交通瞥見台灣的影子" class="headerlink" title="出差看見的美國交通瞥見台灣的影子"></a>出差看見的美國交通瞥見台灣的影子</h2><div style="max-width: 100%; margin: auto;"><img src="/2023/01/09-transportation/austin.jpg" class=""></div><p>講到美國的第一印象就是國土寬廣。有次出差去了德州，德州為美國第二大州，當然也是幅員遼闊。上圖是在德州首府 Austin 隨手拍下的照片，照片主角是建築物，在街頭很輕易就能看見的，平凡無奇的停車場。台灣也是有大型停車場，但是比起德州人如此豪爽地使用土地，隔沒幾條街就能蓋起停車大樓，寸金寸土的台灣都會區實在阮囊羞澀，只能在空間隙縫中擠出停車格。</p><p>另外兩張圖，我記得是 35 號州際公路跟 E 6th Street 的路口，從旅館的高處往這看，每天都能看見綿延不斷的回堵塞車。當時頗為驚訝，就算德州也有塞車之苦。可見不管國土再大，通勤時刻的都會區路口就是會塞車。</p><p>即便如此，汽車仍然是美國「正常生活」的低標，擁有自己的汽車才有自由移動的能力，才是正常的成年人。這樣的思維其實台灣相當熟悉，滿十八歲最重要的一件事情就是考到駕照，騎著摩托車實現交通能力的自由。</p><p>美國國土遼闊，台灣呢？我不曾聽過任何人用「大」形容台灣，雖然我們並非迷你小國，但絕對不會有人覺得台灣很大。</p><p>不過，如果要比人口密度，台灣就很厲害了。</p><p>從維基百科的<a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%9B%BD%E5%AE%B6%E5%92%8C%E5%9C%B0%E5%8C%BA%E4%BA%BA%E5%8F%A3%E5%AF%86%E5%BA%A6%E5%88%97%E8%A1%A8">人口密度列表</a>來看，世界上 200+ 的國家、地區裡，台灣排名 20。密度更高的有摩納哥、直布羅陀、梵蒂岡這些真正迷你的地方，前面 19 個只有 3 個比台灣大，其他甚至比苗栗國 1800 平方公里還要小。也就是說台灣的人口密度可說世界頂尖，更別提台灣多數人口都聚集在西側。</p><p>人口如此密集的國家，交通政策卻向美國看齊，這個大方向就註定台灣交通會有困境</p><ul><li><a href="https://opinion.udn.com/opinion/story/8048/2842031">從車的城市到人的城市：台灣該向美國汽車文化看齊？ - 廖桂賢</a></li></ul><h2 id="台灣的交通困境與螺旋"><a href="#台灣的交通困境與螺旋" class="headerlink" title="台灣的交通困境與螺旋"></a>台灣的交通困境與螺旋</h2><p>雖然心裡知道「台灣的交通不是很好」，但自小在台灣長大，早已經習慣車水馬龍，似乎也沒什麼太大的問題。直到三十歲後經常往返各國，仔細體會行走國外街道的感覺，接著飛了幾個小時回到台灣，踏上原本熟悉的馬路：這路況真糟糕啊！</p><p>撇除特異的台北市不談，以私人交通工具為主的台灣家庭，評比交通效率的考量往往是這兩點</p><ul><li>從家裡出門能夠多快到目的地</li><li>停車後需要步行多久到目的地</li></ul><p>政府對改善交通的承諾，也都是滿足上述兩點為主。遇到交通的民怨，往往會開新路或增設快速道路，接著在終端想辦法擠出停車場或停車格。台灣發展觀光的方式也大致如此，任何觀光景點遇上交通問題，只要情況允許就會盡可能開路。於是在某個縣市的兩個景點之間可能會不斷地開新路，或是拓寬原有道路。</p><p>在台灣文化裡開路等同建設，建設等同選票支持，這是地方政治的要點：不管真實需求的高低，能建設馬路，地方就願意支持。誰敢反對就是跟選票過不去。</p><p>從這樣的文化，就能勾勒出台灣的交通困境的原因。不論開了幾條順暢的路，終端永遠都是人多的地方，難以生出停車位。本來就腹地狹小的城鎮或景點，湧入的車輛永遠高於停車位數量，自然產生的結果就是大家各憑本事隨意停車，先天停車位不足，後天要靠執法補救也只會累積民怨。</p><p>停車問題會影響旅遊品質。雖然台灣好山好水，但是許多知名觀光景點的旅遊體驗相當糟糕，家庭出遊最大的精神消耗就是塞車與停車。</p><p>就算不談出遊，一般家庭的停車問題就已經很嚴重。新建的大樓通常都有地下停車場容納住戶的車輛，情況可能好一點。但早期的房子沒有考慮到停車位，所以住戶都是在家附近尋找車位，有些停車位處於灰色地帶，也常耳聞鄰居間因為停車問題產生糾紛。更何況現在一個家庭常常需有兩台車，又有多少人家裡有兩個停車格？</p><p>台灣也有人嘗試反制，也就是以檢舉的方式減少違停。遵守交通條例的人認為，已經付出成本，把自己的生活方式調整成不需要依靠違規，為什麼還要忍受其他人的違規降低自己的生活品質？但是對許多人而言，模糊地帶的停車一直都是生活的一部分，為何長時間累積而成的默契要被不知名的人打破？</p><p>當兩方發生衝突，民意代表自然成為解決衝突的角色。但是全國上下不曾對交通戰略做出通盤檢討，局部的法規取締必然收效甚微，不免猜出民意代表最後會如何取捨。</p><p><a href="https://www.thenewslens.com/article/135482">要消滅檢舉達人，形象清新的賴品妤為何成為「羅淑蕾第二」？</a></p><h2 id="以大眾交通為主的東京地區"><a href="#以大眾交通為主的東京地區" class="headerlink" title="以大眾交通為主的東京地區"></a>以大眾交通為主的東京地區</h2><p>用我比較熟悉的東京地區 (涵蓋千葉、埼玉與神奈川)，住在這塊地區的人，多半不用買車。或著換個角度說，不買車的人也能夠在這塊地區找到落腳處。</p><p>整個大東京地區，由 JR、都營地鐵與各種私鐵交織出相當綿密的網絡，之外還有各家公車補足沒有被鐵路網涵蓋到的區域。多數人選擇住宅的方式就是以車站為中心，走路十五分鐘內能到的地方就算是能夠住人的範圍。再遠一點的人，便會選擇用自行車作為接駁工具。多數大樓以及車站外都有自行車停車場，由於停車的限制，自行車 + 鐵道往往會比騎摩托車要來得方便。</p><p>如果要比喻的話，整個東京就是捷運跟人行道更密集，去掉大量摩托車的台北市。我相信規劃東京自由行的外國人，乃至於到東京近郊甚至遠達富士山的外國人，多半不需要考慮租車的問題。</p><div style="max-width: 100%; margin: auto;"><img src="/2023/01/09-transportation/sidewalk.jpg" class=""></div><p>雖然東京也是寸土寸金，保護行人路權卻不馬虎。不只有完整的人行道，許多鬧區，例如銀座或秋葉原，在週末還會實施行人天國，該路段禁止汽車駛入，讓行人安心地逛街消費。</p><p>出了東京地區的交通，如果目的地是知名景點，經常還是有電車或公車可以抵達。如果一定要開車，可以選擇轉乘電車之後再開車。我以前去富士山附近玩都是全程開車，最近幾次都是坐電車到小田原之後再租車，省去中間的長途開車與塞車隱憂。用台灣的地理位置來比喻，若從台北想去日月潭玩，與其直接開車，不如先搭高鐵到台中烏日站，再租車前往日月潭。</p><p>在東京地區，絕大多數的交通需求都能用大眾交通工具滿足，開車的必要性被降低之後，停車的問題也減少許多。如果沒有特殊的需求(譬如載老人或嬰幼兒)，往往搭鐵道的體驗優於自駕。</p><h2 id="交通影響生活"><a href="#交通影響生活" class="headerlink" title="交通影響生活"></a>交通影響生活</h2><p>東京跟台灣的交通方式如此不同，那麼對生活有哪些影響呢？</p><p>生活中能做的事情，取決於我們能行動的範圍。青少年就是最好的例子，步入高中之後開始發展個人興趣，想做的事情愈來愈多，但是若缺少父母接送，很多想做的事情都做不了。我這種鄉下長大的小孩，真正能夠嚐到自由的滋味，是滿 18 歲之後家裡為我買了一台摩托車才開始。</p><p>但是自由的生活，又會在結婚生子後瞬間崩毀。我有很多朋友的小孩已經是國小的年紀。同事早早到公司不是因為勤奮，是因為要配合小孩的上學時間。至於放學，幸運的人早早準時下班去接小孩，不夠幸運的人就是再多花一筆錢，把小孩送去安親班待到下班時間為止。</p><p>日本就不是這樣。日本人在升上小學之後，多數就會開始自己上學，有些是完全步行，有些會轉乘電車、公車。年紀再大一點，就能自己坐車出遠門，早早就能體會到獨立的感覺。</p><div style="max-width: 100%; margin: auto;"><img src="/2023/01/09-transportation/students.jpg" class=""></div><p>我個人的直覺，房價也跟交通有關。在日本租房的地點選擇方式，其實還滿像台北市，車站十分鐘步行距離為最佳。不同的是電車涵蓋的網路比台北市更大更密集，房屋的選項也更多。以我之前通勤的距離為例，我從出門到坐進辦公室的時間大約是 70 分鐘，通勤的距離約 30 km。</p><p>有時候在想，如果把同等級的鐵路網放到台北市，從台北車站拉 30 公里都到大溪了。但是在大台北地區捷運的覆蓋密度不比東京地鐵，選項少房價自然高。至於沒捷運的省轄市，情況更是悲慘。</p><p>並非日本人不開車，而是在日本的都會區，人們有很多不開車的選擇，道路硬體的建設也會優先考量行人，同時也是照顧社會弱勢，那些沒能力開車的老人、小孩，或是負擔不起車價的人。</p><p>但是在台灣，每個人都沒有選擇的餘地，只能開車或騎車，只能跳進道路的修羅場掙扎求生。</p><h2 id="台灣交通有沒有改變的機會？"><a href="#台灣交通有沒有改變的機會？" class="headerlink" title="台灣交通有沒有改變的機會？"></a>台灣交通有沒有改變的機會？</h2><p>我舉不出什麼專業的論點作為理論基礎，只是我個人會希望台灣交通能在這兩點上做出改變</p><ul><li>更多的大眾交通工具</li><li>更多的人行道</li></ul><p>台灣人口高度密集，腹地也不算遼闊。若能用鐵路之類的工具建成網絡，「CP值」應該要比日本還高。人們有了開車騎車以外的選擇，才有可能降低道路上的壓力，接著才去要求民眾做出更好的駕駛行為(停車、禮讓行人)。也才能釋放空間，施作人行道。</p><p>然而民眾已經習慣使用汽機車作為工具，糟糕的路況多數人也習以為常，我還真不敢期待有哪位民意代表或民選首長，敢去做任何丟選票，短期內看不出成果的交通改革。但是台灣這個死結已經綁了幾十年，絕不是抽一兩個線頭就能解開，只能祈禱哪天出現一位有遠見的交通部長，訂下長遠的戰略，逐步改變台灣的交通方針。至於這個結該從何解起，我還真沒有頭緒</p><p>不過對於任何社會秩序問題，我的原則都會是「工程先於規範」。先在工程面增加安全係數，再從規範面去要求駕駛做出更好的行為。比起大刀闊斧地蓋大眾交通系統，或許改善現有的道路工程、標線劃設，會更適合台灣這種高度在意 CP 值的國家吧。</p><ul><li><a href="https://www.twreporter.org/a/sidewalk-pedestrian-traffic-safety">被稱「行人地獄」的台灣──為何我們的馬路設計不安全？</a></li><li><a href="https://www.twreporter.org/a/sidewalk-pedestrian-roadmarking-advocates">「撞死人才想改」太慢，兩位「馬路醫生」日常道路改造大作戰</a></li></ul><p>每個人都會被交通影響生活，同時每個人也在影響交通，我們還是有些能做的小事，聚沙成塔慢慢推動交通的改革</p><ul><li>對行人多些同理心<ul><li>我們都有當行人的機會，友善行人的環境，對我們自身也有好處</li><li>同時把這種想法分享給親友，擴散影響力。</li><li>正如自己家裡的長輩或小孩走在路上，我們也希望他們行走得安全、安心，能被其他駕駛尊重。</li></ul></li><li>開車出門多預留時間緩衝，讓自己開車的心情不要過度緊繃<ul><li>留有餘裕的行車心態，也能減少事故機率</li><li>行車事故的成本很高，小則時間金錢，大則生命安全，搶快實在不划算</li></ul></li><li>觀察生活周遭的人行動線<ul><li>正如前述，先有病識感就很夠了。</li><li>觀察自己常走的路段，有哪些不舒服的地方，或是不合理的設計。</li><li>行有餘力者再向當地的民意代表提出想法，要求他們改進。</li></ul></li></ul><p>交通的變革需要無比的耐心，難收速效。話說回來，搞不好幾十年後，台灣的交通問題與高房價問題，會因為人口數大幅減少而自然痊癒？(笑)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;這應該算是資質駑鈍：長到三十多歲的年紀，我才理解到交通之於生活的重要性。&lt;/p&gt;
&lt;p&gt;除了現在旅居日本，我還有幾次到國外出差的經驗，短時間內在不同國家的街道步行而明顯感受到衝擊，對於台灣的交通環境更有感觸。在此整理我對台灣交通的看法與期待，以後跟朋友討論到交通問題就能以此篇文章出發，不需要什麼事都從頭講。&lt;/p&gt;
&lt;p&gt;更希望拋磚引玉，看到這篇文章的鄉親，也抒發自己對台灣交通的看法，促進公共討論，推動交通意識改變，進而改善生活環境。我不天真地認為幾十年的沈痾會在短時間內被革除，但是先把問題講清楚，講久了，眾人才有病識感。&lt;/p&gt;
&lt;p&gt;先有病識感，才知道有病要治，接著各種處方建議才會被接受。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="government" scheme="https://jchu.cc/tags/government/"/>
    
  </entry>
  
  <entry>
    <title>政治參與程度之我見</title>
    <link href="https://jchu.cc/2022/11/27-political.html"/>
    <id>https://jchu.cc/2022/11/27-political.html</id>
    <published>2022-11-27T12:47:25.000Z</published>
    <updated>2022-11-27T15:09:30.919Z</updated>
    
    <content type="html"><![CDATA[<p>在不同地方政治人物旁邊看多了，覺得不同政治參與程度的人可以被歸分到不同的族群。而且不同族群的人對於政治會有不同的想像與感受</p><p>當然以下的想法沒有任何數據佐證，純粹就是我的個人看法。</p><span id="more"></span><h1 id="簡單分類"><a href="#簡單分類" class="headerlink" title="簡單分類"></a>簡單分類</h1><p>根據不同的參與程度，我會粗略分成下面四個族群。每次聽到任何人講地方的政治八卦，我就會先將對方分類到以下其中一個群體，當作我驗證對方說話可性度的參考。</p><div style="max-width: 100%;" class="img-row"><img src="/2022/11/27-political/group.svg" class=""></div><ul><li>政客：沒有貶意，純粹是為了省字。除了檯面上民意代表與官員，還泛指該人周圍的幕僚與黨工</li><li>樁腳：我常說這些人吃政治飯的人。舉凡什麼社區發展協會主委、里幹事、某某協會理事長…等等。這些人最常向政客要各種補助經費，也是吃飯喝酒的主揪。也包括許多協會成員，或是義消之類的。</li><li>鄉親：並非直接靠政治維生，但是工作上常跟前兩者往來。通常會是家裡做生意，或是跟樁腳私交不錯的人</li><li>公民：基本上講不出自己家附近有什麼阿里不搭協會的人，多半就在這裡了。多數小本生意人或上班族都在這裡面。</li></ul><p>鄉親跟公民是我硬湊出來的詞，只是不想用「民眾A/B」來指稱兩者。</p><p>鄉親跟公民的比例，在服務業興盛的都會區跟農業比例高的鄉下不同，移入人口多的新市鎮，與人口老化的老市鎮也不一樣。</p><h1 id="所謂地方聲音"><a href="#所謂地方聲音" class="headerlink" title="所謂地方聲音"></a>所謂地方聲音</h1><p>基本上政客與助理都很忙，會期之外就是跑行程參加各種活動，或是各種會勘去現場看看東西蓋德有沒有問題，又或著是處理大小的選民服務。所以政客實際上並沒有辦法真正地接觸到普羅大眾</p><p>你如果覺得很奇怪，沒有做民調的時候，到底哪來的「地方聲音」？其實就是樁腳的聲音。</p><p>那些樁腳就是整天到處跑，努力做 1) 跟政客混熟 2) 跟其他樁腳混熟 3) 跟民眾A 混熟。政客最直接的管道，就是聽到樁腳告訴他的消息。</p><p>但是樁腳也有自己的利害關係，而且他能接觸的「民眾」最多也只到鄉親。比較有良心的樁腳會傳達鄉親的心聲，沒良心的就玩資訊操弄，賣給政客有利自己的資訊。</p><p>沒有民調的時候，政客只能高度仰賴樁腳，或是熟識的鄉親的意見。如果你家那邊的政客如果幹了什麼鳥事，若不是為了私利，多半就是這一層在亂搞。</p><h1 id="政治謠言"><a href="#政治謠言" class="headerlink" title="政治謠言"></a>政治謠言</h1><p>地方謠言的出現，大致上都是這樣</p><ul><li>樁腳A：「弄成這樣，我覺得老王搞不好會出來選立委」</li><li>樁腳B：「C 我跟你講，A 說他覺得老王會出來選立委」</li><li>樁腳C：「我聽 B 說老王可能會出來選立委」</li><li>樁腳D：「聽說老王要出來選立委了」</li><li>樁腳E：『誰説的』</li><li>樁腳D：「B 講的，應該很可靠」</li></ul><p>雖然樁腳的工作是傳遞訊息，但並非傳遞精準的訊息。所以很多地方耳語起源於樁腳的個人臆測。</p><p>即使是同黨的政客，也偶有利益衝突，也常常會是選舉的對手，所以政治人物之間的訊息交換非常不透明，並沒有公民所想的那麼團結一致。如果沒有派系頭來排解，就會有很多樁腳介入的空間。</p><h1 id="選舉的資訊傳遞"><a href="#選舉的資訊傳遞" class="headerlink" title="選舉的資訊傳遞"></a>選舉的資訊傳遞</h1><p>按照通常的理解，我區分成陸戰、空戰以及傳統媒體。選舉的時候就是透過資訊的傳遞去影響鄉親與公民的意願</p><h2 id="陸戰"><a href="#陸戰" class="headerlink" title="陸戰"></a>陸戰</h2><p>平常看到誰挺誰，就是政客指揮樁腳要支持誰。樁腳本身人數不算多 (但在地方基層選舉也是稍有影響)，但是樁腳很能影響鄉民，鄉民的數量就可觀多了，多席次的民意代表選舉只要掌握好這個就有保證的席次</p><p>「比起陌生人，把資源分享給自己熟識的人」我覺得算是人類的動物本能。對於公民而言，平常就會打招呼聊天的鄉親，選舉的時候若是沒接收到太強烈的政治訊息，投票意向就很容易被鄉親影響。</p><p>陸戰能夠影響的有樁腳、鄉親，還有一部分的公民。</p><h2 id="空戰"><a href="#空戰" class="headerlink" title="空戰"></a>空戰</h2><p>沒有時間跟資源養樁腳跟鄉親，所以新興候選人多半只能從網路打空戰。但是空戰其實直接影響的也有限，除了公民圈裏面對政治比較在乎的一塊，以及稍微進一點的鄉親。</p><p>於是空戰的間接影響就很重要，如何透過公民裡面的有色圈，把自己形塑成值得選的人，推銷給公民無色圈。公民無色圈其實也不懂那麼多艱深的理論，也沒多堅定的意志。「反正我也沒特別想投誰，既然我那朋友都說這個人不錯，那就投他吧」</p><p>空戰能夠影響的範圍就是有色公民圈，以及一部分無色公民圈。能影響到多少廣？不知道</p><p>對，這就是空氣票</p><h2 id="傳媒"><a href="#傳媒" class="headerlink" title="傳媒"></a>傳媒</h2><p>說某傳媒沒顏色，在台灣應該沒人相信吧。反正選舉期的傳媒就是宣傳機器，藍綠各取所需。</p><p>傳媒對於選舉的影響很強烈。陸戰的論述基本上是從傳媒的主軸變化而來。譬如說某民代質疑疫苗採購不法，樁腳就在看新聞的時候煽風點火：「那個一定有貪啦，騙我們不知道」。當然也可能反操作：「那個都是假的，媒體被操控了」</p><p>空戰也會被影響，當傳媒的某個議題發酵且對候選人不利的時候，有色公民圈就要向無色圈努力解釋。無色圈的人就變成整天看新聞說 A，偶爾聽朋友說 B，接著覺得政治真的很煩。</p><h2 id="聊天群組"><a href="#聊天群組" class="headerlink" title="聊天群組"></a>聊天群組</h2><p>我沒在圖片畫出來，但我會把 LINE/FB 群組歸類在陸戰。雖然這些是數位工具，但是用法其實相當傳統。其實就是把以前在榕樹下或街尾聚在一起罵對方陣營的作法，搬到數位工具上，而且執行得更有效率。</p><p>這種聊天室不是用來論理辨是非，而是用來傳播特定論點。</p><h1 id="2022-地方選舉的雜想"><a href="#2022-地方選舉的雜想" class="headerlink" title="2022 地方選舉的雜想"></a>2022 地方選舉的雜想</h1><p>我覺得 2020 的民進黨內總統初選，大致上就是傳統的賴清德陸戰派與蔡英文空戰派的對決，延續到總統選舉結束可說是小英完全勝利。我想從政者都很明白陸戰的重要，這不必贅言。但是蔡跟黨內派系競爭的時候 (沒有人天真到以為民進黨內一派和諧吧？)，想要推的人通常基層實力也不比傳統派系，有限資源下只能更多倚賴空戰。</p><p>於是在那之後，各個空戰側翼的自信與聲量就愈加膨脹，連帶也影響著綠營網路支持者的態度。遇到風向不順的議題就變得敏感且富攻擊性。</p><p>近年來的各大議題，對執政黨有意見的人不都被指教過一輪？同黨內有意見的人貼上叛徒的標籤。看那違規停車還會對警員施壓，陰德值已經很低的徐巧芯，都能夠挖出側翼群組要出征的難堪新聞給自己得意一陣。這些側翼網軍不是持續在削弱民進黨在空戰的實力嗎？</p><p>誠如前述，空戰是要靠間接的影響力，透過口碑的傳遞把政令或候選人推銷出去。但是現在民進黨空軍愈加極端，燒光陰德值後以前願意講話的淺色公民圈的人明哲保身只能站得遠一點，論述就傳不出去了。第一層的人沒意願討論，傳統媒體更沒有興趣追蹤。</p><p>那麼最外面的人聽到的是什麼呢？各種論文的花絮。結果就是傳統媒體表演大亂鬥，聽不太懂政治的人就覺得煩了。</p><p>總體來說我覺得空戰其實影響有限，但是在風向不太糟糕的時候，能夠激起淺色公民圈甚至到無色那一塊的認同。但是這個傳遞鏈已經被那些劍走偏鋒的側翼弄斷了</p><p>你我這種「會看部落格文章的中產階級上班族」，多半都是最外圈的邊緣人。坦然面對吧，無足輕重的我們就算跳樓也不見得會上新聞，我們說的話也沒什麼份量。想要幫綠營的話，只要不添亂不到處罵人，讓身邊無色圈的朋友覺得「其實台獨份子也是很務實的」就功德無量了</p><p>民主沒有特效藥，台獨也沒有。來得快的東西，去得也快。台獨這條線要走得穩，只能在現實中，慢慢取得一位又一位的認同</p><p>把那些做哏嘲諷反對者，用力嘶喊誰是叛徒，或是整天叫你疼惜民進黨的帳號，尤其是不知道本尊的帳號全部封掉吧，那些是阻礙民進黨重新前進的絆腳石</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在不同地方政治人物旁邊看多了，覺得不同政治參與程度的人可以被歸分到不同的族群。而且不同族群的人對於政治會有不同的想像與感受&lt;/p&gt;
&lt;p&gt;當然以下的想法沒有任何數據佐證，純粹就是我的個人看法。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 雙冒號 ::someMethod 的觀察</title>
    <link href="https://jchu.cc/2022/09/04-kotlin.html"/>
    <id>https://jchu.cc/2022/09/04-kotlin.html</id>
    <published>2022-09-03T15:09:44.000Z</published>
    <updated>2022-09-03T16:20:44.478Z</updated>
    
    <content type="html"><![CDATA[<p>寫 kotlin 的時候經常會看到 <code>::myMethod</code> 的出現，本文觀察編譯器的結果去猜測可能的過程。並非真正地去閱讀規格或源碼。若有寫不正確的地方，還請鄉親指正</p><span id="more"></span><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>有時候在實作中，我們會自製一些可被觀察的物件 Observable，以及觀察者 Observer。然後在 Fragment 結束的時候拔掉 Observer。Observer 的實作就用 lambda 解決</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.addObserver &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.removeObserver &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>上面的片段一看就知道很有問題，因為新增跟刪除傳遞進去的東西很明顯不是同一個物件實體。通常會生出一個 private field 來指向同一個物件實體。但如果寫成這樣呢？能夠順利地移除掉 Observer 嗎？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.addObserver(::doSomething)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myDataOwner.removeObserver(::doSomething)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>先說結論：<strong>運氣好的話，可以。</strong></p><p>這邊引出幾個問題</p><ul><li>為什麼可以？在哪些情況下可以？</li><li>究竟 <code>::doSomething</code> 這段做了什麼事？</li><li>或著問，<code>::doSomething</code> 總是回傳同樣的東西嗎？(Singleton?)</li></ul><p>在那之前，我先岔題談一下 Lambda</p><h1 id="Lambda-是如何傳遞的"><a href="#Lambda-是如何傳遞的" class="headerlink" title="Lambda 是如何傳遞的"></a>Lambda 是如何傳遞的</h1><p><a href="https://kotlinlang.org/docs/lambdas.html">Lambda</a> 鄉親都用得很爽，常聽到函式在 Kotlin 裡面是 First-class，就文件跟編譯的結果來看，Kotlin 是透過 <code>kotlin.jvm.functions.Function0</code> 或是類似的內部類別來實作，這東西就跟 Java 的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html">Method</a>差不多。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">observable.addObserver &#123;</span><br><span class="line">    println(<span class="string">&quot;===Inside lambda&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> myFunc = <span class="keyword">object</span> : Function0&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;====Inside function&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">observable.addObserver(myFun)</span><br></pre></td></tr></table></figure><p>這兩個寫法都可以只是上方的 Lambda 會產生一個匿名類別(anonymous class)，通常用數字取名 <code>$1</code>，底下會產生一個 <code>$myFunc</code>的類別。放編譯檔案的目錄 <code>app/build/...</code> 裡面就能找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$myFun$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$1.class</span><br></pre></td></tr></table></figure><p>用 javap 去看，會發現兩個東西很像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">$ javap <span class="string">&#x27;./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$1.class&#x27;</span></span><br><span class="line">Compiled from <span class="string">&quot;MyObservableTest.kt&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">foooo</span>.<span class="title">baaar</span>.<span class="title">MyObservableTest</span>$<span class="title">testInstance</span>$1 <span class="keyword">extends</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">internal</span>.<span class="title">Lambda</span> <span class="keyword">implements</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">functions</span>.<span class="title">Function0</span>&lt;<span class="title">kotlin</span>.<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> foooo.baaar.MyObservableTest$testInstance$<span class="number">1</span> INSTANCE;</span><br><span class="line">  foooo.baaar.MyObservableTest$testInstance$<span class="number">1</span>();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myFun</span></span><br><span class="line">$ javap <span class="string">&#x27;./tmp/kotlin-classes/debugUnitTest/foooo/baaar/MyObservableTest$testInstance$myFun$1.class&#x27;</span></span><br><span class="line">Compiled from <span class="string">&quot;MyObservableTest.kt&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">foooo</span>.<span class="title">baaar</span>.<span class="title">MyObservableTest</span>$<span class="title">testInstance</span>$<span class="title">myFun</span>$1 <span class="keyword">implements</span> <span class="title">kotlin</span>.<span class="title">jvm</span>.<span class="title">functions</span>.<span class="title">Function0</span>&lt;<span class="title">kotlin</span>.<span class="title">Unit</span>&gt; </span>&#123;</span><br><span class="line">  foooo.baaar.MyObservableTest$testInstance$myFun$<span class="number">1</span>();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>兩個都實作了 <code>Function0</code>，這就有點像是 Runnable 的介面，<a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/function-types.md">Kotlin Function Type</a> 是這麼寫的</p><ul><li>On JVM, introduce Function0..Function22, which are optimized in a certain way, and FunctionN for functions with 23+ parameters. When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.</li><li>Also on JVM (under the hood) add abstract FunctionImpl which implements all of Function0..Function22 and FunctionN (throwing exceptions), and which knows its arity. Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.</li></ul><p>也可以看一下 JVM 的實作<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/FunctionImpl.java">FunctionImpl.java</a></p><p>小結：使用 Lambda 的時候，Kotlin 會自動幫你實作一個匿名類別，你傳遞過去的東西其實是這個匿名類別的實體化物件</p><h1 id="雙冒號-class-java-在幹嘛？"><a href="#雙冒號-class-java-在幹嘛？" class="headerlink" title="雙冒號 ::class.java 在幹嘛？"></a>雙冒號 ::class.java 在幹嘛？</h1><p>這是 Kotlin 使用 <a href="https://kotlinlang.org/docs/reflection.html">Reflection API</a> 的方法。Java 也有一套 Reflection API，讓你能做一些見不得光的事情，尤其測試的工具經常大量使用到 Reflection。在 Java 裡面通常會先拿到一個叫做 Class 的類別，然後用那個類別動態挖出一些 Method 來用。在 Kotlin 裡面，除了能用 Java 的 Class，做了很多對應的類別，好比 <code>KClass</code>，加個 K 就是 Kotlin 界的東西。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> j: Class&lt;Foobar&gt; = Foobar::<span class="keyword">class</span>.java</span><br><span class="line"><span class="keyword">val</span> k: KClass&lt;Foobar&gt; = Foobar::<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>這個範例加上了型別，所以就很清楚知道 <code>MyClass::class.java</code> 是使用 Reflection API 去拿到 Java 界的 <code>Class</code> 類別，而 <code>MyClass::class</code> 是拿到 Kotlin 界的 <code>KClass</code> 類別。</p><p><code>::class.java</code> 就相當於以前的 <code>object.getClass</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> j: Class&lt;Foobar&gt; = Foobar::<span class="keyword">class</span>.java</span><br><span class="line"><span class="keyword">val</span> obj = Foobar(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> oldSchool: Class&lt;Foobar&gt; = obj.javaClass</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;oldSchool === j&#125;</span>&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>小結：<code>::class</code> 是使用 Reflection API 的方法，用來拿到 <code>KClass</code> 這個類別</p><h1 id="雙冒號-someFunc-在幹嘛？"><a href="#雙冒號-someFunc-在幹嘛？" class="headerlink" title="雙冒號 ::someFunc 在幹嘛？"></a>雙冒號 ::someFunc 在幹嘛？</h1><p>前面是用 <code>::class</code>，但如果到我們的主角，雙冒號後面接個 method 呢？雖然同樣用 <code>::</code> 都是 Reflection，但是此時的行為不一樣。</p><p>Kotlin 是個語言，跑在 JVM 上面只是這個語言的其中一種實作。只論 JVM 這部分的話，Kotlin 遇到 <code>::someFunc</code> 的處理方式，跟前面的 lambda 很像，都是產生一個匿名類別，然後傳遞出去。</p><p>而且 <code>類別::someFunc</code> 跟 <code>物件::someFunc</code> 雖然都是產生出 <code>Callable</code> 的物件，但是兩者有所不同。懂 JS 的人，想像一下 <code>Function.prototype.apply()</code>就知道了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foobar = Foobar(<span class="string">&quot;Foobar&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> funSpeakA: KFunction&lt;<span class="built_in">Unit</span>&gt; = foobar::speak</span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line">funSpeakA.call()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funSpeakB: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak</span><br><span class="line"><span class="comment">// runTime 會爆出 IllegalArgumentException Callable expects 1 arguments, but 0 were provided.</span></span><br><span class="line">funSpeakB.call()</span><br><span class="line"><span class="comment">// 塞一個 Instance 給它就可以了</span></span><br><span class="line">funSpeakB.call(foobar)</span><br></pre></td></tr></table></figure><p>在上面的例子，生出 funSpeakB 的時候根本不知道<code>this</code> 是誰，所以會生出一個需要傳入 Foobar 實例的函式物件。</p><p>既然知道這麼多「生出匿名類別與 Callable 物件」的技巧，可以看看這段程式碼會生出幾個匿名類別？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foobar = Foobar(<span class="string">&quot;Foobar&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> funSpeakA: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak <span class="comment">// 從 class 產生</span></span><br><span class="line"><span class="keyword">val</span> funSpeakB: KFunction&lt;<span class="built_in">Unit</span>&gt; = Foobar::speak</span><br><span class="line"><span class="keyword">val</span> funSpeakC: KFunction&lt;<span class="built_in">Unit</span>&gt; = foobar::speak <span class="comment">// 從 instance 產生</span></span><br><span class="line"><span class="keyword">val</span> funSpeakD: () -&gt; <span class="built_in">Unit</span> = foobar::speak</span><br><span class="line"><span class="keyword">val</span> funSpeakE: () -&gt; <span class="built_in">Unit</span> = foobar::speak</span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver(funSpeakD)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br><span class="line">instanceFromMyObservable.addObserver(foobar::speak)</span><br></pre></td></tr></table></figure><p><strong>答案是「8個」</strong>，abcde 各五個，以及 addObserver 那三行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakA$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakB$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$1.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$2.class</span><br><span class="line">./tmp/kotlin-classes/debugUnitTest/investigate/reflection/mypkg/Tester$testReflection$3.class</span><br></pre></td></tr></table></figure><p>而且看 Java 的 byte code，還真的都是拿不同的類別來做事</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">18</span>: getstatic     #<span class="number">49</span>  <span class="comment">// Field investigate/reflection/mypkg/Tester$testReflection$funSpeakA$1.INSTANCE:Linvestigate/reflection/mypkg/Tester$testReflection$funSpeakA$1;</span></span><br><span class="line"> <span class="number">21</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">24</span>: astore_3</span><br><span class="line"> <span class="number">25</span>: getstatic     #<span class="number">54</span>  <span class="comment">// Field investigate/reflection/mypkg/Tester$testReflection$funSpeakB$1.INSTANCE:Linvestigate/reflection/mypkg/Tester$testReflection$funSpeakB$1;</span></span><br><span class="line"> <span class="number">28</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">31</span>: astore        <span class="number">4</span></span><br><span class="line"> <span class="number">33</span>: <span class="keyword">new</span>           #<span class="number">56</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1</span></span><br><span class="line"> <span class="number">36</span>: dup</span><br><span class="line"> <span class="number">37</span>: aload_1</span><br><span class="line"> <span class="number">38</span>: invokespecial #<span class="number">57</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakC$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">41</span>: checkcast     #<span class="number">19</span>  <span class="comment">// class kotlin/reflect/KFunction</span></span><br><span class="line"> <span class="number">44</span>: astore        <span class="number">5</span></span><br><span class="line"> <span class="number">46</span>: <span class="keyword">new</span>           #<span class="number">59</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1</span></span><br><span class="line"> <span class="number">49</span>: dup</span><br><span class="line"> <span class="number">50</span>: aload_1</span><br><span class="line"> <span class="number">51</span>: invokespecial #<span class="number">60</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakD$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">54</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">57</span>: astore        <span class="number">6</span></span><br><span class="line"> <span class="number">59</span>: <span class="keyword">new</span>           #<span class="number">64</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1</span></span><br><span class="line"> <span class="number">62</span>: dup</span><br><span class="line"> <span class="number">63</span>: aload_1</span><br><span class="line"> <span class="number">64</span>: invokespecial #<span class="number">65</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$funSpeakE$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">67</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">70</span>: astore        <span class="number">7</span></span><br><span class="line"> <span class="number">72</span>: aload_2</span><br><span class="line"> <span class="number">73</span>: aload         <span class="number">6</span></span><br><span class="line"> <span class="number">75</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"> <span class="number">78</span>: aload_2</span><br><span class="line"> <span class="number">79</span>: <span class="keyword">new</span>           #<span class="number">71</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$1</span></span><br><span class="line"> <span class="number">82</span>: dup</span><br><span class="line"> <span class="number">83</span>: aload_1</span><br><span class="line"> <span class="number">84</span>: invokespecial #<span class="number">72</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$1.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"> <span class="number">87</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"> <span class="number">90</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"> <span class="number">93</span>: aload_2</span><br><span class="line"> <span class="number">94</span>: <span class="keyword">new</span>           #<span class="number">74</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$2</span></span><br><span class="line"> <span class="number">97</span>: dup</span><br><span class="line"> <span class="number">98</span>: aload_1</span><br><span class="line"> <span class="number">99</span>: invokespecial #<span class="number">75</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$2.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"><span class="number">102</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"><span class="number">105</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br><span class="line"><span class="number">108</span>: aload_2</span><br><span class="line"><span class="number">109</span>: <span class="keyword">new</span>           #<span class="number">77</span>  <span class="comment">// class investigate/reflection/mypkg/Tester$testReflection$3</span></span><br><span class="line"><span class="number">112</span>: dup</span><br><span class="line"><span class="number">113</span>: aload_1</span><br><span class="line"><span class="number">114</span>: invokespecial #<span class="number">78</span>  <span class="comment">// Method investigate/reflection/mypkg/Tester$testReflection$3.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span></span><br><span class="line"><span class="number">117</span>: checkcast     #<span class="number">62</span>  <span class="comment">// class kotlin/jvm/functions/Function0</span></span><br><span class="line"><span class="number">120</span>: invokevirtual #<span class="number">69</span>  <span class="comment">// Method investigate/reflection/mypkg/MyObservable.addObserver:(Lkotlin/jvm/functions/Function0;)V</span></span><br></pre></td></tr></table></figure><p>現在知道了 <code>::someFunc</code> 就像 lambda 一樣，會生出匿名類別，並產生 Instance 來用。而且，<strong>如果 ::someFunc 有兩行，就會產生兩個</strong>，知道這個問題的答案之後，也很容易回答另外一個問題。</p><p>既然都是用不同的類別來產生實體，當然不是回傳同樣的東西，絕對不是 Singleton</p><h1 id="什麼時候可以讓-removeObserver-如預期般運作"><a href="#什麼時候可以讓-removeObserver-如預期般運作" class="headerlink" title="什麼時候可以讓 removeObserver 如預期般運作"></a>什麼時候可以讓 removeObserver 如預期般運作</h1><p>那麼第一個問題，在什麼情況下可以這麼用呢？這跟 Observer 的實作有關。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObservable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> list: MutableList&lt;MyObserver&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">triggerObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            it.invoke()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addObserver</span><span class="params">(observer: <span class="type">MyObserver</span>)</span></span> &#123;</span><br><span class="line">        list.add(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">MyObserver</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> index = list.indexOfFirst &#123; it == observer &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            list.removeAt(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>實作的關鍵點就在 <code>removeObserver</code> 那邊，如果找到同樣的 observer 就拿掉，所以用 lambda 的時候很自然地就會拿不掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line">println(<span class="string">&quot;Size A: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver &#123; someFunc() &#125;</span><br><span class="line">println(<span class="string">&quot;Size B: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.removeObserver &#123; someFunc() &#125;</span><br><span class="line">println(<span class="string">&quot;Size C: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是如果改用 <code>::someFunc</code> 竟然會動！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instanceFromMyObservable = MyObservable()</span><br><span class="line">println(<span class="string">&quot;Size A: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.addObserver(::someFunc)</span><br><span class="line">println(<span class="string">&quot;Size B: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">instanceFromMyObservable.removeObserver(::someFunc)</span><br><span class="line">println(<span class="string">&quot;Size C: <span class="subst">$&#123;instanceFromMyObservable.list.size&#125;</span>&quot;</span>) <span class="comment">// 0 !!</span></span><br></pre></td></tr></table></figure><p>明明是不同類別產生的物件，為什麼可以順利被對應到？鄉民們一定馬上就想到<strong>因為 <code>==</code> 被改寫了！</strong></p><p>既然 Kotlin Relection 是產生 <code>KFunction</code> 介面的時候，那我們來看一下 JVM 平台的實作 <a href="https://github.com/JetBrains/kotlin/blob/b8b0b279ee2195ccbdce61e2365f123ee928532b/core/reflection.jvm/src/kotlin/reflect/jvm/internal/KFunctionImpl.kt#L176">KFunctionImpl</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> that = other.asKFunctionImpl() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> container == that.container &amp;&amp; name == that.name &amp;&amp; signature == that.signature &amp;&amp; rawBoundReceiver == that.rawBoundReceiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我沒有繼續深追下去確認細節，看起來是用相同 Reflection API 方法產生的類別都會在這邊被視為同一個東西。所以在上方的 Observer 實作就能用 <code>==</code> 找到「同一種東西」</p><p>我們可以用 <code>System.identityHashCode()</code> 找出物件的 hash code 來確認，其實它們真的不是同一個物件。也因此，如果在 <code>Observerable.removeObserver</code> 裡面用 <code>===</code> 當作比對的方法，就會發現原本可以 remove 的作法行不通了。這也就是我在一開始就說「運氣好的話，遇到用 <code>==</code> 來比對的實作，就可以這樣傳 <code>::someMethod</code> 進去」</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫 kotlin 的時候經常會看到 &lt;code&gt;::myMethod&lt;/code&gt; 的出現，本文觀察編譯器的結果去猜測可能的過程。並非真正地去閱讀規格或源碼。若有寫不正確的地方，還請鄉親指正&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="java" scheme="https://jchu.cc/tags/java/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Anki 的基本介紹與自訂卡片</title>
    <link href="https://jchu.cc/2022/09/01-anki.html"/>
    <id>https://jchu.cc/2022/09/01-anki.html</id>
    <published>2022-09-01T13:16:06.000Z</published>
    <updated>2022-09-01T15:27:39.964Z</updated>
    
    <content type="html"><![CDATA[<p>Anki 是相當知名的單字背誦軟體，但是製作卡片的方法不是很容易理解，本篇文章嘗試從軟體阿宅的角度做基本的介紹</p><span id="more"></span><p>光是看中文寫作能力，就已經比許多台灣人還要厲害的畢靜翰也說<a href="https://www.facebook.com/john.barthelette/posts/pfbid0EyfaNKzdjf8pW5X7SVuxinrfsoeStQpfeJXZW78ReoCek5YMCyn375ZAeSmfNheXl">學語言需要有技巧地背單字</a>，強者都這麼說了，當然要試著把這件事情做好。</p><p>正所謂工欲善其事，必先利其器，我們軟體阿宅，最喜歡花時間把工具弄好。就像很多人會花好幾天調整 Blog 的樣式，然後三年寫不到一篇。寫不寫 Blog 不是重點，重點是我們寫 Blog 的工具一定要夠順夠好用。同理，能用 Anki 背多少單字一點都不重要，重要的是能夠造出比別人更細膩的單字卡，這才是我們關心的部分。</p><h1 id="要做出怎樣的卡片"><a href="#要做出怎樣的卡片" class="headerlink" title="要做出怎樣的卡片"></a>要做出怎樣的卡片</h1><p>小畢那篇文章對於 Anki 用法的建議，大致整理要點如下</p><ul><li>正面寫上英文單字，譬如<code>Cone</code></li><li>背面寫上中文解釋，並且加上例句，例句裡面要把生字挖空，譬如<code>圓錐或圓錐體 The ____is gone: VLC Media Player silently banned in India</code></li></ul><p>就我的額外理解，對於這個單字要產生兩張卡片。一張卡片是扔出英文單字，考你中文意思；另一張卡片是扔出中文，要你在英文例句裏面填空。當你卡片數量累積夠多的時候，就可以偶爾考你英翻中，偶爾考你中翻英，兩邊夾攻之下聽起來效果會很不錯。</p><p>然而，但是，不過，But，我現在想學的是日文，學日文多了一個「漢字」要背。</p><p>漢字該怎麼安排？我想了很久都想不到一個合理的做法。我試過分別產生漢字跟假名的卡片來背誦，可是這樣效果很差。舉例來說「便利(べんり)」這個字，漢字跟中文解釋完全一樣，這樣產生的卡片就很尷尬。</p><p>我最近才想通，就單純背單字來說，我不應該去背漢字。就像完全不會寫漢字的日文小學生，全部寫假名然後用講的也能溝通，我應該要把假名當成英文，然後背誦的假名跟中文解釋的關係，譬如「正面：べんり；反面：很方便；東京の生活は…ですね」，漢字則當成一個補充學習的東西，反正對台灣人來說漢字大多數都不難。</p><p>所以我的目標就是做出這樣的卡片</p><ul><li>正面：假名</li><li>背面：中文解釋、挖空生字的例句</li><li>可選(optional) 的註釋，預設都是隱藏起來，直到按下去才會顯示出來</li></ul><p>這樣我就能用背英文單字的方式去背日文，真的想要知道額外訊息的時候再去偷看一下註釋的東西。</p><h1 id="Anki-的基本介紹"><a href="#Anki-的基本介紹" class="headerlink" title="Anki 的基本介紹"></a>Anki 的基本介紹</h1><p>剛開始碰 Anki 的阿宅都會搞不太懂牌組或卡片之類的關係，會覺得有點混亂。如果從軟體宅的角度來解釋，我會用資料庫的方式去解說</p><ul><li>整個 Anki 筆記就是一個資料庫<ul><li>不懂程式的人，可以想像是一個 Excel 檔案</li></ul></li><li>筆記類型(Note Type) 就是一個 Table<ul><li>可以想像是一個 Excel 檔案裡面有好幾個工作表(Sheet)，一個 Note Type 就是一個 Sheet</li></ul></li><li>筆記(Note) 就是 Table 裡面的一個 Row<ul><li>可以想像是某個 Sheet 裡面的某一筆資料</li></ul></li><li>卡片就是某一個 Row (筆記) Render 出來的結果，就像 Select 語句<ul><li><code>SELECT front_col, back_col, comment_col FROM MY_NOTE;</code> 產生第一堆卡片，正面顯示假名，背面顯示中文解釋與例句</li><li><code>SELECT back_col, front_col, comment_col FROM MY_NOTE;</code> 產生第二堆卡片，正面顯示中文解釋與例句，背面顯示假名</li><li>可以想像是把 Sheet 裡面的資料匯出成各種花俏的資料</li></ul></li><li>牌堆(Deck)就是前述 SELECT 出來的卡片，分組放到不同的地方<ul><li>可以想像是把匯出的花俏資料，放到不同的資料夾：「給上司看的」「呼嚨投資人的」</li></ul></li></ul><p>用資料庫的表格來看，大概會像這樣</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/tables.svg" class=""></div><ul><li>有兩個 Note type，一個叫 JP，一個叫 Eng</li><li>JP 裡面有三筆 Notes</li><li>Eng 裡面有兩筆 Notes</li></ul><p>實際上 Anki 裡面是怎麼儲存這些資料呢？我沒有去看源碼所以並不清楚。不過沒關係，真正搞懂原理才動手，這是舊時代骨灰程式設計師才會做的事情，身為後現代軟體宅，歷經各種 Scrum 的調教，我們明白 time to market 比什麼都重要。所有東西都可以視為黑盒子，只要 INPUT 對，OUTPUT 對，就可以上線出貨。為了可以趕快進到改介面那個階段，我們不用管 Anki 存資料的真正方式。</p><p>突破心魔之後，一切就海闊天空，要做的事情就變得很明確</p><ul><li>新增一個符合我們目標的 Note Type<ul><li>要有 Front</li><li>要有 Back</li><li>要有 Comment</li></ul></li><li>該 Note Type 要能夠針對每筆 Note 生出兩張卡片<ul><li>一張問你 假名 =&gt; 意思、例句</li><li>一張問你 意思、例句 =&gt; 假名</li></ul></li><li>針對卡片修改外觀<ul><li>Comment 預設隱藏，點一下才會顯示</li></ul></li><li>輸入 Note 新增需要背誦的資料<ul><li>其實可以用 CSV 檔匯入，但我懶得紀錄了</li></ul></li><li>Optional(可省略)：使用 Anki 背單字</li></ul><h1 id="開始自訂格式"><a href="#開始自訂格式" class="headerlink" title="開始自訂格式"></a>開始自訂格式</h1><h2 id="產生我們的-Note-Type"><a href="#產生我們的-Note-Type" class="headerlink" title="產生我們的 Note Type"></a>產生我們的 Note Type</h2><p>其實你也可以用現成的 Note Type，但是自己土砲一個是軟體宅基本美德，我們永遠都會嫌棄，看不上毫無個性的預設值。</p><ul><li>打開 Anki desktop 版</li><li>點上方的 Browse</li><li>從左邊的 side bar 找到 Note Type，按右鍵選 Manage Note Types</li><li>打開 Note Types 對話框之後，點 Add</li><li>在顯示的 Add Note Type 對話框裡面，先隨便選個基本的 Add: Basic，取名叫 <code>JP</code></li></ul><p>至此已經產生 Table，但是 Table 裡面的欄位不對，所以我們來修改一下</p><ul><li>在 Note Types 對話框點剛剛新增的 <code>JP</code>，然後選右邊的 Fields</li><li>在打開的 Field 對話框點 Add，新增一個欄位叫做 HiddenComment，於是就會有三個欄位<ul><li><code>Front</code> - 這是預設的</li><li><code>Back</code> - 這是預設的</li><li><code>HiddenComment</code> - 我們新增的</li></ul></li></ul><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_add_field.jpg" class=""></div><p>Save 之後就完成了這個階段</p><h2 id="針對-Note-生出兩張卡片"><a href="#針對-Note-生出兩張卡片" class="headerlink" title="針對 Note 生出兩張卡片"></a>針對 Note 生出兩張卡片</h2><ul><li>回到 Notes Type 對話框，選了 <code>JP</code> 之後點右邊的 <code>Cards</code> 按鈕，打開 Cards Types for JP 對話框</li><li>點右上方的 Options 選 Add Card Type，預設的名字是 Card2</li></ul><p>以後 <code>JP</code> 這個 Note Type 每新增一筆資料，就會根據 Card1 跟 Card2 定義的樣式生出兩張卡片了</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_add_type.jpg" class=""></div><p>截圖裡面兩張卡片的敘述看起來不是很好懂，它的格式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[順序]: [卡片類型名稱]: [正面卡片欄位] -&gt; [背面卡片欄位]</span><br></pre></td></tr></table></figure><p>改名字只能改到 <code>卡片類型名稱</code> 那一塊，剩下的都是自動產生的提示，正面跟背面卡片的欄位會由下一節的內容來決定</p><h2 id="針對卡片修改外觀"><a href="#針對卡片修改外觀" class="headerlink" title="針對卡片修改外觀"></a>針對卡片修改外觀</h2><p>重頭戲來了，展示我們軟體宅與眾不同的地方就是在這裡，首先我們先改 Card1 的外觀</p><ul><li>在 Card Types for JP 的對話框，在 Card Type 選 Card1</li><li>接著左邊 Template 是我們動工的地方，右邊 Preview 就是…Preview 啦！<ul><li>Front template - 卡片正面的版型，通常也就是提問的那一面</li><li>Back template - 卡片背面的版型，也就是回答的那一面</li><li>Style - 給你放超陽春 CSS 的地方，Template 跟 Style 分開來是基本起手式了</li></ul></li></ul><p>有寫過網頁的一看就知道這很像 mustache 之類的模板語言，在 front template 裡面填入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;front&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Front&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很簡單地把<code>Front</code> 欄位的內容放到 div 裡面，接著在 back template 裡面填入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Back&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hint-container&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;hint:HiddenComment&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&#123;&#123;hint:HiddenComment&#125;&#125;</code> 是 Anki 的特殊標記，告訴 Anki 要把 <code>HiddenComment</code> 這個欄位的內容視為 <code>Hint</code>，而 Hint 就會被 Anki 暫時隱藏起來，直到我們點下去才會顯示內容。接著輸入 Style</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.front</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.8rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.back</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hint</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hint-container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#AAA</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就完成了 Card1 的外觀修改，接著 Card Type 選 Card2，繼續改它的 Front template。這次我們調換順序，在正面顯示 <code>Back</code> 欄位的內容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;front&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Back&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Back Template 顯示 <code>Front</code> 欄位的內容，於是我們就能夠用同一個 Note，產生出不同方向的問法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;FrontSide&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">id</span>=<span class="string">answer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;Front&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hint-container&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;HiddenComment&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至於 Styles 的話，Card1 跟 Card2 都是共用同一個，所以不用再修改了。儲存之後就搞定這一切了</p><h2 id="編輯資料"><a href="#編輯資料" class="headerlink" title="編輯資料"></a>編輯資料</h2><p>前述的東西只要做一次就好，以後只要專心新增資料就好。有時候我們會被混淆，雖然介面上說的是「新增卡片」，但實際上你新增的是 Note。我猜應該是要對一般使用者講清楚 Note 跟 Card 的差別太麻煩，所以新增的時候只會跟你說「新增卡片」，實際上真正的操作是在「新增筆記(Note)」</p><p>也因此，你在卡片瀏覽器裏面，對某一張卡片點右鍵，怎樣都找不到「刪除卡片」的選項。因為 Card 是根據 Note 畫出來的結果，你真正要刪除的東西其實是 Note</p><div style="max-width: 100%;" class="img-row"><img src="/2022/09/01-anki/anki_toggle.jpg" class=""></div><p>在卡片瀏覽器的上方，可以透過 toggle widget(那個 N，原本是 C) 快速切換到 Note，這時候按右鍵就可以看見刪除的按鈕。正如我們前面的製作，讓一個 Note 可以生出兩張 Card，這邊刪除了一個 Note，理所當然會刪除對應的兩張 Card。</p><p>至於 Deck(牌組) 的部分，我覺得不用做太多。其實一個或兩個就很夠用了，畢竟學習的方法是要創一個單字池，持續地把生字丟進去，讓 Anki 根據時間撈出來給你複習，我們大家腦筋都不好，每天能背的就是那幾個。所以一個 Deck 就很夠用，除非要背單字以外的其他東西，才比較需要弄不同的 Deck。如果考試前要加強複習的話，目前的做法都是利用 Filter，創立一個暫時的 Deck，把單字卡都丟進去，考完試之後再把該 Filter 刪掉，這樣就不會影響原本 Deck 的進度。</p><p>以上就是對 Anki 的簡單介紹。身為軟體宅的你，現在已經能夠假裝自己對於 Anki 軟體本身有一定程度的熟悉，還能夠透過 CSV 檔一次匯入上千個單字，顯示出客製化過的幾千張卡片。別人只會用預設卡片老實地背單字，我們就能夠好好地炫耀：「看看我的 Anki 卡片，多美啊！」</p><p>工具調整得差不多之後，可以安心地把 Anki 關掉了。</p><div style="max-width: 500px;" class="img-row"><img src="/2022/09/01-anki/donotask.jpg" class=""></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;Anki 是相當知名的單字背誦軟體，但是製作卡片的方法不是很容易理解，本篇文章嘗試從軟體阿宅的角度做基本的介紹&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://jchu.cc/categories/life/"/>
    
    
    <category term="tools" scheme="https://jchu.cc/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>我的死刑議題立場</title>
    <link href="https://jchu.cc/2022/08/27-2022-08-26.html"/>
    <id>https://jchu.cc/2022/08/27-2022-08-26.html</id>
    <published>2022-08-26T15:00:06.000Z</published>
    <updated>2022-08-26T15:18:07.652Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有重大刑案，不免俗地死刑議題又再被提出來討論。我又不是意見領袖，當然談不上什麼倡議或說服。只是習慣性自言自語，紀錄當下我的看法，或許多年後會有不同的立場。</p><p>就結論來說，我的立場比較偏向廢除死刑。</p><span id="more"></span><p>開場不免俗要來個免責聲明。我並不認識任何廢死聯盟的人，我對他們做的事情只有很淺薄的了解，偶爾看到轉貼文章的那種程度。我所說的任何東西，僅僅只能代表我個人。</p><p>我的立場之所以傾向廢除死刑，取決於我對國家系統的理解，這份理解大致上可以歸納成幾項</p><ul><li>法律需要保留一定程度的彈性空間，實務上才能運作</li><li>審判系統永遠都有缺陷，也會產生失誤<ul><li>只要判死刑的人夠多，絕對會有少數的幾例屬於量刑過重</li></ul></li><li>過長的刑期或許可以藉由金錢給予當事人補償，但是死刑完全不可逆也無法對當事人補償</li></ul><p>以前跟朋友聊這個時，朋友曾說「那就把法律修成『罪證確鑿』者才判死刑」。但是這點是法律條文做不到的事情。</p><p>首先光是「證據確鑿」就是一個很難精確定義的事情。死刑不是開玩笑的，我相信所有的法官在判下死刑之前，在他心中衡量的那把尺，無疑認定嫌犯就是證據確鑿。甚至可以推論，只要不是存心貪污的法官，量刑的當下都是覺得符合他心中的道德正義。</p><p>其次，五個人看到 A 殺人，這樣算證據確鑿嗎？四個大人一個小孩呢？五個嗜好是霸凌人的小流氓呢？法律沒辦法用這種量化的數字來定義何謂證據確鑿。更別說現在各種科技持續進步，以往能夠被當成證據的錄音、影像，都可能隨著愈來愈強大的造假技術而變得難分真假。</p><p>當然，最近發生的殺警案，我們可以說這算是「證據確鑿」，我完全同意。但是法律該怎麼寫呢？難不成附註「當社會大眾一致同意，可視為證據確鑿」這樣嗎？不可能吧。</p><p>意思是說，沒有辦法寫出一個完美的敘述句，把現實生活中可能發生的各種兇殺案，區分成證據確鑿與尚有疑義兩大塊，這是其一。</p><p>法官也是人，也會有他的立場與偏見。樹大有枯枝，整個司法體系裡面總是會有一些位置坐很高，但是你深交後就只想搖頭的人，就算我們排除掉人的因素，客觀的證據也可能會因為科技的進步而有不同的解釋方法。又或著，隨著時間推移而出現翻盤的證據而影響判決。</p><p>一個必定會模糊的條文框架，以及無法完美精確的審判系統，就絕對會有量刑不精確的結果。</p><p>我說的量刑不精確，當然包括了應該要判更重刑的混蛋逃過一劫。</p><p>近幾年比較成人故事的遊戲，都喜歡描述世事難兩全的故事。現實生活也是這樣，有些光鮮亮麗的人私底下是混蛋，有些看起來可憐的人其實也是混蛋一個，許多糾紛其實就是混蛋跟混蛋在吵架，但是我們沒辦法分辨究竟是哪個混蛋該被打屁股，於是只能夠訂出一個不偏頗的規則，然後我們遵循這個規則讓社會運作。我們希望正義被實現，但我們只能透過公平的規則去趨近多數人認同的正義，但我們只能趨近而無法到達。</p><p>(所以正義女神之所以蒙著眼，就因為世人多是混蛋，看不出來哪個比較好啊！)</p><p>換個方向，那些窮凶惡極的重大刑犯該死嗎？我也希望這些人可以死一死，並非為了希望受害家屬被安慰，是我單純就看到混蛋死了覺得感覺很痛快，我承認自己不過是個容易憤怒的鄉民。沒有信仰的我缺乏宗教大愛，覺得受害者家屬從來都沒必要原諒什麼。看到嫌犯上香被家屬追打的畫面，我只會冷笑一聲活該。</p><p>只是談到死刑時，我會忍不住想到整個系統的缺陷，以及跑得夠久就遲早會扔出的 Exception。對於絕大多數泯滅人性的傢伙我沒什麼憐憫，但只要想到上千人裡面可能會有一個罪不致死的混蛋，我就會猶豫拿掉死刑能不能是個選項？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近又有重大刑案，不免俗地死刑議題又再被提出來討論。我又不是意見領袖，當然談不上什麼倡議或說服。只是習慣性自言自語，紀錄當下我的看法，或許多年後會有不同的立場。&lt;/p&gt;
&lt;p&gt;就結論來說，我的立場比較偏向廢除死刑。&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
  </entry>
  
  <entry>
    <title>Android 的 View.canScrollVertically 的誤讀</title>
    <link href="https://jchu.cc/2022/08/24-android_scroll.html"/>
    <id>https://jchu.cc/2022/08/24-android_scroll.html</id>
    <published>2022-08-24T13:54:19.000Z</published>
    <updated>2022-08-28T06:41:17.686Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 官方文件裡面有個 <code>View.canScrollVertically</code>，起初我認為這個 API 文件寫錯了，後來再看了更多文件，才覺得是我的誤會。</p><span id="more"></span><p>官方文件是這麼寫的</p><blockquote><p>public boolean canScrollVertically (int direction)</p><p>Check if this view can be scrolled vertically in a certain direction.<br>direction: Negative to check scrolling up, positive to check scrolling down.</p></blockquote><p>如果傳入小於零的值，而 View 可以往上 Scroll 的時候，<code>View.canScrollVertically(-1)</code> 會回傳 <code>true</code>。</p><p>看起來很簡單，但是當我們實際去測試，明明「手指還能往上滑」的時候，這個 API 竟然會回傳 <code>false</code>，怎麼跟觀察到的結果不一樣？是不是文件剛好寫反了？</p><p>其實這個 scroll 並非「手指往上 scroll」，而是「視窗/Viewport 往上 scroll」，因此我們要區分 Scroll 跟 Drag 的差別。</p><div style="max-width: 60%;" class="img-row"><img src="/2022/08/24-android_scroll/gesture.png" class=""></div><p><strong>Scroll</strong> 的概念是來自於滑鼠的時代，我們把滑鼠滾輪往上滾，就是 <strong>Scroll up</strong>，也就是把 Viewport 往上方移動，但是在 Touch panel 的時代，<strong>Drag down</strong>(往下拖動) 會有同樣的效果。</p><p>網頁 JS 裡面的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo">window.scrollTo</a>，也是同樣的效果，傳入座標後，實際上就是把 <code>Viewport 的 (left, top)</code> 移動到給定的 <code>(x, y)</code></p><p><strong>Scroll 是在移動 Viewport/Window</strong></p><p>這樣去思考的話，回頭看 Android API 就會得到相同的答案了。</p><p>前一陣子在寫內部的文件時，我也一直常被混淆：「大家都在講 scroll，到底是 scroll 什麼」。太常在手機上面開發的人，很容易就把 Scroll-up 想像成「手指按著螢幕，由下往上滑」，如果團隊裡面沒有把這件事情講清楚，Web deverloper 跟 Mobile app developer 很容易就雞同鴨講。</p><p>嚴格說起來沒有受詞的 drag 也是曖昧不明，譬如說 Drag-down 究竟是把 View 往下拖動，還是透過 Drag 的動作把畫面移動到底下呢？</p><p>至少我自己寫文件的時候會盡量遵循這樣的規則</p><ul><li>scroll 的作用對象都是 Viewport，scroll up 就是把 view port 往上方移動</li><li>drag 是手指在螢幕上的拖動方向，drag down 就是手指按著螢幕，往下滑</li></ul><p>Update:</p><p>官方的 <a href="https://developer.android.com/develop/ui/views/touch-and-input/gestures/scroll">Animate a scroll gesture</a> 也有提到這部分</p><blockquote><p>“Scrolling” is a word that can take on different meanings in Android, depending on the context.<br>Scrolling is the general process of moving the viewport (that is, the ‘window’ of content you’re looking at)</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android 官方文件裡面有個 &lt;code&gt;View.canScrollVertically&lt;/code&gt;，起初我認為這個 API 文件寫錯了，後來再看了更多文件，才覺得是我的誤會。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Overlord - Escape from Nazrick</title>
    <link href="https://jchu.cc/2022/06/25-escape_from_nazarick.html"/>
    <id>https://jchu.cc/2022/06/25-escape_from_nazarick.html</id>
    <published>2022-06-24T19:25:29.000Z</published>
    <updated>2022-08-24T12:52:03.876Z</updated>
    
    <content type="html"><![CDATA[<p>I just finished the game, Overlord Escape from Nazarick. I was playing the SWITCH version, and I would like to make some notes.</p><span id="more"></span><p>The first thing is the map. This is the map I drawed manually, it is svg file with CC0 license.</p><div style="max-width: 100%;" class="img-row"><img src="/2022/06/25-escape_from_nazarick/overlord-escape_from_nazarick-map.svg" class=""></div><p>If you want the map without grid lines: <a href="/2022/06/25-escape_from_nazarick/overlord-escape_from_nazarick-map-no_lines.svg" title="overlord-escape_from_nazarick-map-no_lines.svg">overlord-escape_from_nazarick-map-no_lines.svg</a></p><p>TODO: add location for all memory fragments.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;I just finished the game, Overlord Escape from Nazarick. I was playing the SWITCH version, and I would like to make some notes.&lt;/p&gt;</summary>
    
    
    
    <category term="acg" scheme="https://jchu.cc/categories/acg/"/>
    
    
    <category term="game" scheme="https://jchu.cc/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>GnuPG 基本觀念與指令介紹</title>
    <link href="https://jchu.cc/2022/05/17-gnupg.html"/>
    <id>https://jchu.cc/2022/05/17-gnupg.html</id>
    <published>2022-05-16T16:25:27.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>GnuPG 應該是絕大多數 Linux user 或是開發者都用過的工具。說起來真不好意思，十多年前剛開始工作的時候就用過它，懵懵懂懂查了幾個常見指令就擺著不放。現在終於振作起來，稍微多花點時間，重新認識這個工具</p><span id="more"></span><p>看完文件之後覺得最後的結論很簡單，但是使用前要弄清楚的一些基本觀念四散在不同的文件，而且 gpg 的指令介面也不是很友善，使得一開始的門檻弄得有點高。我試著整理出我覺得比較容易理解的順序</p><h1 id="Gpg-使用層的基本邏輯"><a href="#Gpg-使用層的基本邏輯" class="headerlink" title="Gpg 使用層的基本邏輯"></a>Gpg 使用層的基本邏輯</h1><p>眾所皆知，Gpg 是用來做加密、簽章等等功能的工具，從使用的角度來看，我們可以這麼理解它的邏輯</p><ul><li>抽象概念上，Gpg 是以「人的身份」為主體來互動</li><li>一個人可能有不同的身份，譬如說工作上的名字叫 Julian，在社群裡面互動又叫 Walkingice</li><li>你可以把這些身份跟你本人合併起來，也可以創造出一個全新的身份，達到匿名的效果</li><li>彼此簽章的時候，實際上是在做「這個人宣稱這個身份為他所有，我也同意這個說法」</li><li>每一個身份就是由一份 Primary Key pair 與數個 Uid 組合而成</li><li>每一個 Primary Key pair 底下可以掛許多個 subkey</li></ul><p>畫成圖例就有點像這樣</p><div style="max-width: 100%;" class="img-row"><img src="/2022/05/17-gnupg/gpg.svg" class=""></div><p>舉例來說，我身為一位中年大叔</p><ul><li>我可以生出一組 Primary Key pair，用來當作我在社會活動的身份<ul><li>從工作開始認識我的朋友，習慣叫我 Julian<ul><li>所以我可以在這個 Primary Key pair 底下創造一個 uid 為 <code>Julian</code></li></ul></li><li>從社群開始認識我的朋友，習慣叫我走冰<ul><li>所以我可以在這個 Primary Key pair 底下創造一個 uid 為 <code>Walkingice</code></li></ul></li><li>兩邊的朋友都知道叫我 Julian 或是 Walkingice，不管用哪個稱謂都沒問題</li><li>任何一邊的朋友，簽章認證我這份 Primary Key pair，是在認同我這個身份<ul><li>換句話說：「我同意這個 Primary Key pair 的所有人是 Julian，也就是 Walkingice」</li></ul></li></ul></li><li>但是我可能在大家不知道的地方，其實是個有變裝癖，並以此賺取斗內為生的肥宅，而這個身份我不想給任何親友知道<ul><li>所以我會生出另外一組 Primary Key pair，用來當作我在賺皮肉錢的身份<ul><li>在這個 Primary key 底下，我可以創造一個 uid 為 <code>FatTuber</code></li><li>簽章認證我這個身份的人，實際上是說：「我同意這個 Primary Key pair 的所有人是 FatTuber」</li></ul></li></ul></li></ul><p>所以我們可以看到幾個特點</p><ul><li>每個人可以創造出不同的身份，各個身份擁有的網絡是獨立的</li><li>每個身份要不要跟你的社會關係做連結，由你決定。</li><li>簽章認證並不表示「這個人真的是那個身份」，充其量只能說「這群人同意他所宣稱的身份」<ul><li>譬如說我也可以宣稱我是 <code>Tony Stark&lt;tony@avenger.universe</code>，而且我身邊一堆人還真的簽章同意，但我很明顯不是</li><li>Gpg 運作的邏輯就像一般社會一樣，所以你要慎選你的朋友，也要仔細斟酌你朋友說的話</li></ul></li></ul><p>使用 Gpg 就像在真實社會裡面運作一樣，你要重視自己某個身份的 reputation，並且好好經營它，才能夠在這個分散式的架構裡面作到身份的認證。</p><h1 id="Gpg-裡面常見的名詞解釋"><a href="#Gpg-裡面常見的名詞解釋" class="headerlink" title="Gpg 裡面常見的名詞解釋"></a>Gpg 裡面常見的名詞解釋</h1><ul><li><p>Key pair</p><ul><li>public key 跟 private key 的組合</li></ul></li><li><p>Primary Key pair / Master Key pair</p><ul><li>一份人際網絡關係就由一份 Primary Key pair 來管理</li><li>大多數情況都只要一份 Primary Key pair 就好，你的個人聲望都會累積在此</li><li>Primary Key pair 的 private key 相當重要</li></ul></li><li><p>UID / User ID</p><ul><li>UTF-8 字串，由一個名字與 e-mail 組合而成，像是 <code>FooBar (Some comment) &lt;foobar@the.addr&gt;</code></li><li>在任何指令需要透過 UID 指定或是搜尋的時候，不用全部打完，通常用一部分也可以配對成功</li><li>每一組 Primary Key pair 底下可以有好幾個 UID<ul><li>你可能因為換工作而有不同的 mail address</li></ul></li></ul></li><li><p>Subkey pair</p><ul><li>因為 Primary key pair 很重要，需要好好藏起來。於是產生其他的 key pair 並且掛在 primary 底下，所以稱為 subkey pair</li><li>在一組 Primary key pair 之下，可以掛上許多不同的 subkey 去做各種簽章或加密的實際動作</li><li>Primary key pair 跟 subkey pair 的資訊安全強度相同 (如果產生的參數一樣)</li></ul></li><li><p>Key ID</p><ul><li>16 進位的字串，用來鑑別一個 Key</li><li>又稱 long key id</li><li>如果只抓最後一部分 16 個字元來看，這個字串就叫 <strong>fingerprint</strong></li><li>gpg 取最後 8 個字元來當 fingerprint，又稱 short key id</li></ul></li><li><p>KeyGrip</p><ul><li>用在 gpg 內部的東西，20 bytes 的 SHA1 字串</li><li>用處跟 fingerprint 有點像</li><li>與 protocol 獨立，是用 key 的公開資訊算出</li></ul></li><li><p>Signing, Certification, Authentication, Encryption</p><ul><li>Signing: 用 keypair 對某一份資料簽名，讓其他人能夠確認是否看到跟我一樣的資料</li><li>Certification: 對別人的一組 key 做 signing，就是 Certification / Certify<ul><li>只有 Primary private key 可以 certify 其他 key</li></ul></li><li>Authentication: 認證，就像常見的 ssh login</li><li>Encryption: 用 key 對資料作加密</li></ul></li></ul><h1 id="與查詢有關的指令"><a href="#與查詢有關的指令" class="headerlink" title="與查詢有關的指令"></a>與查詢有關的指令</h1><p>很多操作都需要用 id 去定位某個 key，所先介紹一下查詢的指令</p><ul><li>列出 Primary key pair 的 key id<ul><li><code>$ gpg -K</code></li><li>如果想看其他人的 pubkey，就用小寫 k <code>$ gpg -k</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gpg -K</span><br><span class="line">sec   ed25519 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">uid           [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid           [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">ssb   dsa2048 2022-05-12 [S]</span><br><span class="line">ssb   rsa2016 2022-05-12 [E] [expires: 2023-05-12]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面給的資訊少得可憐。既然我們經常要用到 subkey，那麼要用什麼指定 subkey？</p><ul><li>列出 subkey 的 fingerprint<ul><li><code>$ gpg -K --keyid-format long</code></li><li><code>$ gpg -K --with-subkey-fingerprint</code> 這個也行，列出比較長的 id</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyid-format long</span><br><span class="line">sec   ed25519/44269415E755ADA0 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">uid                 [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid                 [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056/2C4FAFA05BC34CC8 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">ssb   dsa2048/96679AF60453EA0B 2022-05-12 [S]</span><br><span class="line">ssb   rsa2016/8AD8E8D104841669 2022-05-12 [E] [expires: 2023-05-12]</span><br></pre></td></tr></table></figure><p>上面的範例，2022/05/12 就會過期的 RSA key 的 fingerprint 就是 <code>2C4FAFA05BC34CC8</code>，後面會經常用到 subkey fingerprint</p><ul><li>列出 keygrip<ul><li><code>$ gpg -K  --with-keygrip</code></li><li>應該是 Gpg 2.1 之後，private key 就會存在 <code>private-keys-v1.d/[KeyGrip].key</code>，所以要看 keygrip 才知道是對應那一把 private key</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --homedir=. -K  --with-keygrip</span><br><span class="line">/home/walkingice/temp/gpg/pubring.kbx</span><br><span class="line">-------------------------------------</span><br><span class="line">sec   ed25519 2022-05-12 [SC]</span><br><span class="line">      A12DA4269CD15837F1D1DFF844269415E755ADA0</span><br><span class="line">      Keygrip = 9636425F6158C1C242C52C79AFF07DB2A76637C8</span><br><span class="line">uid           [ultimate] Foobar (Primary Key for testing GPG) &lt;foobar@testing.gpg&gt;</span><br><span class="line">uid           [ultimate] SecondUid (third) &lt;second@outerspace&gt;</span><br><span class="line">ssb   rsa1056 2022-05-12 [S] [expires: 2022-08-20]</span><br><span class="line">      Keygrip = 80ACB61CD079B38A4FBE6B9511BAD1FF90CD1D10</span><br><span class="line">ssb   dsa2048 2022-05-12 [S]</span><br><span class="line">      Keygrip = 0E3D334598E9A2A46450F52035A30348D85776A1</span><br><span class="line">ssb   rsa2016 2022-05-12 [E] [expires: 2023-05-12]</span><br><span class="line">      Keygrip = E7B8746A7A51D69486938458A9B3C68E105791C3</span><br></pre></td></tr></table></figure><h1 id="管理-Primary-key-與-Subkey"><a href="#管理-Primary-key-與-Subkey" class="headerlink" title="管理 Primary key 與 Subkey"></a>管理 Primary key 與 Subkey</h1><p>網路上其他地方已經很多教學了，我這邊只大概列出常用到的指令當作備忘</p><ul><li><p>新增 primary key pair</p><ul><li><code>$ gpg --gen-key</code></li><li><code>$ gpg --expert --full-gen-key</code> 用更專家的模式來產生 key</li></ul></li><li><p>刪除 primary key pair</p><ul><li><code>$ gpg --delete-secret-keys [UID]</code> 先刪除 private key</li><li><code>$ gpg --delete-keys [UID]</code> 接著刪除 public key</li></ul></li><li><p>編輯 subkey</p><ul><li>subkey 是掛在 primary key 底下，所以操作都是從「編輯 primary key」出發</li><li><code>$ gpg --edit-key [UID]</code> - 編輯這個 UID 所關聯的 primary key<ul><li><code>gpg --expert --edit-key [UID]</code> - 用專家模式可以有更多操作選項</li></ul></li><li>新增<ul><li><code>gpg&gt; addkey</code></li></ul></li><li>刪除<ul><li><code>gpg&gt; key [SUBKEY fingerprint]</code> - 特別指定要對這個 subkey 操作</li><li><code>gpg&gt; delkey</code></li></ul></li><li>撤銷/Revoke key<ul><li><code>gpg&gt; key [SUBKEY fingerprint]</code> - 特別指定要對這個 subkey 操作</li><li><code>gpg&gt; revkey</code> - revoke 之後記得要重新 export public key 告知其他人</li></ul></li></ul></li><li><p>匯出並刪除 primary private key</p><ul><li>匯出 primary private key 到檔案 <code>primary_private_key.gog</code> 並且拿到別的地方好好保存</li><li><code>$ gpg -o primary_private_key.gpg --armor --export-secret-keys [KEY_ID]</code></li><li>備份完備，接著在 gpg 管轄範圍內刪除 primary private key</li><li><code>$ rm private-keys-v1.d/[Primary KeyGrip]</code> - v2.1 之後直接砍掉檔案就行了</li><li>確認一下，打 <code>$ gpg -K</code> 會看到 private key 前面的 <code>sec</code> 變成 <code>sec#</code></li></ul></li><li><p>匯出 subkey private key</p><ul><li>如果你想要備份 subkey 的 private key，匯出的方式會有點不同</li><li><code>$ gpg -o sub_prikeys.gpg --armor --export-secret-subkey [KEY_ID]</code> - 匯出所有的 subkey private keys</li><li><code>$ gpg -o sub_prikeys.gpg --armor --export-secret-subkey [SUBKEY_FINGERPRINT]!</code> - 只匯出某一把 subkey private key，注意那個驚嘆號</li></ul></li><li><p>匯入 primary private key</p><ul><li>需要把 primary private key 找回來的時候，把之前匯出的檔案重新匯入即可</li><li><code>$ gpg --import primary_private_key.gpg</code></li></ul></li></ul><p>為什麼要麻煩地把 primary private key 藏起來？</p><p>這把 key 可能擁有你經年累月所累積的聲望，用這把 key 簽署過幾百人，也可能跟幾百人都交換過。如果哪天要出差去高風險的地方，電腦可能會遭竊或是被破壞，我們不會希望這把私鑰就這樣毀於一旦。利用 subkey 的機制，可以把 primary key 在大多數情況都藏起來，主要使用 subkey 來加密或是簽名。即使 subkey 遺失或是被竊盜，還能夠請出最權威的 primary 來宣稱某把 subkey 已經失效</p><p><a href="https://wiki.debian.org/Subkeys">Debian 這篇 Subkeys</a> 解釋了原因，並且列出哪些情況才會需要用到 primary private key</p><ul><li>你要簽署認同別人的 key，或是要撤銷手上的某個 key<ul><li>when you sign someone else’s key or revoke an existing signature,</li><li>when you revoke or generate a revocation certificate for the complete key</li></ul></li><li>你要編輯 UID<ul><li>when you add a new UID or mark an existing UID as primary,</li><li>when you change the preferences (e.g., with setpref) on a UID,</li></ul></li><li>你需要編輯 subkey<ul><li>when you create a new subkey,</li><li>when you revoke an existing UID or subkey,</li><li>when you change the expiration date on your primary key or any of its subkey, or</li></ul></li></ul><p>所以建構 key 的流程會有這種方式</p><ol><li>產生一組 primary key pair<ul><li>因為不會直接拿它做檔案加密所以不用擔心效率，選定最難的加密演算法，長度用到最大</li></ul></li><li>產生幾組專門拿來加密或是簽名的 subkey</li><li>匯出 primary private key 將其好好保存</li><li>刪掉 gpg 裡面的 primary private key</li><li>使用 subkey 做常見的工作</li><li>需要用到 primary private key 的時候，才暫時將其匯入，用完再刪掉</li></ol><h1 id="跟別人交換-key"><a href="#跟別人交換-key" class="headerlink" title="跟別人交換 key"></a>跟別人交換 key</h1><p>用 gpg 終究不會是自己一個人玩，總是要跟別人交流。所以雙方會交換 pubkey 放到自己的 gpg database 裡面</p><ul><li><p>匯出自己的 pubkey</p><ul><li><code>$ gpg --output my-pubkey.gpg --export [UID]</code> - 匯出所有的 pubkeys</li><li><code>$ --output my-single-pubkey.gpg --export [SUBKEY_FINGERPRINT]!</code> - 只匯出某個 subkey 的 pubkey</li></ul></li><li><p>匯入別人的 pubkey</p><ul><li><code>$ gpg --import friend_pubkey.gpg</code></li></ul></li></ul><p>單單把別人的 pubkey 放進自己的 database 還不夠，還需要用我們自己的人格去保證這把 pubkey 是不是真的由某個認識的人發出</p><ul><li>確認匯入的 pubkey<ul><li><code>$ gpg -k</code> 確認一下「朋友」的 pubkey 已經放進去，假設「朋友」的名字是 <code>the_friend</code></li><li><code>$ gpg --edit-key the_friend</code> - 開始編輯「朋友」的 key</li><li><code>gpg&gt; fpr</code> - 確認一下「朋友」的 fingerprint 對不對</li><li><code>gpg&gt; uid friend_the_one</code> - 「朋友」有很多 UID，我想針對 <code>friend_the_one</code> 這個 UID 做簽名</li><li><code>gpg&gt; sign</code> - 進行簽名認證，或是用 <code>lsign</code> 只在 local 端簽名。確認這份 pubkey 就是由「朋友」所擁有</li><li><code>gpg&gt; save</code></li></ul></li></ul><p>如果你需要親自跟每個 gpg user 見面，確認對方的身份之後才簽名認證，長久下來效率低落。可以利用透過其他人認證過的結果來簡化流程。譬如說有個叫 Kenji 的人做事總是不仔細，所以他認證過的人我都不願意相信。但是我完全無條件相信「朋友」所認證的任何人，所以我可以針對 Kenji 跟「朋友」設定不同的 trust 程度</p><ul><li>修改 trust<ul><li><code>$ gpg --edit-key the_friend</code></li><li><code>gpg&gt; trust</code></li><li><code>gpg&gt; save</code></li></ul></li></ul><p>但是時間久了，要怎麼知道我們所設定的 trust 程度呢？edit key 的時候就能看見</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub  rsa3072/58C7791869454109</span><br><span class="line">     created: 2022-05-12  expires: 2024-05-11  usage: SC</span><br><span class="line">     trust: ultimate      validity: ultimate</span><br></pre></td></tr></table></figure><p>上方的例子，trsut 的程度就是 <code>ultimate</code>，「朋友」的話就是對的！👆</p><p>交換 public key 如果全部都要用 e-mail 之類的方法傳遞，那就太累人了。通常就會找一個 keyserver，大家把 public key 傳上去，或從那邊抓下某個人的 public key，確認無誤之後再 sign。又或著，你對自己的 key 做出什麼變更，也可以傳上 server。別人就能從這個 server 抓下你的更新</p><ul><li>送出 public key 到 server<ul><li><code>$ gpg --send-keys [KEY_ID]</code> - 送出這一組的 public key<ul><li>但有時候會遇到 <code>gpg: keyserver send failed: Server indicated a failure</code> ，那可能就是你指定的 keyserver 掛了。</li><li>ubuntu 的 key server 好像也滿常用到</li><li><code>$ gpg --keyserver keyserver.ubuntu.com --send-keys [KEY_ID]</code> - 送出這一組的 public key 到 ubuntu key server</li><li>如果你想以後都用 ubuntu 的 key server，可以在 <code>~/.gnupg/gpg.conf</code> 裡面加上 <code>keyserver hkp://keyserver.ubuntu.com</code></li></ul></li></ul></li><li>從 server 下載 public key<ul><li><code>$ gpg --recv-keys [KEY_ID]</code></li></ul></li></ul><h1 id="加密、解密與簽名"><a href="#加密、解密與簽名" class="headerlink" title="加密、解密與簽名"></a>加密、解密與簽名</h1><p>前面千辛萬苦終於把 keys 都搞定了，現在開始真正使用 gpg 來做正事</p><ul><li><p>針對某個文字檔案做簽名</p><ul><li>產生一個新的可讀文字檔案，把原檔的東西放進去，同時也把簽章的資訊放進去</li><li><code>$ gpg --clear-sign [Filename]</code> - 不影響原檔案，額外產生 <code>[Filename].asc</code></li><li><code>$ gpg -u [SUBKEY_FINGERPRINT]! --clear-sign [Filename]</code> - 如果有多個 subkey，使用驚嘆號指定某個 subkey 來 sign，<ul><li>也可以在 <code>gpg.conf</code> 裡面寫上 <code>default-key [SUBKEY_FINGERPRINT]!</code> 當作預設使用的 subkey</li></ul></li><li>驗證簽名<ul><li><code>$ gpg --verify [Filename].asc</code></li></ul></li></ul></li><li><p>僅僅只產生一個額外的簽章資訊</p><ul><li>對方收到檔案之後，再根據這個簽章的資訊驗證檔案是不是真的來自你</li><li><code>$ gpg --sign --detach-sign [Filename]</code>   產生 <code>[Filename].sig</code>，把簽名跟檔案本體分開來</li><li>驗證簽名<ul><li><code>$ gpg --verify [Filename].sig [Filename]</code></li></ul></li></ul></li><li><p>對稱式加解密</p><ul><li>就是一般常見的用密碼加密，其實要用這招的話，也不需要搞一堆 key 了</li><li><code>$ gpg -c [Filename]</code></li><li>或是 <code>$ gpg --symmetric [Filename]</code></li><li>會產生 <code>[Filename].gpg</code></li></ul></li><li><p>用對方的 public key 加密</p><ul><li><code>$ gpg --encrypt -r [UID] [Filename]</code> - 指定 recipient 為 UID，會產生加密檔案 <code>[Filename].gpg</code></li><li>如果對方有很多把 subkey，想要用其中一把 subkey 加密</li><li><code>$ gpg --encrypt -r [Recipient&#39;s Public Subkey Fingerprint]! [Filename]</code> - 注意 subkey 後面有個驚嘆號，驚嘆號就是用來指定 fingerprint</li></ul></li><li><p>用自己的 private key 加密，讓對方可以用我的 public key 解密</p><ul><li>其實，這就是對這個檔案做簽章，並且不要把簽章的資訊額外放到別的檔案</li><li><code>$ gpg --sign [Filename]</code></li></ul></li><li><p>如果手上有對方的 pubkey，不想要把對方的 pubkey 加到 database 裡面，也能用 pubkey 檔案來加密</p><ul><li><code>gpg --encrypt -f [Recipient PubKey Filename] [Filename]</code><ul><li>如果這個檔案包了好幾個 pubkey，那麼 gpg 應該會用最新的那個</li><li>所以對方最好是只給一個 pubkey</li></ul></li></ul></li></ul><h1 id="檔案管理與備份"><a href="#檔案管理與備份" class="headerlink" title="檔案管理與備份"></a>檔案管理與備份</h1><p>除了使用 gpg，妥善地管理檔案以及備份也很重要。不過我個人比較懶惰，通常是直接備份整個工作目錄，比較挑惕的人可以稍微理解一下目錄底下哪些檔案是做什麼的</p><p>gpg 的預設工作目錄是 <code>~/.gnupg</code>，也能由 <code>--homedir</code> 或是環境變數 <code>GNUPGHOME</code> 來指定其他地方為工作目錄。我在讀文件的時候，就是用 <code>--homedir</code> 來練習。不過要注意，gpg 會跑起一個 daemon <code>gpg-agent</code>，它會暫存一些資訊，譬如說輸入的 passphrase，有時候需要砍掉這個 daemon 清光 cache。</p><p>在 2.1 之後就不用 <code>secring.gpg</code> 這個檔案了。分開維護 public keyring 跟 private keyring 常常會引起問題，所以在 gpg 2.1 之後，全部把工作都交給了 gpg-agent (真正的 encryption engine)來做</p><ul><li><code>pubring.kbx</code><ul><li><strong>需要備份</strong></li><li>public key box</li><li>v2.1 之後新增的 <a href="https://www.gnupg.org/faq/whats-new-in-2.1.html#nosecring">https://www.gnupg.org/faq/whats-new-in-2.1.html#nosecring</a></li><li>給 <code>gpgsm</code> 共享使用。(<code>man gpgsm</code>)，所以這個檔案可能在早就被產生了</li></ul></li><li><code>openpgp-revocs.d</code><ul><li><strong>需要備份</strong></li><li>裡面的東西可以用來 revoke 正在使用的 key，所以最好分開存放，或是印出來收藏</li></ul></li><li><code>private-keys-v1.d</code><ul><li><strong>需要備份</strong></li><li><code>gpg-agent</code> 會把 private key 存在這裡面</li></ul></li><li><code>trustdb.gpg</code><ul><li>不需要備份</li><li>trust database</li><li>真的要備份，會用 <code>--export-ownertrust</code> 匯出檔案</li></ul></li></ul><h1 id="後話閒談"><a href="#後話閒談" class="headerlink" title="後話閒談"></a>後話閒談</h1><p>前一陣子在想，數位資產的所有權(暫且先不管「所有權」的嚴格定義)認證目前都是綁定在網站的帳號之上，可是我們註冊帳號的時候往往要提供一個 e-mail，這年頭許多人(包括我)都是直接用 gmail。如果我的 gmail 帳號因為任何原因而被停權，也代表我有風險失去在某個網站上面的數位資產。如果我想要自己架 mail server 給自己發 e-mail 帳號，實際上我的 domain name 也是被某個網路巨頭所掌控。如果想要證明登入的人真的是「我」，似乎都要被某個網路巨頭箝制？</p><p>「如何在網路上證明自己的身份，而不倚靠大公司的服務？這不就是 GnuPG？！」是啊，這個問題早就有個解法了。</p><p>最近幾年大家對「網路巨頭」很不信任，不過我身為這個行業裡面的一員，雖然有點提防但也沒有到很緊繃的程度，對於民主國家裡面比較有聲譽的大公司，其實我還是有一定程度的信任，也因此我對「完全去中心化」這種目標並不是很有興趣。</p><p>即便如此，我還是強烈同意並主張，<strong>人們應該要有個可以驗證自己的方法，不受大公司的限制</strong></p><p>用 gpg 的例子來說，就是我可以用 gpg subkey 來註冊帳號，而非使用 e-mail。註冊帳號只是例子，其實泛指的是任何需要 authenticate 的事情。這只是個理想，而現實的其中一個關卡就是，gpg 真的很難用。</p><p>Gpg 指令難用之一在於，它會故作聰明地幫你找一堆 fallback，經常你搞錯 keyid 或是 fingerprint，忘記加上驚嘆號都會動，或著在 conf 裡面設定錯誤的 default-key，這些弄錯都還是會動，但是結果跟你預期的不大一樣。從大學就喜歡用 Linux command line 的我，依然覺得 gpg 的指令很反人類。它的功能很完整，熟悉的人可以很好地使用它。但是在那之前，gpg 混亂的文件說明與複雜的指令，沒有強大耐心的人應該都沒動力弄懂 gpg，多半就只有拿來 gen key 而已。</p><h1 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h1><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc4880">RFC4880: OpenPgp Message Format</a></li><li><a href="https://davesteele.github.io/gpg/2014/09/20/anatomy-of-a-gpg-key/">Anatomy of a GPG Key</a></li><li><a href="http://jedi.org/blog/archives/gpg_party_zh_tw.html">中文：GnuPG Keysigning Party HOWTO</a></li><li><a href="https://zhuanlan.zhihu.com/p/481900853">知乎：使用 GPG Key 来构建签名、加密及认证体系</a></li><li><a href="https://zhuanlan.zhihu.com/p/24103240">知乎：关于GnuPG的subkey（子密钥）的使用</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;GnuPG 應該是絕大多數 Linux user 或是開發者都用過的工具。說起來真不好意思，十多年前剛開始工作的時候就用過它，懵懵懂懂查了幾個常見指令就擺著不放。現在終於振作起來，稍微多花點時間，重新認識這個工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="linux" scheme="https://jchu.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Social Network 是否可能有另外一種樣貌？</title>
    <link href="https://jchu.cc/2022/04/29-social-network.html"/>
    <id>https://jchu.cc/2022/04/29-social-network.html</id>
    <published>2022-04-28T16:38:09.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>隨手在 FB 寫了些對於最近鄉民從 Twitter 逃難到 Mastodon 的感想，竟然意外有不少朋友回應</p><p>雖然我一開始的本意，只是想要重述我在私下講過好多次的想法，想要提醒那些沒那麼熟悉科技工具的朋友，他們應該找個地方把他們的論述好好保存下來。結果卻演變成我對 Social Network 的看法，仔細再想一下，我也可以趁機好好整理一下我自己的想法，於是就打算來「認真寫一篇」</p><span id="more"></span><p>最近，超級有錢而且相當唱秋的 Elon Musk 似乎開著玩笑說要買下 Twitter，然後還真的出了 400 多億美金去買。這件事情有人喜歡，有人不喜歡，引發一波 Twitter 逃難潮，有些人最近開始使用 Mastodon</p><p>類似的逃難潮已經發生過好多次。前一陣子普羅大眾對「演算法」三個字很熟悉的時候，不少人決定「不要被 Facebook 的演算法操縱」，於是開了新的帳號。過了不久，這些帳號也都很少啟動。畢竟大多數人不是靠營銷維生，對於演算法的改變其實不敏感，也習慣。更重要的是，在那裡有更多的朋友，Social Network 就是要滿足社交嘛。</p><p>Social Network 就是這樣有力，毫無疑問。</p><p>從 Twitter 到 Mastodon 的搬家潮？除非 Twitter 真的做了什麼核心的改變，讓使用者覺得很難用，否則出走的人終究會回去習慣的地方。回去沒什麼不對，畢竟 Elon Musk 也還沒幹什麼事啊，搞不好他真的把 Twitter 弄得很有趣，活得很好。</p><p>新的 Social Network 平台崛起，舊的沒落，這已經發生過很多次。所以 FB / IG / Twitter 甚或是 Mastodon，我都覺得沒有太大的差別。Social Network 對於公共討論的影響，乃至於影響到整個政治與社會，幾年來已經有相當多的探討與觀點。</p><h1 id="Social-Network-對網路環境的影響"><a href="#Social-Network-對網路環境的影響" class="headerlink" title="Social Network 對網路環境的影響"></a>Social Network 對網路環境的影響</h1><p>社群平台的轉移風潮，理所當然地影響社會上的資訊傳遞方法。除了之外，還有一個我很在意的影響，這個影響是資訊界的人，尤其是 Web 1.0 或是部落格時代就開始參與網路的老骨頭都相當清楚的一件事：網路上累積的知識內容增長幅度不如預期</p><p>或著說，過去十多年來，各行各業的愈來愈多精英參與了網路，但是在網路上能搜尋到的優質文章並沒有蓬勃地增加。</p><p>又或著說，精英在 Social Network 把自己的知識轉化成群眾的短期支持，然後，僅止與此。這些原本被樂意分享的知識，並沒有累積到網路上，這是我覺得可惜的地方。</p><p>舉個例子來說，各個 Social Network 裡面有大大小小的社團，幾乎你有興趣的主體都找得到社團。但是，如果你拿相近的關鍵字在各個搜尋引擎來尋找，最終找到的結果不外乎是 Wiki、Blog、論壇(Reddit, BBS, Stackoverflow…)、新聞網站以及內容農場。極少的情況，你會看到來自 Social Network 的公開文章。</p><p>許多產出內容的人，他們樂意被看見嗎？我想是的。他們希望自己的文字能被更多人看見嗎？我想也是如此。但結果就是，你總是很難看見來自 Social Network 的搜尋結果。從技術的角度來看，我們可以挑惕搜尋引擎做得不夠好，老實說沒有實作過我也不敢講死責任全在 Social Network 不夠公開。我只能從結果來看，內容發布在 Social Network 裡面，多半就是紅個幾天接著消失在網路中。</p><p>當然，我這麼市儈的人，頭一個就是想到(廣義上)錢的問題，後面再談。</p><p>沒有辦法在網路累積知識，我將其視為「現象」而非「問題」，因為我也不確定累積愈來愈多免費的知識是不是好事(笑)，當然我個人是希望知識可以免費取得。這個現象的形成，是因為 Social Network 取代了 Blog。不幸的是，在我看來，這個取代又是必然發生的。</p><h1 id="前-Web-2-0-時代"><a href="#前-Web-2-0-時代" class="headerlink" title="前 Web 2.0 時代"></a>前 Web 2.0 時代</h1><p>稍微回顧網路的歷史。Web 1.0 那個時代，要產出內容你就要學會「架站」，還要學會寫烘培雞 (Home Page)。我還記得高中的電腦課，老師教我們用記事本寫簡單的 HTML，那個年代的 Web 真是簡單到不行。架站就沒那麼容易了，如果不找免費空間，就要有人提供「工作站」。那時候玩 MUD，有正在念大學的朋友說：「我幫你開個工作站的帳號」就覺得對方實在帥到不行。對國高中生而言「工作站」實在是一個高上大帥到爆炸的名詞 - 雖然我只會連上去開 tintin。(所以我大一裝完 Linux 第一次開機，看到一堆 Check OK 的文字時，真的感動到快流淚了，原來我也可以有帥到翻過來的機會)</p><p>後來進到 Web 2.0 的時代，也就是使用者產出內容的時代。從此開始，你不需要學會架站或 HTML，你就可以有個自己的天地來寫東西。對台灣人而言，大致上可以對比成無名小站當紅的時代</p><p>像我這種渾身汗臭味的大叔，會覺得那個時代真是美好啊。(打嗝) (大叔臭味更濃了)</p><p>每個人都有自己的「家」，不喜歡無名小站的，也可以開 Blogspot，或是像我們這種資工系的人就是要架個隨時會被打爆的機器證明自己的尊絕不凡。總之，每個人都有自己的空間，每個人都把自己的照片往那裡堆，每個人都把自己的心情往那裡寫。預設就是給所有人看，展現自己的風格 - 當然也有隱私的空間，但預設都是開放的。</p><p>不管是心儀的隔壁班對象，或是討厭的他校情敵，總之關鍵字丟對了，很多資訊都找得到。嗯，現在我這個年紀回想起來，這還真是恐怖啊 XD</p><p>每個人都預設別人會來看，而且是把自己家的所有東西認真看一遍。於是不少人都會認真經營自己的部落格，連帶地就會開始競爭產出的內容。</p><p>在那個時期，每個人在網路上的「家」都像是一個孤島，彼此之間透過 RSS 或是瀏覽器的 Bookmark 連結起來。雖然搬家很痛，會流失不少讀者，但是「搬家」是可能的。文章與照片是可以帶走的資產，許多程式可以讓 Blogger 轉換平台而不會損失太多文章。過往辛苦耕耘的東西都還在，讀者終究會回來。</p><p>直到 Social Network 的興起</p><h1 id="Social-Network-必然取代-Blog"><a href="#Social-Network-必然取代-Blog" class="headerlink" title="Social Network 必然取代 Blog"></a>Social Network 必然取代 Blog</h1><p>記得 Social Network 剛興起的時候，比較多人用的詞是 <strong>Micro Blog</strong> (微部落格)。當時我心想，原本部落格可以寫很長的文章，現在被限制到幾百字，這不是一種退化嗎？當時我不明白的是 1) 很多人本來就沒啥興趣看長文 (譬如本篇) 2) 重點是 social，不是 blog</p><p>Blog 剛開始流行的時候，大家都嘛隨便寫。蹺課被點名而超不爽可以寫一大篇，晚餐麻辣鍋很好吃但是拉肚子很痛苦，兩句話也能寫一篇。許多人寫 blog 只是想要在網路上社交，這個需求既然能被 social network 滿足，何必再寫 Blog？</p><p>Blog 時代也嘗試過加入社交的元素。譬如說文章留言，可以讓(孤島)島主跟路人互動的機會，或是 Pingback 機制，把不同網站的文章連結起來，又或是 Planet 把幾個 Blog 合併在一起變得更熱鬧，部落格會顯示每日參觀人數滿足人們被看見的渴望。但這些都不及 Social Network 來得直接，都不比 Social Network 刺激</p><p>在 Social Network 時代，大家都是真切地待在同一個島上。人們不再是島主，而是島民，產出都是最終貢獻給島，讓那個平台成為更豐饒的島。付出代價換回的是更直接刺激的即時回應：有多少人點了讚，有多少人轉貼</p><p>原本我就認為，所謂「值得紀錄的好文」不過是滿足社交需求這個主目的的副產品，既然 Social Network 可以滿足多數人的需求，那麼部落格的式微便是必然。</p><p>於是多數人從 Blog 轉換 Social Network 後，原本以產出文字維生的人，自然也是轉戰 Social Network。於是寫 Blog 的人，就只剩下不太需要靠文字維生，卻又刻意希望留下長久足跡的人。也因此，寫 Blog 更像是一個神聖而必須專注的工作，既然牢騷可以在 Social Network 獲得滿足，那麼 Blog 必須展現專業。</p><p>理論上來說，人多了就會產出優質的內容，實際上也是這樣，雖然 Twitter 或 FB 充滿各種牢騷或是讓人搖頭的意見，但是還是有很多精英分享真知灼見。但是在商業的考量下，Social Network 上面註定不會留下太多東西。對，還是因為錢的關係</p><h1 id="Social-Network-比較好賺錢"><a href="#Social-Network-比較好賺錢" class="headerlink" title="Social Network 比較好賺錢"></a>Social Network 比較好賺錢</h1><p>同樣都是靠廣告營利，Blog 的平台對於讀者的掌控力弱，對於內容產出者的控制力道也弱(寫手不爽就搬家了)。但是 Social Network 上面，賽制跟場地都是自己的，當然比 Blog 還要好賣廣告。更何況大多數的商品都有時效性，賣一段時間就可以了，快速迭代的 Social Network 比走長尾的 Blog 還要有用。</p><p>我已經是鼻子聞不到花香，只聞得到銅臭味的中年爸爸了，我非常清楚也認同錢的重要。</p><p>要開公司，當然要想辦法把所有的客人都鎖在自己家平台呀。</p><p>如果我當老闆，大家討論新產品的時候，有人跟我說他想做一個可以讓使用者輕易搬家的程式，我應該也會踹他兩腳再把他扔出窗外。大家想的是怎樣讓更多使用者黏在自家平台上，怎麼會有人降低搬家的門檻呢？</p><p>有人批評現在的 Social Network 大公司都在貪用網路的自由基石獲利而吝於分享。情感上我同意這種看法，但邏輯上我又覺得這難以避免。講難聽一點，我現在工作的項目，也是在利用公開的 HTTP 協定，傳送大多對人類智慧沒有幫助的資訊。既得利益者的我，領薪水的時候也是跪下來笑嘻嘻流口水捧著鈔票。</p><p>公司需要獲利，既然築起城牆可以讓公司更安全的獲利，那麼大家都築牆就太自然了。</p><p>也許適當地公開一些內容，可以為公司帶來更長遠的利益。但是這種不易證明獲利的功能，在優先權上很難贏過其他顯著有優勢的項目。要是有個工程師跟我說，他覺得整體網路的健康性比能賺錢影片廣告還要重要，希望平台的內容都很容易給網路爬蟲索引，我也會踹他兩腳：「你去幫我看看剛剛我丟下去的人死透了嗎？」然後也把他丟下去</p><p>好啦，以上是說笑。我心底是希望網路更健康，但是在公司要推動項目不能靠理想。靠理想的公司也不太容易活下來就是了。</p><h1 id="Blog-還有辦法存活嗎？"><a href="#Blog-還有辦法存活嗎？" class="headerlink" title="Blog 還有辦法存活嗎？"></a>Blog 還有辦法存活嗎？</h1><p>我覺得很難。</p><p>在台灣比較知名還存活的部落格平台，應該是 Pixnet 吧。打開 Pixnet 就看到廣告數量堪比祖國滿溢的愛，不由得覺得辛酸。Blogspot 雖然有個富爸爸，但是幾年下來沒什麼改變，多半也是靠爸才沒餓死。Wordpress 看起來活得不錯，但我的理解它不是靠 Blog 服務維生，而是提供許多小廠商架站的平台。(歡迎指正)</p><p>總之 Blog 的平台賺的錢少，但是養平台要錢，是筆難作的生意。</p><p>我的 Blog 目前是寄生在 Github page 上面，用 hexo 生出靜態網頁。哪天 Github page 收掉，我還能自己架個 web server 所以沒差。但是相對的寫文章的成本就很高，有時候我自己都覺得寫 Blog 好累，一年寫個幾篇就不錯了，正如我開頭所說，需要打起精神才能「認真寫一篇」，累啊</p><p>相較之下在 twitter / FB 發牢騷的字數多出百倍。如果寫 blog 變成一種需要刻意為之的選項，那麼它自然難以持續</p><h1 id="我總是期待-Social-Network-能夠留下些什麼"><a href="#我總是期待-Social-Network-能夠留下些什麼" class="headerlink" title="我總是期待 Social Network 能夠留下些什麼"></a>我總是期待 Social Network 能夠留下些什麼</h1><p>前面講了一大堆，是想闡述在我的理解之中，演變成今天這樣是很自然的。我擔心 Social Network 對民主的傷害，但我坦然接受 Social Network 取代 Blog 的事情。而且在我的感受裡，不管是 FB / Twitter / Tiktok / Mastodon 都沒什麼太大的差別，它們對網路環境的影響最終都會差不多，至少在我說的「累積」這一塊是相同的。</p><p>我只是有時候在想，有沒有哪個平台，會在陰錯陽差之下設計出更容易累積文章的功能？</p><p>寫 Blog 只是一種形式，我所在乎的是，那些在 Social Network 上面的優秀文章，能夠以更長久更公開的形式被保留下來。以 Facebook 為例，雖然說文章設定成公開地球，理論上就要能被 Google 搜尋到。但實際上就是鮮少搜尋得到。</p><p>譬如說聖騎士大仁哥，帳號掛著藍勾勾，發的文章都是開地球，他的公衛專業發出的文章值得一看，但你在 FB 以外的地方就是搜尋不到。這可能是 Google 不夠力，也可能是 FB 給搜尋引擎穿小鞋，總之就是看不到。</p><p>這件事情又回到目前 Social Network 的主流設計：你心裡明白你的產出最終不是放進你的收藏櫃，而是放上別人 timeline 架上的競爭品</p><p>這其中有個很微妙的落差。首先我們可以假設，累積的文章這麼少，是因為很多人寫文章本來就想過那麼遠，當下寫了大家看完就算了。但是如果針對那些想要被傳播的長文，一篇一篇問，希望不希望這篇文章能夠被更多人看見，被保存的更久？我想多數的回答是：「沒什麼不好」。</p><p>Social Network 不加分辨地，預設地把這些長文跟一般的社交文章用同樣的方式處理，以至於這些文章就隨著時間消失。</p><p>從技術的角度來看，解法倒也沒有太難。給這些擁有藍勾勾的人，一個類似 Blog 網站的個人頁面，姑且叫它展示櫃好了。一定長度的文章，在發布前就跳個選項問：「是否要放進展示櫃？」，然後同步複製過去就可以了。只要這些展示櫃同樣有 RSS 也能被爬蟲看到，那麼好文就容易被留下來。</p><p>這是我希望的，Social Network 能有的另外一個樣貌，跟現在差不多，只是有點不一樣。</p><p>只是，我想不到這對檯面上的 Social Network 大公司有什麼好處，這件事情沒發生，我也不怎麼意外。也許某些平台有類似的功能可以做到類似的事情，但我想這不會是 Social Network 公司覺得有價值的事情，自然也不會是被推崇的方向，UX 的設計更不會讓這件事情那麼容易作到。換句話說就是，做得到但是不會讓人想去做，因為沒必要</p><p>有另外一個取巧的作法，就是自己寫程式，把別人的文章轉貼出來到第三方的網站，做個自己的「公開收藏櫃」。技術上當然是可以，但是一來有授權的問題，二來 hosting 要錢，如果只能自己玩玩，那麼對於「累積好文」這個目標就沒什麼幫助。更重要的是，我覺得這種作法不健康，轉貼文章會稀釋原作者的帳號的價值，要看原作者的好文，還是要回到他的家/官方頁面去看，才能夠鼓勵原作者持續創作。</p><p>說到底，還是要靠 Social Network 平台自己去推動才有可能改變，但我自己是完全看不出來有什麼動力可以讓任一平台做這種事情。所以我自己是悲觀地認為，這是一個死局</p><p>以上，就是中年大叔的超長牢騷。黃金週結束前我大概都沒力氣寫其他東西了 (捅自己一刀)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;隨手在 FB 寫了些對於最近鄉民從 Twitter 逃難到 Mastodon 的感想，竟然意外有不少朋友回應&lt;/p&gt;
&lt;p&gt;雖然我一開始的本意，只是想要重述我在私下講過好多次的想法，想要提醒那些沒那麼熟悉科技工具的朋友，他們應該找個地方把他們的論述好好保存下來。結果卻演變成我對 Social Network 的看法，仔細再想一下，我也可以趁機好好整理一下我自己的想法，於是就打算來「認真寫一篇」&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
  </entry>
  
  <entry>
    <title>在本機上存取 Android 的 sqlite 檔案</title>
    <link href="https://jchu.cc/2022/04/17-sqlite.html"/>
    <id>https://jchu.cc/2022/04/17-sqlite.html</id>
    <published>2022-04-17T13:14:04.000Z</published>
    <updated>2022-06-24T18:24:36.850Z</updated>
    
    <content type="html"><![CDATA[<p>之前紀錄過一篇怎麼在 Android Studio 裡面用 SQLScout 的 Plugin 存取 sqlite database</p><p>其實用指令把 sqlite db 抓到本機端測試也一樣</p><span id="more"></span><p>先確保你安裝的是 debuggable app，假設 package 是 <code>foo.bar</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">$ run-as foo.bar</span><br><span class="line">$ <span class="built_in">cd</span> /data/data/foo.bar/database</span><br></pre></td></tr></table></figure><p>找 <code>db</code> 結尾的檔案就是 sqlte 的資料庫檔案了。如果你的資料庫名稱是 <code>my-db</code>，多半檔名就是 <code>MyDb.db</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp MyDb.db /sdcard</span><br></pre></td></tr></table></figure><p>接下來用 adb pull 就能抓下來了。知道路徑的話，可以用一行指令做完</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb exec-out run-as foo.bar cat /data/data/foo.bar/databases/MyDb.db &gt; backup.db</span><br></pre></td></tr></table></figure><p>以後用 sqlte3 的指令操作這個檔案就可以測試了，習慣指令操作的人，會覺得比起用 plugin 更有彈性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前紀錄過一篇怎麼在 Android Studio 裡面用 SQLScout 的 Plugin 存取 sqlite database&lt;/p&gt;
&lt;p&gt;其實用指令把 sqlite db 抓到本機端測試也一樣&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>kotlinx-coroutines-test migrate to 1.6 紀錄</title>
    <link href="https://jchu.cc/2022/03/30-coroutine-migration.html"/>
    <id>https://jchu.cc/2022/03/30-coroutine-migration.html</id>
    <published>2022-03-30T13:07:18.000Z</published>
    <updated>2022-04-01T16:46:25.178Z</updated>
    
    <content type="html"><![CDATA[<p>之前因為工作的需要，把 kotlin 從 <code>1.5.2</code> 升級到 <code>1.6.0</code>，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。</p><span id="more"></span><p>kotlin 升級到 1.6.0 的時候，有把許多元件標為 <code>Deprecated</code>。這在一般的小專案裡面不是什麼大問題，但我的公司有很多部門都會把程式送到同一個 repository 裡面，當然許多人都有寫 unit test 的習慣，而且我們也有打開 <strong>-Werror(Warning as Error)</strong> 的選項。於是必須在一個 PR 裡面，升級 coroutine 版本的同時，就把上百個 unit test 類別裡面的過時寫法一口氣更新。</p><p>這種改測試的任務，配分到各個跨國團隊底下，很容易大家就因為各自的時程壓力而搞到永遠作不完。跟同事討論之後，決定我跳下去動手改。除了改程式碼的苦工之外，還要跟不同的團隊合作避免把測試改壞，同時要保持 commit 的清晰才容易解決 merge conflict，追上最新的開發版。來來回回搞了一個月，終於送出一個增減超過五千行的巨大 PR，算是最近工作比較難忘的一件事。</p><p>這過程中也看到各種不同的使用 coroutine 的實作與單元測試寫法，我盡量把我記得的東西寫下來。</p><h1 id="關於升級-kotlinx-coroutine-1-6"><a href="#關於升級-kotlinx-coroutine-1-6" class="headerlink" title="關於升級 kotlinx coroutine 1.6"></a>關於升級 kotlinx coroutine 1.6</h1><p>首先要看官方的 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md">Migration Guide</a>，列了不少步驟以及細節。說實在我也是來來回回看了好多遍，才搞懂大部分的意思。需要作 migration 的人可以認真看一下，一方面也是搞懂如何用比較簡潔的方式寫 coroutine unit test</p><p>大致上有幾個重點，在寫 unit test 的時候</p><ol><li>不要用 <code>runBlocking</code> 或是 <code>runBlockingTest</code>，改用 <code>runTest</code></li><li>不要用 <code>TestCoroutineScope</code>，改用 <code>TestScope</code></li><li>不要用 <code>TestCoroutineDispatcher</code>，改用 <code>StandardTestDispatcher</code></li><li>如果實作同時用到其他非同步的工具，好比 RxJava，可以試 <code>UnconfinedTestDispatcher</code> 看看有無奇效</li><li>必要的時候用 <code>runCurrent</code> 確保 pending 的 coroutine 有跑完</li><li>用到 <code>ViewModel.viewModelScope</code> 的話，用 <code>Dispatchers.setMain</code> 把 dispatcher 塞進去</li><li>實作要是有用到 <code>delay</code>，可以用 <code>advanceTimeBy</code> 來控制時間進度</li></ol><p>掌握上面的幾個重點，應該就能處理絕大多數的測試。</p><h1 id="好處：使用一致的風格撰寫-coroutine-的測試"><a href="#好處：使用一致的風格撰寫-coroutine-的測試" class="headerlink" title="好處：使用一致的風格撰寫 coroutine 的測試"></a>好處：使用一致的風格撰寫 coroutine 的測試</h1><p>升級到 <code>1.6.0</code> 之後，我覺得寫 unit test 有比較簡潔一點，而且我把絕大多數的測試包進 <code>runTest</code> 之後，也不需要依賴 Mockito 提供的一些為了測試 coroutine 而增加的工具。整體來說能夠用比較一致的風格來寫單元測試，對於大團隊算是好事。</p><p>寫 coroutine unit test 的主要精神就是，產生一個 <code>TestDispatcher</code>，然後透過這個 <code>TestDispatcher</code> 生出 <code>TestScope</code>，然後注入這些測試專用的 Dispatcher 或是 Scope 到實作的程式裡面。因為這些測試用的物件提供了我們上下其手的空間，所以我們就能預期被測試的實作會如何被執行，以此來進行單元測試。</p><p>Coroutine 的測試最後大概都能寫成這樣，以下是我覺得不錯的風格。(當然一個測試檔案只應該測試一個對象，我一次塞進 <code>foo</code>, <code>bar</code>, <code>foobar</code>, <code>foobarViewModel</code> 只是為了節省空間)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.test.assertEquals</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.ExperimentalCoroutinesApi</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.StandardTestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestDispatcher</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.TestScope</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runCurrent</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.runTest</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.test.setMain</span><br><span class="line"><span class="keyword">import</span> org.junit.Before</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith</span><br><span class="line"><span class="keyword">import</span> org.robolectric.RobolectricTestRunner</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="meta">@RunWith(RobolectricTestRunner::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope) <span class="comment">// inject Scope to implementation Foo</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher) <span class="comment">// inject Dispatcher to implementation Bar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = foo.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">        <span class="keyword">val</span> returnedValue = bar.suspendableFunc()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        foobar.suspendableFunc()</span><br><span class="line"></span><br><span class="line">        runCurrent() <span class="comment">// ensure foobar completed its job</span></span><br><span class="line">        assertEquals(<span class="number">5987</span>, foobar.fetchedResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從上方的範例可以看到</p><ol><li>我用 <code>StandardTestDispatcher</code> 產生一個 <code>TestDispatcher</code></li><li>並且用 <code>TestDispatcher</code> 產生一個 <code>TestScope</code></li><li>這些 Dispatcher 跟 Scope 被注入進 <code>Foo</code>, <code>Bar</code>…等</li></ol><p>接著列出一些常見的例子，解釋該怎麼寫測試比較好。<strong>注意：下方範例裡面的類別，即使同名，介面可能跟上面完全不同，請不要訝異上面下面對不起來。</strong></p><h1 id="如何測試-suspend-function"><a href="#如何測試-suspend-function" class="headerlink" title="如何測試 suspend function"></a>如何測試 suspend function</h1><p>測試一個單純的 <code>suspend</code> function 最簡單了，因為我們可以直接掛在 testScope 底下執行該 function，過程輕鬆簡單</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentValue = fetchRemoteWithDelay(currentValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemoteWithDelay</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar()</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, bar.currentValue)</span><br><span class="line">    bar.suspendableFetch()</span><br><span class="line">    assertEquals(<span class="number">1</span>, bar.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runTest</code> 會產生一個 <code>TestScope</code>，所以在它的 block 裡面，我們可以直接執行 <code>suspend</code> function 而不用擔心太多。</p><h1 id="以注入的-Scope-來執行-suspend-function-的程式，該如何測試"><a href="#以注入的-Scope-來執行-suspend-function-的程式，該如何測試" class="headerlink" title="以注入的 Scope 來執行 suspend function 的程式，該如何測試"></a>以注入的 Scope 來執行 suspend function 的程式，該如何測試</h1><p>以下的範例有個看起來很普通的函式 <code>asyncRead</code>，其實裡面會透過注入的 coroutine scope 執行 suspend function。<code>asyncRead</code> 會直接返回，但我們又想要測試 <code>currentValue</code> 是否有按照預期地被更動</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            currentValue = fetchRemote(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">(input: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的例子來說，<code>asyncRead</code> 是一個在任何地方都可以呼叫的普通函式，射後不理的特徵讓我們不知道該怎麼測試。但是它是掛在注入的 <code>injectedScope</code> 下來執行，其實很好解決。既然已經注入了 scope，那麼只要在 assert 之前確保 scope 把該做的事情都做完就好。要確保這件事情，就是出動 <code>runCurrent</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.runCurrent()</span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外還有其他寫法，譬如說底下的作法也會通</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;  <span class="comment">// 指定了 dispatcher</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    runCurrent()  <span class="comment">// 不需指定 scope</span></span><br><span class="line">    assertEquals(<span class="number">1</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要看懂上面這個寫法，就要先弄懂 <code>runTest</code> 做了什麼事。<code>runTest</code> 可以接受一個 CoroutineContext，用它生出一個新的 TestScope。而 <code>runCurrent</code> 雖然是 <code>TestScope</code> 的 extension，實際上拿 <code>TestScope</code> 裡面的 scheduler 來用。因為我們把 <code>testDispatcher</code> 塞給了 <code>runTest</code>，同時又把跟 <code>testDispatcher</code> 綁在一起的 <code>testScope</code> 注入進去 <code>foo</code>。所以 <code>runCurrent()</code> 用的 scheduler 是同一個。</p><p>結論就像下方的 pseudo code 演示的概念</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Just Psuedo Code **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theScheduler = testDispatcher.testScheduler</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest(theScheduler) &#123; theScheduler -&gt;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    theScheduler.runCurrent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以什麼時候會用 <code>runTest(testDispatcher)</code> 呢？<strong>想要確保 <code>runTest() &#123;....&#125;</code> 的 block 裡面是用哪個 scheduler 的時候</strong>。(另外也能寫成 <code>testScop.runTest &#123;...&#125;</code>，但我覺得寫 coroutine 的單元測試，控制流程進度應該從 Dispatcher 切入，而非 Scope，所以我都會避免這樣的寫法)</p><h1 id="ViewModel-如何測試"><a href="#ViewModel-如何測試" class="headerlink" title="ViewModel 如何測試"></a>ViewModel 如何測試</h1><p><strong>androidx.lifecycle.lifecycle-viewmodel-ktx</strong> 提供了一個 extension <code>ViewModel.viewModelScope</code>，讓你在 ViewModel 裡面可以莫名其妙就拿到一個 Coroutine Scope 來用。其實實作很簡單，就是拿 <code>Dispatchers.Main</code> 來生出一個 scope 而已。所以在寫單元測試的時候，只要把 Main Dispatcher 換成我們自己的 TestDispatcher 就搞定了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBarViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentValue: <span class="built_in">Int</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            updateValue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateValue</span><span class="params">()</span></span> = withContext(viewModelScope.coroutineContext) &#123;</span><br><span class="line">        currentValue = <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoobarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> foobarViewModel: FooBarViewModel = FooBarViewModel()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Dispatchers.setMain(testDispatcher) <span class="comment">// for testing foobarViewModel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testFoobarViewModel</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        foobarViewModel.testFunc()</span><br><span class="line"></span><br><span class="line">        assertEquals(-<span class="number">1</span>, foobarViewModel.currentValue)</span><br><span class="line">        runCurrent()</span><br><span class="line">        assertEquals(<span class="number">9527</span>, foobarViewModel.currentValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果跳進去看實作，就會看到 <code>StandardTestDispatcher</code> 跟 <code>UnconfinedTestDispatcher</code> 在建立的時候，如果沒有指定 Scheduler，就會拿同一個 Scheduler 來用，而且是同一個。而且執行 <code>Dispatcher.setMain</code> 的時候把這個 Dispatchers 指定給 Main，<code>TestSceop</code> 也說建購的時期如果沒有指定 Dispatcher，也會拿 Main Dispatcher 來用。所以到最後，這幾個背後都是同一個 Scheduler，也因此 <code>runCurrent</code> 幾乎是隨便亂用都會動(嘖嘖)。</p><h1 id="StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪"><a href="#StandardTestDispatcher-跟-UnconfinedTestDispatcher-差別在哪" class="headerlink" title="StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪"></a>StandardTestDispatcher 跟 UnconfinedTestDispatcher 差別在哪</h1><p>官方 Guide 會看到這句話</p><blockquote><p>In these cases, UnconfinedTestDispatcher() should be used. We ensured that, when run with an UnconfinedTestDispatcher, runTest also eagerly enters launch and async blocks.</p></blockquote><p>當一個 coroutine 由 <code>UnconfinedTestDispatcher</code> 所啟動 (launch)，它會積極地在 caller 的 thread 執行。也就是說當你用這個 Dispatcher 跑起了一個 coroutine，它裡面又產生了一個 coroutine，那麼 <code>UnconfinedTestDispatcher</code> 會盡量去執行這個新的 coroutine。舉例來說</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foobar</span></span>(injectedDispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(injectedDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine A</span></span><br><span class="line">            funA()</span><br><span class="line">        &#125;</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funB()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funA</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcA&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine C</span></span><br><span class="line">           funC()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcA&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funB</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&gt; before funcB&quot;</span>)</span><br><span class="line">        scope.launch &#123; <span class="comment">// coroutine B</span></span><br><span class="line">            funcD()</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;&lt; after funcB&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funC</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;running funcC&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">funcD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;running funcD&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>printMsg</code> 會產生兩個 coroutine，一個跑 <code>funA</code>，一個跑 <code>funB</code>。<code>funA</code> 執行的時候會 launch 一個 coroutine 來跑 <code>funC</code>，<code>funB</code> 也會 launch 一個 coroutine 來跑 <code>funD</code></p><p>用 <code>StandardTestDispatcher</code> 的測試程式如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">    assert(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>如果把依序把 <code>funA</code> 產生的 coroutine 稱為 <code>coroutine A</code>，那麼執行的順序就是</p><ol><li>coroutine A</li><li>coroutine B</li><li>coroutine C</li><li>coroutine D</li></ol><p>接著改用 <code>UnconfinedTestDispatcher</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> theDispatcher: TestDispatcher = UnconfinedTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foobar: Foobar = Foobar(theDispatcher)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFooBar</span><span class="params">()</span></span> = runTest(theDispatcher) &#123;</span><br><span class="line">    foobar.printMsg()</span><br><span class="line">    runCurrent()</span><br><span class="line">    println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">results:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; before funcA</span></span><br><span class="line"><span class="comment">&lt; after funcA</span></span><br><span class="line"><span class="comment">running funcC</span></span><br><span class="line"><span class="comment">&gt; before funcB</span></span><br><span class="line"><span class="comment">&lt; after funcB</span></span><br><span class="line"><span class="comment">running funcD</span></span><br><span class="line"><span class="comment">Done</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>執行順序變成</p><ol><li>coroutine A</li><li>coroutine C</li><li>coroutine B</li><li>coroutine D</li></ol><p>A 排在 B 前面，而 A 裡面產生的 C 被 Dispatcher 積極執行，所以插隊在 B 前面，這就是 Guide 裡面說的 Eagerly</p><p>如果你的實作混用了其他 library 的非同步功能(ie: Rx)，有時候用 <code>UnconfinedTestDispatcher</code> 可以讓程式的執行順序跑得比較像一般函式呼叫的順序。但是長久來說，還是避免一堆工具混在一起作牛丸，盡量用單一工具來做非同步比較好。</p><h1 id="何時使用-advanceTimeBy"><a href="#何時使用-advanceTimeBy" class="headerlink" title="何時使用 advanceTimeBy"></a>何時使用 advanceTimeBy</h1><p>有時候會用到 <code>delay</code> 或是其他函式對一個 coroutine 的執行時間作調整</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentValue = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            delay(<span class="number">2000</span>) <span class="comment">// 白金之星！...好吧，它是 delay 而非暫停時間</span></span><br><span class="line">            currentValue = <span class="number">9527</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>advanceTimeBy</code> 可以把 dispatcher 裡面的虛擬時鐘調快，就像老闆的替身能力克里姆王的那樣刪除一段時間</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    foo.asyncRead()</span><br><span class="line">    assertEquals(-<span class="number">1</span>, foo.currentValue)</span><br><span class="line"></span><br><span class="line">    testScope.advanceTimeBy(<span class="number">3000</span>) <span class="comment">// 老闆能力發動！</span></span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.currentValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Troubleshooting-用到兩個-TestDispatcher-會出錯"><a href="#Troubleshooting-用到兩個-TestDispatcher-會出錯" class="headerlink" title="Troubleshooting: 用到兩個 TestDispatcher 會出錯"></a>Troubleshooting: 用到兩個 TestDispatcher 會出錯</h1><p>有時候會看到這個錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br><span class="line">java.lang.IllegalStateException: Detected use of different schedulers. If you need to use several test coroutine dispatchers, create one `TestCoroutineScheduler` and pass it to each of them.</span><br></pre></td></tr></table></figure><p>那是因為不小心產生了兩個 TestDispatcher，好比以下這段程式，使用 <code>withContext</code> 的時候經常發生這個錯誤。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>(<span class="keyword">val</span> dispatcher: CoroutineDispatcher) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendableFunc</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(dispatcher)&#123; <span class="comment">// 這裡用注入的 Dispatcher</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: Bar = Bar(testDispatcher)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest &#123; <span class="comment">// runTest 自己產生一個 Dispatcher，接著再以此生出 TestScope</span></span><br><span class="line">        bar.suspendableFunc()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bar.suspendableFunc()</code> 會用注入的 Dispathcer，<code>runTest</code> 如果不指定一個 <code>TestDispatcher</code>，它內部實作也會產生一個新的。</p><p>讓兩邊都用同一個 TestDispatcher 就可以解決問題。下面就是讓 runTest 使用同一個 Dispatcher</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testBar</span><span class="params">()</span></span> = runTest(testDispatcher) &#123;</span><br><span class="line">    bar.suspendableFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果有個函式用到-withContext-Dispatcher-IO-，該如何測試"><a href="#如果有個函式用到-withContext-Dispatcher-IO-，該如何測試" class="headerlink" title="如果有個函式用到 withContext(Dispatcher.IO)，該如何測試"></a>如果有個函式用到 withContext(Dispatcher.IO)，該如何測試</h2><p>有時候我們會看到以下這樣的作法。<code>fetchRemote</code> 是個跑在 <code>Dispatcher.IO</code> 上面的耗時函數，外部呼叫 <code>asyncRead</code> 之後就可以射後不理，等到 <code>returnValue</code> 更新了，再去更新 UI</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> injectedScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="keyword">var</span> returnedValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asyncRead</span><span class="params">()</span></span> &#123;</span><br><span class="line">        injectedScope.launch &#123;</span><br><span class="line">            returnedValue = fetchRemote()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> <span class="number">9527</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要測試 <code>asyncRead</code> 就會變得很麻煩，雖然已經注入了一個 <code>injectedScope</code>，但是在 <code>fetchRemote</code> 跑在我們測試程式碼裡面完全碰不到的 <code>Dispatchers.IO</code>。</p><p>有個滿噁心的寫法：利用 <code>withContext</code> 來測試。</p><p><code>withContext</code> 會拿當下的 coroutine context 跟透過參數指定進去的 context，兩個 merge 起來產生新的 context，接著用新的 context 裡面的 coroutine scope 執行 block 裡面的程式，直到該 scope 完成之後才離開 block。所以單元測試只要拿 <code>withContext</code> 產生的 scop 注入進去測試對象就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    <span class="keyword">var</span> localFoo: Foo</span><br><span class="line">    withContext(testDispatcher) &#123;</span><br><span class="line">        localFoo = Foo(<span class="keyword">this</span>) <span class="comment">// `this` is a coroutineScope that created by withContext</span></span><br><span class="line">        localFoo.asyncRead()</span><br><span class="line">        assertEquals(<span class="number">0</span>, localFoo.returnedValue)</span><br><span class="line">    &#125;</span><br><span class="line">    assertEquals(<span class="number">9527</span>, localFoo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我覺得測試寫成這樣太過取巧，很可能遭天譴或是被人恥笑。有辦法修改的話，還是把類別改寫得比較容易測試才是正途。譬如說”inject Dispatcher” + “default value”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> coroutineScope: CoroutineScope,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> ioDispatcher: CoroutineDispatcher = Dispatchers.IO</span><br><span class="line">) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchRemote</span><span class="params">()</span></span>: <span class="built_in">Int</span> = withContext(ioDispatcher) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scope, dispatcher, 球員，裁判都是我的，測試就會變得很好寫</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testDispatcher: TestDispatcher = StandardTestDispatcher()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> testScope: TestScope = TestScope(testDispatcher)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> foo: Foo = Foo(testScope, testDispatcher)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFoo</span><span class="params">()</span></span> = runTest &#123;</span><br><span class="line">    assertEquals(<span class="number">0</span>, foo.returnedValue)</span><br><span class="line">    foo.asyncRead()</span><br><span class="line"></span><br><span class="line">    runCurrent()</span><br><span class="line">    assertEquals(<span class="number">9527</span>, foo.returnedValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>寫 coroutine 的單元測試，主要是要先搞懂當下在用的是哪個 Scope 或 Dispatcher，釐清它執行的順序，接著就是確保在 assert 之前把該做的事情做完。既然談到執行順序，又回到大家早就知道的概念，實作的時候要適當地注入 Dispatcher，這樣測試才會好寫。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前因為工作的需要，把 kotlin 從 &lt;code&gt;1.5.2&lt;/code&gt; 升級到 &lt;code&gt;1.6.0&lt;/code&gt;，同時修了許多 unit test 相關的問題，在這邊紀錄一下過程，給需要幫助的朋友。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
    <category term="android" scheme="https://jchu.cc/tags/android/"/>
    
    <category term="kotlin" scheme="https://jchu.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>紀錄三讀通過交通處罰條例</title>
    <link href="https://jchu.cc/2021/12/10-ly.html"/>
    <id>https://jchu.cc/2021/12/10-ly.html</id>
    <published>2021-12-10T13:32:34.000Z</published>
    <updated>2021-12-10T14:48:04.034Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css">    ol li {        line-height: 1.3rem;    }    .del {        background-color: #FCC;    }    .add {        background-color: #CFC;    }</style><p>今天看到<strong>道路交通管理處罰條例第七條之二條文修正草案</strong>三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下</p><span id="more"></span><h1 id="三讀通過的條文"><a href="#三讀通過的條文" class="headerlink" title="三讀通過的條文"></a>三讀通過的條文</h1><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100412:LCEWA01_100412_00092">立法院第 10 屆第 4 會期第 12 次會議議案關係文書</a> (備份檔： <a href="/2021/12/10-ly/final.pdf" title="final.pdf">final.pdf</a> )</p><p>法條修改的部份如下</p><p><strong>現行條文</strong></p><blockquote><p>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p></blockquote><p><strong>通過條文</strong></p><blockquote><p>第七條之一 民眾對於下列違反本條例之行為者，得敘明違規事實並檢具違規證據資料，向公路主管或警察機關檢舉：<br>(…..略….)<br>公路主管機關或警察機關對於第一項之檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。民眾依第一項規定檢舉同一輛汽車二以上違反本條例同一規定之行為，其違規時間相隔未逾六分鐘及行駛未經過一個路口以上，公路主管或警察機關以舉發一次為限。公路主管或警察機關對第一項檢舉之逕行舉發，依本條例第七條之二第五項規定辦理。</p></blockquote><p>主要的變化是，原本民眾可以針對道路交通管理處罰條例的違規事項做檢舉，現在變成只有正面表列的違規事項才能檢舉。「略」裏面放了一長串的條文 reference，指出哪些違規事項是民眾可以檢舉的，底下列出各個被參考條文的大意</p><ol><li><p>第三十條第一項第二款。</p><ul><li>汽車裝載時，有下列情形之一者…所載貨物滲漏、飛散、脫落、掉落或氣味惡臭。</li></ul></li><li><p>第三十一條第六項或第三十一條之一第一項至第三項。</p><ul><li>機車駕駛人或附載座人未依規定戴安全帽者，處駕駛人新臺幣五百元罰鍰。</li><li>汽車駕駛人於行駛道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣三千元罰鍰。</li><li>機車駕駛人行駛於道路時，以手持方式使用行動電話、電腦或其他相類功能裝置進行撥接、通話、數據通訊或其他有礙駕駛安全之行為者，處新臺幣一千元罰鍰。</li><li>汽機車駕駛人行駛於道路，手持香菸、吸食、點燃香菸致有影響他人行車安全之行為者，處新臺幣六百元罰鍰。</li></ul></li><li><p>第三十三條第一項第二款、第三款、第四款、第七款、第九款、第十一款至第十六款、第四項或第九十二條第七項。</p><ul><li>汽車行駛於高速公路、快速公路或設站管制之道路…有下列行為者…<ul><li>未保持安全距離</li><li>未依規定行駛車道</li><li>未依規定變換車道</li><li>違規超車、迴車、倒車、逆向行駛</li><li>未依規定使用路肩</li><li>裝置貨物未依規定覆蓋、捆紮。</li><li>未依標誌、標線、號誌指示行車。</li><li>進入或行駛禁止通行之路段。</li><li>連續密集按鳴喇叭、變換燈光或其他方式迫使前車讓道。</li><li>行駛中向車外丟棄物品或廢棄物。</li><li>車輪、輪胎膠皮或車輛機件脫落</li></ul></li><li>不得行駛或進入第一項道路之人員、車輛或動力機械，而行駛或進入者</li><li>汽缸排氣量五百五十立方公分以上之大型重型機車行駛高速公路，有下列行為者…..</li></ul></li><li><p>第四十二條。</p><ul><li>汽車駕駛人，不依規定使用燈光者</li></ul></li><li><p>第四十三條第一項第一款、第三款、第四款或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者…道路上蛇行，或以其他危險方式駕車</li></ul></li><li><p>第四十四條第二項或第三項。</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一者<ul><li>行近未設行車管制號誌之行人穿越道，不減速慢行</li><li>行經設有彎道、坡路、狹路、狹橋或隧道標誌之路段或道路施工路段，不減速慢行</li></ul></li></ul></li><li><p>第四十五條第一項第一款、第三款、第四款、第六款、第十三款、第十六款或第二項。</p><ul><li>汽車駕駛人，爭道行駛有下列情形之一者….<ul><li>不按遵行之方向行駛</li><li>不依規定駛入來車道</li><li>在多車道不依規定駕車</li><li>駕車行駛人行道</li><li>機車不在規定車道行駛</li><li>佔用自行車專用道</li></ul></li><li>聞消防車、救護車、警備車、工程救險車、毒性化學物質災害事故應變車之警號，不立即避讓者</li></ul></li><li><p>第四十七條。</p><ul><li>汽車駕駛人超車時，有下列情形之一者…..注：各種危險超車</li></ul></li><li><p>第四十八條第一項第二款、第四款、第五款或第七款。</p><ul><li>汽車駕駛人轉彎或變換車道時，有下列情形之一者….不依標誌、標線、號誌指示</li></ul></li><li><p>第四十九條。</p><ul><li>汽車駕駛人迴車時，有下列情形之一者…注：各種危險迴轉</li></ul></li><li><p>第五十三條或第五十三條之一。</p><ul><li>汽車駕駛人，行經有燈光號誌管制之交岔路口闖紅燈者，及前項紅燈右轉行為者</li><li>車駕駛人，行經有燈光號誌管制之大眾捷運系統車輛共用通行交岔路口闖紅燈者，及前項紅燈右轉行為者</li></ul></li><li><p>第五十四條。</p><ul><li>汽車駕駛人，駕車在鐵路平交道有下列情形之一者….注：各種平交道危險事項</li></ul></li><li><p><code>第五十五條第一項第二款或第四款併排臨時停車。</code></p></li><li><p><code>在第五十五條第一項第二款規定禁止臨時停車之處所停車。</code></p></li><li><p><code>第五十六條第一項第十款及第二項。</code></p></li><li><p>第六十條第二項第三款</p><ul><li>汽車駕駛人，駕駛汽車有下列情形之一，而本章各條無處罰之規定者….注：各種不遵守指揮的行為</li></ul></li></ol><p>上面可以看到列了一大堆東西，其實都是一般人不太會去檢舉的事項，我們最關心的就是違規停車。也就是第 13, 14, 15 個項目提及的東西。第五十五條跟第五十六條裡面，我們還剩下哪些能檢舉呢？</p><p>塗上紅色的，就是民眾在修法過後，不能檢舉的事項</p><p>第 55 條</span></p><ol><li><span class="del">汽車駕駛人，臨時停車有下列情形之一者，處新臺幣三百元以上六百元以下罰鍰：</span><ul><li><span class="del">一、在橋樑、隧道、圓環、障礙物對面、人行道、行人穿越道、快車道臨時停車。</span></li><li><span class="add">二、在交岔路口、公共汽車招呼站十公尺內或消防車出、入口五公尺內臨時停車。</span></li><li><span class="del">三、在設有禁止臨時停車標誌、標線處所臨時停車。</span></li><li><span class="add">四、不依順行之方向，或不緊靠道路右側，或單行道不緊靠路邊，或併排臨時停車。</span></li><li><span class="del">五、在道路交通標誌前臨時停車，遮蔽標誌。</span></li></ul></li><li><span class="del">接送未滿七歲之兒童、行動不便之人上、下車者，臨時停車不受三分鐘之限制。</span></li></ol><p>第 56 條</p><ol><li><span class="del">汽車駕駛人停車時，有下列情形之一者，處新臺幣六百元以上一千二百元以下罰鍰：</span><ul><li><span class="del">一、在禁止臨時停車處所停車。</span></li><li><span class="del">二、在設有彎道、險坡、狹路標誌之路段、槽化線、交通島或道路修理地段停車。</span></li><li><span class="del">三、在機場、車站、碼頭、學校、娛樂、展覽、競技、市場、或其他公共場所出、入口或消防栓之前停車。</span></li><li><span class="del">四、在設有禁止停車標誌、標線之處所停車。</span></li><li><span class="del">五、在顯有妨礙其他人、車通行處所停車。</span></li><li><span class="del">六、不依順行方向，或不緊靠道路右側，或單行道不緊靠路邊停車。</span></li><li><span class="del">七、於路邊劃有停放車輛線之處所停車營業。</span></li><li><span class="del">八、自用汽車在營業汽車招呼站停車。</span></li><li><span class="del">九、停車時間、位置、方式、車種不依規定。</span></li><li><span class="add">十、於身心障礙專用停車位違規停車。</span></li></ul></li><li><span class="add">汽車駕駛人停車時，有併排停車之情事者，處汽車駕駛人新臺幣二千四百元罰鍰。</span></li><li><span class="del">汽車駕駛人在道路收費停車處所停車，依規定繳費，主管機關應書面通知駕駛人於七日內補繳，並收取必要之工本費用，逾期再不繳納，處新臺幣三百元罰鍰。</span></li><li><span class="del">第一項及第二項情形，交通勤務警察、依法令執行交通稽查任務人員或交通助理人員，應責令汽車駕駛人將車移置適當處所；如汽車駕駛人不予移置或不在車內時，得由該交通勤務警察、依法令執行交通稽查任務人員或交通助理人員為之。</span></li><li><span class="del">第一項第十款應以最高額處罰之，第三項之欠費追繳之。</span></li><li><span class="del">在圓環、交岔路口十公尺內，公路主管機關、市區道路主管機關或警察機關得在不妨害行人通行或行車安全無虞之原則，設置必要之標誌或標線另行規定汽車之停車處所。</span></li></ol><h1 id="委員提案"><a href="#委員提案" class="headerlink" title="委員提案"></a>委員提案</h1><p>看完了三讀通過的法案，再看一下立委的原始提案。</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100114:LCEWA01_100114_00063">院總第 756 號 委員提案第 24811 號</a> (備份檔： <a href="/2021/12/10-ly/24811.pdf" title="24811.pdf">24811.pdf</a> )</p><p>提案人：陳歐珀<br>連署人：莊競程 陳亭妃 賴惠員 賴品妤 莊瑞雄 林楚茵 吳玉琴 楊 曜 黃國書 黃秀芳 王美惠 邱泰源 劉世芳 陳明文 洪申翰 何欣純 林宜瑾 范雲</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/24811.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="del">應即舉發</span>。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，<span class="add">先給予勸導，若同一違規事實再犯者，即予舉發</span>。但行為終了日起逾七日之檢舉，不予舉發</p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100202:LCEWA01_100202_00068aa">院總第 756 號 委員提案第 25053 號</a> (備份檔： <a href="/2021/12/10-ly/25053.pdf" title="25053.pdf">25053.pdf</a> )</p><p>提案人：鄭正鈐<br>連署人：陳玉珍 翁重鈞 鄭天財 Sra Kacaw 張育美 謝衣鳯 李貴敏 李德維 吳怡玎 陳以信 呂玉玲 廖婉汝 魯明哲 陳雪生 洪孟楷 林文瑞 徐志榮 葉毓蘭 林德福 孔文卲 林思銘 吳斯懷 溫玉霞 蔣萬安</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/25053.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">對於不影響交通安全之違規檢舉案件，應先開立勸導單，其類型由主管機關定之。</span></p><p><a href="https://lis.ly.gov.tw/lygazettec/mtcdoc?PD100306:LCEWA01_100306_00015">院總第 756 號 委員提案第 26098 號</a> (備份檔： <a href="/2021/12/10-ly/26098.pdf" title="26098.pdf">26098.pdf</a> )</p><p>提案人：林俊憲 林宜瑾<br>連署人：陳歐珀 羅美玲 蘇巧慧 陳明文 趙天麟 邱議瑩 陳素月 賴惠員 劉建國 周春米 蔡易餘 蘇治芬 邱志偉 劉櫂豪</p><div style="max-width: 100%; margin: auto;"><img src="/2021/12/10-ly/26098.jpg" class=""></div><p><strong>現行條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。</p><p><strong>修正條文</strong><br>第七條之一 對於違反本條例之行為者，民眾得敘明違規事實或檢具違規證據資料，向公路主管或警察機關檢舉，經查證屬實者，應即舉發。但行為終了日起逾七日之檢舉，不予舉發。<span class="add">兩件違規舉發事項之時間需相隔六分鐘以上或行駛經過一個路口以上。</span></p><h1 id="我的想法"><a href="#我的想法" class="headerlink" title="我的想法"></a>我的想法</h1><p>我是相當在意交通環境的人，長期以來對於台灣的交通一直都是非常失望。好不容易近幾年來大家開始知道要尊重行人路權，知道要減少違規停車，交通安全意識要開始進步的時候，立委修法限縮了這個人民對付交通惡霸的武器。</p><p>不管修法的方向是什麼，總是要有個冠冕堂皇的理由。今天立委們刻意放大「惡意檢舉」的案例來強化自己修法的正當性，而避談無獎金的踴躍檢舉，是因為民眾對糟糕的交通環境累積的長期不滿，現在立委的修法討好了喜歡貪便宜的人，犧牲的是乖乖遵守交通規則的人</p><p>修法的提案人，有國民黨的鄭正鈐，也有民進黨的陳歐珀，林俊憲，林宜瑾。為了討好民眾，甘願犧牲台灣長久利益的這種作為，藍綠沒什麼差別。</p><p>我不談道德，只談利益。遵守規則往往也要付出成本，如果不能讓迴避規則的人承受更大的壓力，要怎麼說服多數的人去遵守交通規則呢？</p><p>今天立委這樣的修法，正是告訴人民：違規停車只要沒被警察看到，就沒關係。如果你會為了交通安全，乖乖地花錢把車停到停車場，再花三十分鐘來回只為買個便當？那是你笨，不懂得精打細算省錢省時間</p><p>我當這種笨蛋很多年了，今天我真是深深覺得自己笨得可以</p><p>立委都開綠燈了，台灣的交通安全？你要學著當聰明用路人啊！</p><h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul><li><a href="https://www.youtube.com/watch?v=3pRnMH1iqrA"> 羅火花 - 縮限檢舉來啦！大違規時代人行道紅線爽違停！我教你怎樣減少違規停車啦立委們！</a></li><li><a href="https://www.thenewslens.com/article/135482">要消滅檢舉達人，形象清新的賴品妤為何成為「羅淑蕾第二」？</a></li><li><a href="https://www.thenewslens.com/article/132505">這天新竹碾死一個機車騎士，真正的兇手是充滿人情味的「微罪不罰」</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;style type=&quot;text/css&quot;&gt;
    ol li {
        line-height: 1.3rem;
    }
    .del {
        background-color: #FCC;
    }
    .add {
        background-color: #CFC;
    }

&lt;/style&gt;

&lt;p&gt;今天看到&lt;strong&gt;道路交通管理處罰條例第七條之二條文修正草案&lt;/strong&gt;三讀通過的事，有人戲稱為大違規時代的來臨，覺得值得紀錄一下&lt;/p&gt;</summary>
    
    
    
    <category term="ramble" scheme="https://jchu.cc/categories/ramble/"/>
    
    
    <category term="taiwan" scheme="https://jchu.cc/tags/taiwan/"/>
    
    <category term="political" scheme="https://jchu.cc/tags/political/"/>
    
    <category term="government" scheme="https://jchu.cc/tags/government/"/>
    
  </entry>
  
  <entry>
    <title>ActivityPub 簡單介紹</title>
    <link href="https://jchu.cc/2021/07/27-activitypub.html"/>
    <id>https://jchu.cc/2021/07/27-activitypub.html</id>
    <published>2021-07-27T12:43:59.000Z</published>
    <updated>2021-07-27T14:57:33.752Z</updated>
    
    <content type="html"><![CDATA[<p><a href="devpoga.org">Poga</a> 架了 <a href="https://g0v.social/">g0v.social</a> 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。</p><p>不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。</p><span id="more"></span><p>Mastodon 是一個類似 Twitter 的 Microblog service application，比起 Twitter 這樣的集中式服務，Mastodon 讓你對自己帳號的掌控權「更多一點」。</p><p>Mastodon 稱自己為去中心化、聯邦式(Federation)的程式。</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_federation.svg" class=""></div><p>Twitter 是集中式(Centralized)的服務，我們都很清楚 Centralized 的運作方式：要連上一個別人管理的網站，在上面註冊帳號、與其他帳號互動。</p><p>Git 就是我們習慣的分散式(Distributed)工具，在 Git 的使用情境裡，任何人都可以弄個 repository 成為別人的 upstream，彼此之間地位相等，隨時可以增加或減少網絡裡的節點。</p><p>Federation 則是介於兩者中間。基本上我們還是要連上某個別人架設好的伺服器；當然你要自己 host 一個也可以。各個服務器之間透過一個公認的規則(ActivityPub)交換訊息，或是透過某種潛規則排擠某一個伺服器。</p><p>於是乎，我就有了三個問題</p><ol><li>如果我的帳號在 Server A，而我的朋友十分鐘前剛剛自己架了一個 Server B，我有辦法 follow 他在新伺服器的帳號嗎？<ul><li>簡答：基本上可以，但有可能不行</li></ul></li><li>當我寫了一個新的 Post，我的 100 個 follower(來自 20 個不同 servers) 該怎麼知道我的新貼文？<ul><li>簡答：由 Server to Server federation protocol 處理</li></ul></li><li>既然沒有一個專屬的機構負責當真理部，該如何避免 spam 或是仇恨言論？<ul><li>簡答：潛規則的政治手段解決</li></ul></li></ol><p>查詢相關的 Spec，一定會看到三個 W3C spec: Activity Vocabulary, ActivityStream 與 ActivityPub</p><p>其實我覺得這三份文件，比起 RFC 都寫得滿籠統，定義會在三者之間相互指涉，看到後面都不懂某個名詞的確切意義是什麼，可能是我看 W3C 規格的功力不夠，這三份又特別有彈性。</p><p>我盡可能列出我對這三份文件的理解。以我的淺薄理解，很明顯對於實作沒有太大的幫助，可能要看過 Mastodon 的程式碼的人比較能回答細節的問題。</p><h3 id="Activity-Vocabulary"><a href="#Activity-Vocabulary" class="headerlink" title="Activity Vocabulary"></a>Activity Vocabulary</h3><blockquote><p>It is intended to be used in the context of the ActivityStreams 2.0 format and provides a foundational vocabulary for activity structures, and specific activity types.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-vocabulary/">Activity Vocabulary</a></li></ul><p>這一份文件為 ActivityStream 會用到的字彙給出更細微的定義，定義每個 Type 或是 property 的意義。這裡面定義了三個 Core types <code>Object</code> <code>Link</code> and <code>Activity</code>。他們之間以及子類別的關係大致如下</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_activity_vocabulary.svg" class=""></div><p>雖然 Activity Vocabulary 只定義了一些類別，但是開發者可以添加更多的延伸類別(由 Activity Stream 定義)。</p><p>一個基本的 Activity 看起來像這樣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@context&quot;</span>: <span class="string">&quot;https://www.w3.org/ns/activitystreams&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Activity&quot;</span>,</span><br><span class="line">  <span class="string">&quot;summary&quot;</span>: <span class="string">&quot;Sally did something to a note&quot;</span>,</span><br><span class="line">  <span class="string">&quot;actor&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Sally&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Note&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;A Note&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity Vocabulary 文件試著解釋每個 property 的用處為何。在閱讀 spec 的時候看到 <code>Domain</code> 指的是這個 property 可以被用在哪個 type 上面。<code>Range</code> 則是說這個 property 可以塞進哪些值</p><h3 id="Activity-Stream"><a href="#Activity-Stream" class="headerlink" title="Activity Stream"></a>Activity Stream</h3><blockquote><p>This specification details a model for representing potential and completed activities using the JSON format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitystreams-core/">ActivityStream</a></li></ul><p>以 JSON 的格式，拿 Activity Vocabulary 定義好的 properties, type 來組合使用，呈現「活動」(actities)，換句話說，這份文件定義了，Activity Vocabulary 定義好的東西，該怎麼拿來用，才能呈現一個事件(Activity)</p><p>這個 Spec 對大多數的 Object 僅僅只有定義不完備的語意，所以可以在 Activity Vocabulary 之外延伸定義更多的細節，也能定義新的 Object type。但是如果仰賴太多延伸定義的類型，那麼 Server 之間會不能溝通</p><h3 id="ActivityPub"><a href="#ActivityPub" class="headerlink" title="ActivityPub"></a>ActivityPub</h3><blockquote><p>The ActivityPub protocol is a decentralized social networking protocol based upon the ActivityStreams 2.0 data format.</p></blockquote><ul><li><a href="https://www.w3.org/TR/activitypub/">ActivityPub</a></li></ul><p>以 ActivityStream 為基礎，定義出去中心化的社交網路協定分成兩部分</p><ul><li>Server to server federation protocol</li><li>Client to server protocol</li></ul><p>這份 Spec 裡面介紹了什麼是 Actor 以及幾個常見的 Activity</p><p>我們所創立的帳號就是 Actor (有沒有其他 Actor 我不確定)。一個 Actor 必須要有這些欄位</p><ul><li>inbox (OrderedCollection)</li><li>outbox (OrderedCollection)</li><li>following</li><li>followers<ul><li>記錄這個 Actor 有多少 follower。以後新增 Activity 的時候會通知這些 follower</li><li>實作上可以設定 filter 讓 authenticated user 有更高的優先權</li></ul></li><li>liked</li><li>streams</li><li>……</li></ul><p>Activity 就是 Actor 在平台上產生的活動，包括但不限於送訊息、追蹤別人、發貼文等等</p><p>Spec 裡面舉例了訊息該怎麼傳遞，畫成圖就是下面的樣子。每個帳號(Actor)都會有一個 INBOX 與 OUTBOX，送出訊息的話，先是把訊息透過 Client-to-Server-protocol 寫進自己的 OUTBOX，接著再由 Server-to-Server-federation-protol 把訊息送到對方的 INBOX。對方上線後去看自己的 INBOX 就能讀到訊息</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_send_message.svg" class=""></div><p>從上面的訊息傳遞，可以看到一個重點：</p><p><strong>Server 之間的訊息傳遞，是以 POST 為主，而非 GET</strong></p><p>也就是說，當 Actor B 想要知道 Actor A 有沒有送訊息過來，並非發出請求叫 Server B 去 Server A 看看 Actor A 的 OUTBOX，而是 Server A 比需要主動檢查 Actor A 的 OUTBOX，把訊息傳遞給對應的 Server B (也可能是其他 Server)。如果 Server A 沒做好這件事情，則 Actor B 永遠不會知道 Actor A 對 B 說了某些話。這個互動的模型看起來是發生在 ActivityPub 的所有 Server-to-Server-federation-protocol 上面，也影響了後續的很多行為</p><p>接著來看 Follow，假設有 Actor A 想要 Follow Actor B</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_follow_activity.svg" class=""></div><p>Actor A 發出了一個 Follow Activity 想要訂閱 Actor B，到 Step 3 之前都跟前面一樣。Step 4 就是一個由實作彈性決定的步驟：「要不要接受這個 follow」，也就是說要不要送出一個 Accept Activity</p><p>以 Twitter 的行為來舉例的話，就是「預設 Accept 所有的 Follow Request」，但是在 Activity Pub 裡面可以有 Reject 的空間，也可以預設就是 Accept</p><p>這邊的重點在於 <strong>發出的 <code>Follow Activity</code> 要被接受，才會把 Actor 放進 Follower</strong>。回到上一段講到的重點，Server 之間的互動是以 POST 為主。當 Actor A 的 Follow activity 被 Actor B 接受之後，Actor B 才會把 A 放進 Follower 的清單裡面。當 Actor B 發出新貼文的時候，只會通知 Follower。如果 A 不在清單裡面，那麼它不會知道 B 有新的貼文</p><p>畫成圖片就像這樣</p><div style="max-width: 100%; margin: auto;"><img src="/2021/07/27-activitypub/ap_create_activity.svg" class=""></div><p>Actor B 寫了一篇新文，產生了 <code>Create Activity</code>，Step 2 找出 Actor B 想要通知 (POST) 的對象，然後把訊息送出去 (Step 3, 4, 5)。送出的接受對象可能是單一的 Actor，也可能是一個共用的 INBOX</p><p>ActivityPub 裡面就大概定義了這些看起來滿高階的行為，但是更細節的部分就沒討論到，大概是保留實作的彈性吧</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>回到前面一開始的三個問題。理論上只要 Server 可以把 Follow Activity 送到其他 Server，那麼我就可以追蹤任意 Server 上面的帳號。但是 Server 之間可以相互封鎖對方，因此我認為答案是 Yes and No。問題二上面已經回答了。至於問題三，我認為是透過 Server 之間的封鎖(過濾)行為來達成的。</p><p>Server admin 可以決定哪些 Server 的訊息可以進來，就像每個城市都可以決定規則，允許哪些外人進入城內。對於總是產出壞人的城市予以拒絕，對於表現優良的城市給予通行，於是 Server 之間就組成了 Federation。Mastodon 的服務群，還能夠組成 <a href="https://en.wikipedia.org/wiki/Fediverse">Fediverse</a>。</p><p>Serve 之間是依照彼此的價值觀組成一個群體，所以我認為是潛規則驅動，用政治方式解決仇恨言論的問題。有興趣的還可以看這篇 <a href="https://www.theverge.com/2019/7/12/20691957/mastodon-decentralized-social-network-gab-migration-fediverse-app-blocking">How the biggest decentralized social network is dealing with its Nazi problem</a>。至於 Server 內的仇恨言論？當然就由 Admin 決定要不要一巴掌拍死囉</p><p>對於一般來說使用者來說還是受制於 Server admin 的管轄，所以我會說使用者只是對自己的帳號稍微多了一點掌控權(你不一定要從某個你很討厭的 server 加入 federation)</p><p>雖然這樣感覺起來似乎有稍微擺脫科技巨頭的箝制。但是回頭想想，Hosting, Domain name 跟我們註冊的 e-mail 帳號還是給大公司牢牢抓著，小個體戶擁有的自由依然比想像中小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;devpoga.org&quot;&gt;Poga&lt;/a&gt; 架了 &lt;a href=&quot;https://g0v.social/&quot;&gt;g0v.social&lt;/a&gt; 之後就有在用。雖然分散式的版本處理系統 git 用了很久，但是一直想不透去中心化的社交網站是怎麼運作。也是大概等到 Trump 的 Twitter 帳號被封，大家開始討論科技巨頭握有太多權力，我才想起來要好好看一下 Mastodon 的 Spec。&lt;/p&gt;
&lt;p&gt;不過我看完之後還是矇矇懂懂，所以請不要對這篇有什麼期待，哈。&lt;/p&gt;</summary>
    
    
    
    <category term="geek" scheme="https://jchu.cc/categories/geek/"/>
    
    
    <category term="geek" scheme="https://jchu.cc/tags/geek/"/>
    
  </entry>
  
</feed>
